/* eslint-disable */
import { Injectable, Input as Input$1, Output, Directive, NgModule, EventEmitter, ElementRef, NgZone, ViewContainerRef, ViewChild, Optional, Component, ContentChildren, QueryList, Inject, forwardRef, ContentChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgControl, FormsModule } from '@angular/forms';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var mobiscroll = mobiscroll || {},
    util = {},
    calendars = {};

var os,
    vers,
    majorVersion,
    minorVersion,
    version = [],
    isBrowser = typeof window !== 'undefined',
    isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,
    userAgent = isBrowser ? navigator.userAgent : '',
    platform = isBrowser ? navigator.platform : '',
    maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,
    isSafari = /Safari/.test(userAgent),
    device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),
    raf = isBrowser && window.requestAnimationFrame || function (func) {
  return setTimeout(func, 20);
},
    rafc = isBrowser && window.cancelAnimationFrame || function (id) {
  clearTimeout(id);
};

if (/Android/i.test(device)) {
  os = 'android';
  vers = userAgent.match(/Android\s+([\d.]+)/i);

  if (vers) {
    version = vers[0].replace('Android ', '').split('.');
  }
} else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {
  // On iPad with iOS 13 desktop site request is automatically enabled in Safari,
  // so 'iPad' is no longer present in the user agent string.
  // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.
  // maxTouchPoints is needed to exclude desktop Mac OS X.
  os = 'ios';
  vers = userAgent.match(/OS\s+([\d_]+)/i);

  if (vers) {
    version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');
  }
} else if (/Windows Phone/i.test(device)) {
  os = 'wp';
} else if (/Windows|MSIE/i.test(device)) {
  os = 'windows';
}

majorVersion = version[0];
minorVersion = version[1];

function testProps(props) {
  var i;

  for (i in props) {
    if (mod[props[i]] !== undefined) {
      return true;
    }
  }

  return false;
}

function testPrefix() {
  var prefixes = ['Webkit', 'Moz', 'O', 'ms'],
      p;

  for (p in prefixes) {
    if (testProps([prefixes[p] + 'Transform'])) {
      return '-' + prefixes[p].toLowerCase() + '-';
    }
  }

  return '';
}

function testTouch(e, elm) {
  if (e.type == 'touchstart') {
    elm.__mbscTouched = 1;
  } else if (elm.__mbscTouched) {
    delete elm.__mbscTouched;
    return false;
  }

  return true;
}

function getPosition(t, vertical) {
  var prefixes = ['t', 'webkitT', 'MozT', 'OT', 'msT'],
      style = getComputedStyle(t[0]),
      i = 0,
      matrix,
      px,
      v;

  while (!matrix && i < prefixes.length) {
    v = prefixes[i];

    if (style[v + 'ransform'] !== undefined) {
      matrix = style[v + 'ransform'];
    }

    i++;
  }

  matrix = matrix.split(')')[0].split(', ');
  px = vertical ? matrix[13] || matrix[5] : matrix[12] || matrix[4];
  return px;
}

function getTextColor(color) {
  if (color) {
    // Cache calculated text colors, because it is slow
    if (textColors[color]) {
      return textColors[color];
    }

    var ctx = canvas && canvas.getContext('2d');

    if (!ctx) {
      return '#fff';
    } // Use canvas element, since it does not require DOM append


    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1, 1);
    var rgb = ctx.getImageData(0, 0, 1, 1).data;
    var delta = +rgb[0] * 0.299 + +rgb[1] * 0.587 + +rgb[2] * 0.114;
    var textColor = delta < 130 ? '#fff' : '#000';
    textColors[color] = textColor;
    return textColor;
  }
}

function scrollStep(el, startTime, from, to, callback) {
  var elapsed = Math.min(1, (new Date() - startTime) / 468),
      eased = 0.5 * (1 - Math.cos(Math.PI * elapsed)),
      current = from + (to - from) * eased;
  el.scrollTop = current;

  if (current !== to) {
    raf(function () {
      scrollStep(el, startTime, from, to, callback);
    });
  } else if (callback) {
    callback();
  }
}

function smoothScroll(el, to, prevAnim, callback) {
  if (prevAnim) {
    el.scrollTop = to;

    if (callback) {
      callback();
    }
  } else {
    scrollStep(el, new Date(), el.scrollTop, to, callback);
  }
}

function listen(el, event, handler, opt) {
  if (el) {
    el.addEventListener(event, handler, opt);
  }
}

function unlisten(el, event, handler, opt) {
  if (el) {
    el.removeEventListener(event, handler, opt);
  }
}

function matches(element, selector) {
  if (!selector || !element || element.nodeType !== 1) {
    return false;
  }

  var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;
  return matchesSelector.call(element, selector);
}

function closest(el, target, selector) {
  while (target) {
    if (matches(target, selector)) {
      return target;
    }

    target = target !== el ? target.parentNode : null;
  }

  return null;
}

function trigger(elm, name, data) {
  var evt;

  try {
    evt = new CustomEvent(name, {
      detail: data,
      bubbles: true,
      cancelable: true
    });
  } catch (e) {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
    evt.detail = data;
  }

  elm.dispatchEvent(evt);
}

function setFocusInvisible() {
  win.__mbscFocusVisible = false;
}

function setFocusVisible() {
  win.__mbscFocusVisible = true;
}

function addWindowFocus() {
  var focusCount = win.__mbscFocusCount || 0;

  if (focusCount === 0) {
    listen(win, 'mousedown', setFocusInvisible, true);
    listen(win, 'keydown', setFocusVisible, true);
  }

  win.__mbscFocusCount = ++focusCount;
}

function removeWindowFocus() {
  var focusCount = win.__mbscFocusCount || 0;
  win.__mbscFocusCount = --focusCount;

  if (win.__mbscFocusCount === 0) {
    unlisten(win, 'mousedown', setFocusInvisible);
    unlisten(win, 'keydown', setFocusVisible);
  }
}

var animEnd,
    canvas,
    mod,
    cssPrefix,
    hasGhostClick,
    hasTransition,
    isWebView,
    isWkWebView,
    jsPrefix,
    win,
    textColors = {};

if (isBrowser) {
  win = window;
  canvas = document.createElement('canvas');
  mod = document.createElement('modernizr').style;
  cssPrefix = testPrefix();
  jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');
  animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';
  hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, 
  // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView
  // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs
  // (keyboard appears, but the cursor is not in the input).

  isWebView = os === 'ios' && !isSafari;
  isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;
  hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;
}

var cssNumber = {
  'column-count': 1,
  'columns': 1,
  'font-weight': 1,
  'line-height': 1,
  'opacity': 1,
  'z-index': 1,
  'zoom': 1
},
    propMap = {
  'readonly': 'readOnly'
},
    emptyArray = [],
    _slice = Array.prototype.slice;

function isFunction(value) {
  return typeof value === "function";
}

function isObject(obj) {
  return typeof obj === "object";
}

function likeArray(obj) {
  return typeof obj.length == 'number';
}

function camelize(str) {
  return str.replace(/-+(.)?/g, function (match, chr) {
    return chr ? chr.toUpperCase() : '';
  });
}

function extend(target, source, deep) {
  for (var key in source) {
    if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {
      if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {
        target[key] = {};
      }

      extend(target[key], source[key], deep);
    } else if (source[key] !== undefined) {
      target[key] = source[key];
    }
  }
}

function dasherize(str) {
  return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
}

function maybeAddPx(name, value) {
  return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
}

var Dom = function () {
  var Dom = function Dom(arr) {
    var _this = this,
        i = 0; // Create array-like object


    for (i = 0; i < arr.length; i++) {
      _this[i] = arr[i];
    }

    _this.length = arr.length; // Return collection with methods

    return $(this);
  };

  var $ = function $(selector, context) {
    var arr = [],
        i = 0;

    if (selector && !context) {
      if (selector instanceof Dom) {
        return selector;
      }
    }

    if (isFunction(selector)) {
      return $(document).ready(selector);
    }

    if (selector) {
      // String
      if (typeof selector === 'string') {
        var els, tempParent, html;
        selector = html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';

          if (html.indexOf('<li') === 0) {
            toCreate = 'ul';
          }

          if (html.indexOf('<tr') === 0) {
            toCreate = 'tbody';
          }

          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
            toCreate = 'tr';
          }

          if (html.indexOf('<tbody') === 0) {
            toCreate = 'table';
          }

          if (html.indexOf('<option') === 0) {
            toCreate = 'select';
          }

          tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (i = 0; i < tempParent.childNodes.length; i++) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [document.getElementById(selector.split('#')[1])];
          } else {
            if (context instanceof Dom) {
              context = context[0];
            } // Other selectors


            els = (context || document).querySelectorAll(selector);
          }

          for (i = 0; i < els.length; i++) {
            if (els[i]) {
              arr.push(els[i]);
            }
          }
        }
      } // Node/element
      else if (selector.nodeType || selector === window || selector === document) {
          arr.push(selector);
        } //Array of elements or instance of Dom
        else if (selector.length > 0 && selector[0].nodeType) {
            for (i = 0; i < selector.length; i++) {
              arr.push(selector[i]);
            }
          } else if ($.isArray(selector)) {
            arr = selector;
          }
    }

    return new Dom(arr);
  };

  Dom.prototype = {
    ready: function ready(callback) {
      if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {
        callback($);
      } else {
        document.addEventListener('DOMContentLoaded', function () {
          callback($);
        }, false);
      }

      return this;
    },
    concat: emptyArray.concat,
    empty: function empty() {
      return this.each(function () {
        this.innerHTML = '';
      });
    },
    map: function map(fn) {
      return $($.map(this, function (el, i) {
        return fn.call(el, i, el);
      }));
    },
    slice: function slice() {
      return $(_slice.apply(this, arguments));
    },
    // Classes and attriutes
    // NOTE: element.classList attribure is not supported on android 2.3!!!
    addClass: function addClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.add(classes[i]);
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }

      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {
            this[j].classList.remove(classes[i]);
          }
        }
      }

      return this;
    },
    hasClass: function hasClass(className) {
      return this[0] ? this[0].classList.contains(className) : false;
    },
    toggleClass: function toggleClass(className) {
      var classes = className.split(' ');

      for (var i = 0; i < classes.length; i++) {
        for (var j = 0; j < this.length; j++) {
          if (typeof this[j].classList !== 'undefined') {
            this[j].classList.toggle(classes[i]);
          }
        }
      }

      return this;
    },
    closest: function closest(selector, context) {
      var node = this[0],
          collection = false;

      if (isObject(selector)) {
        collection = $(selector);
      }

      while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {
        node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;
      }

      return $(node);
    },
    attr: function attr(attrs, value) {
      var attr;

      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this.length) {
          attr = this[0].getAttribute(attrs);
          return attr || attr === '' ? attr : undefined;
        }
      } else {
        // Set attrs
        for (var i = 0; i < this.length; i++) {
          if (arguments.length === 2) {
            // String
            this[i].setAttribute(attrs, value);
          } else {
            // Object
            for (var attrName in attrs) {
              this[i][attrName] = attrs[attrName];
              this[i].setAttribute(attrName, attrs[attrName]);
            }
          }
        }

        return this;
      }
    },
    removeAttr: function removeAttr(attr) {
      for (var i = 0; i < this.length; i++) {
        this[i].removeAttribute(attr);
      }

      return this;
    },
    prop: function prop(props, value) {
      props = propMap[props] || props;

      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        return this[0] ? this[0][props] : undefined;
      } else {
        // Set props
        for (var i = 0; i < this.length; i++) {
          this[i][props] = value;
        }

        return this;
      }
    },
    val: function val(value) {
      if (typeof value === 'undefined') {
        if (this.length && this[0].multiple) {
          return $.map(this.find('option:checked'), function (v) {
            return v.value;
          });
        }

        return this[0] ? this[0].value : undefined;
      }

      if (this.length && this[0].multiple) {
        $.each(this[0].options, function () {
          this.selected = value.indexOf(this.value) != -1;
        });
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].value = value;
        }
      }

      return this;
    },
    //Events
    on: function on(eventName, targetSelector, listener, capture) {
      var boundListener,
          elm,
          event,
          events = eventName.split(' '),
          i,
          j;

      function handleLiveEvent(e) {
        var target = e.target;

        while (target) {
          if ($(target).is(targetSelector)) {
            listener.call(target, e);
          }

          target = target !== this ? target.parentNode : null;
        }
      }

      function handleNamespaces(el, name, listener, capture) {
        var namespace = name.split('.');

        if (!el.DomNameSpaces) {
          el.DomNameSpaces = [];
        }

        el.DomNameSpaces.push({
          namespace: namespace[1],
          event: namespace[0],
          listener: listener,
          capture: capture
        });
        el.addEventListener(namespace[0], listener, capture);
      }

      for (i = 0; i < this.length; i++) {
        elm = this[i];

        if (isFunction(targetSelector) || targetSelector === false) {
          // Usual events
          if (isFunction(targetSelector)) {
            capture = listener || false;
            listener = targetSelector;
          }

          for (j = 0; j < events.length; j++) {
            event = events[j]; // check for namespaces

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, listener, capture);
            } else {
              elm.addEventListener(event, listener, capture);
            }
          }
        } else {
          // Live events
          boundListener = handleLiveEvent.bind(elm);

          for (j = 0; j < events.length; j++) {
            event = events[j];

            if (!elm.DomLiveListeners) {
              elm.DomLiveListeners = [];
            }

            elm.DomLiveListeners.push({
              listener: listener,
              liveListener: boundListener
            });

            if (event.indexOf('.') != -1) {
              handleNamespaces(elm, event, boundListener, capture);
            } else {
              elm.addEventListener(event, boundListener, capture);
            }
          }
        }
      }

      return this;
    },
    off: function off(eventName, targetSelector, listener, capture) {
      var elm,
          event,
          events,
          i,
          j,
          k,
          liveListeners,
          that = this;

      function removeEvents(event) {
        var el,
            i,
            j,
            item,
            nameSpaces,
            parts = event.split('.'),
            name = parts[0],
            ns = parts[1];

        for (i = 0; i < that.length; ++i) {
          el = that[i];
          nameSpaces = el.DomNameSpaces;

          if (nameSpaces) {
            for (j = 0; j < nameSpaces.length; ++j) {
              item = nameSpaces[j];

              if (item.namespace == ns && (item.event == name || !name)) {
                el.removeEventListener(item.event, item.listener, item.capture);
                item.removed = true;
              }
            } // remove the events from the DomNameSpaces array


            for (j = nameSpaces.length - 1; j >= 0; --j) {
              if (nameSpaces[j].removed) {
                nameSpaces.splice(j, 1);
              }
            }
          }
        }
      }

      events = eventName.split(' ');

      for (i = 0; i < events.length; i++) {
        event = events[i];

        for (j = 0; j < this.length; j++) {
          elm = this[j];
          liveListeners = elm.DomLiveListeners;

          if (isFunction(targetSelector) || targetSelector === false) {
            // Usual events
            if (isFunction(targetSelector)) {
              capture = listener || false;
              listener = targetSelector;
            }

            if (event.indexOf('.') === 0) {
              // remove namespace events
              removeEvents(event.substr(1));
            } else {
              elm.removeEventListener(event, listener, capture);
            }
          } else {
            // Live event
            if (liveListeners) {
              for (k = 0; k < liveListeners.length; k++) {
                if (liveListeners[k].listener === listener) {
                  elm.removeEventListener(event, liveListeners[k].liveListener, capture);
                }
              }
            }

            if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {
              removeEvents(event);
            }
          }
        }
      }

      return this;
    },
    trigger: function trigger$1(eventName, eventData) {
      var events = eventName.split(' ');

      for (var i = 0; i < events.length; i++) {
        for (var j = 0; j < this.length; j++) {
          trigger(this[j], events[i], eventData);
        }
      }

      return this;
    },
    // Sizing/Styles
    width: function width(dim) {
      if (dim !== undefined) {
        return this.css('width', dim);
      }

      if (this[0] === window) {
        return window.innerWidth;
      } else if (this[0] === document) {
        return document.documentElement.scrollWidth;
      } else {
        return this.length > 0 ? parseFloat(this.css('width')) : null;
      }
    },
    height: function height(dim) {
      if (dim !== undefined) {
        return this.css('height', dim);
      }

      if (this[0] === window) {
        return window.innerHeight;
      } else if (this[0] === document) {
        var body = document.body,
            html = document.documentElement;
        return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      } else {
        return this.length > 0 ? parseFloat(this.css('height')) : null;
      }
    },
    innerWidth: function innerWidth() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerWidth) {
          return this[0].innerWidth;
        } else {
          var size = this[0].offsetWidth,
              sides = ['left', 'right'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    innerHeight: function innerHeight() {
      var elm = this;

      if (this.length > 0) {
        if (this[0].innerHeight) {
          return this[0].innerHeight;
        } else {
          var size = this[0].offsetHeight,
              sides = ['top', 'bottom'];
          sides.forEach(function (side) {
            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);
          });
          return size;
        }
      }
    },
    offset: function offset() {
      if (this.length > 0) {
        var el = this[0],
            box = el.getBoundingClientRect(),
            doc = document.documentElement;
        return {
          top: box.top + window.pageYOffset - doc.clientTop,
          left: box.left + window.pageXOffset - doc.clientLeft
        };
      }
    },
    hide: function hide() {
      for (var i = 0; i < this.length; i++) {
        this[i].style.display = 'none';
      }

      return this;
    },
    show: function show() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].style.display == "none") {
          this[i].style.display = '';
        }

        if (getComputedStyle(this[i], '').getPropertyValue("display") == "none") {
          this[i].style.display = 'block';
        }
      }

      return this;
    },
    clone: function clone() {
      return this.map(function () {
        return this.cloneNode(true);
      });
    },
    styles: function styles() {
      return this[0] ? window.getComputedStyle(this[0], null) : undefined;
    },
    css: function css(property, value) {
      var i,
          key,
          element = this[0],
          css = '';

      if (arguments.length < 2) {
        if (!element) {
          return;
        }

        if (typeof property === 'string') {
          return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);
        }
      }

      if (typeof property === 'string') {
        if (!value && value !== 0) {
          this.each(function () {
            this.style.removeProperty(dasherize(property));
          });
        } else {
          css = dasherize(property) + ":" + maybeAddPx(property, value);
        }
      } else {
        for (key in property) {
          if (!property[key] && property[key] !== 0) {
            for (i = 0; i < this.length; i++) {
              this[i].style.removeProperty(dasherize(key));
            }
          } else {
            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
          }
        }
      }

      return this.each(function () {
        this.style.cssText += ';' + css;
      });
    },
    each: function each(callback) {
      for (var i = 0; i < this.length; i++) {
        if (callback.apply(this[i], [i, this[i]]) === false) {
          break;
        }
      }

      return this;
    },
    filter: function filter(callback) {
      var matchedItems = [];

      for (var i = 0; i < this.length; i++) {
        if (isFunction(callback)) {
          if (callback.call(this[i], i, this[i])) {
            matchedItems.push(this[i]);
          }
        } else if (matches(this[i], callback)) {
          matchedItems.push(this[i]);
        }
      }

      return new Dom(matchedItems);
    },
    html: function html(_html) {
      if (typeof _html === 'undefined') {
        return this[0] ? this[0].innerHTML : undefined;
      } else {
        this.empty();

        for (var i = 0; i < this.length; i++) {
          this[i].innerHTML = _html;
        }

        return this;
      }
    },
    text: function text(_text) {
      if (typeof _text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      } else {
        for (var i = 0; i < this.length; i++) {
          this[i].textContent = _text;
        }

        return this;
      }
    },
    is: function is(selector) {
      return this.length > 0 && matches(this[0], selector);
    },
    not: function not(selector) {
      var nodes = [];

      if (isFunction(selector) && selector.call !== undefined) {
        this.each(function (idx) {
          if (!selector.call(this, idx)) {
            nodes.push(this);
          }
        });
      } else {
        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);

        if (isObject(excludes)) {
          excludes = $.map(excludes, function (el) {
            return el;
          });
        }

        this.each(function (i, el) {
          if (excludes.indexOf(el) < 0) {
            nodes.push(el);
          }
        });
      }

      return $(nodes);
    },
    indexOf: function indexOf(el) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === el) {
          return i;
        }
      }
    },
    index: function index(element) {
      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
    },
    get: function get(idx) {
      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
    },
    eq: function eq(index) {
      if (typeof index === 'undefined') {
        return this;
      }

      var length = this.length,
          returnIndex;

      if (index > length - 1) {
        return new Dom([]);
      }

      if (index < 0) {
        returnIndex = length + index;
        return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);
      }

      return new Dom([this[index]]);
    },
    append: function append(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }

      return this;
    },
    appendTo: function appendTo(parent) {
      $(parent).append(this);
      return this;
    },
    prepend: function prepend(newChild) {
      var i, j;

      for (i = 0; i < this.length; i++) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          } // this[i].insertAdjacentHTML('afterbegin', newChild);

        } else if (newChild instanceof Dom) {
          for (j = 0; j < newChild.length; j++) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    },
    prependTo: function prependTo(parent) {
      $(parent).prepend(this);
      return this;
    },
    insertBefore: function insertBefore(selector) {
      var before = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (var j = 0; j < before.length; j++) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }

      return this;
    },
    insertAfter: function insertAfter(selector) {
      var after = $(selector);

      for (var i = 0; i < this.length; i++) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (var j = 0; j < after.length; j++) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }

      return this;
    },
    next: function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].nextElementSibling) {
            return new Dom([this[0].nextElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    nextAll: function nextAll(selector) {
      var nextEls = [],
          el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.nextElementSibling) {
        var next = el.nextElementSibling;

        if (selector) {
          if ($(next).is(selector)) {
            nextEls.push(next);
          }
        } else {
          nextEls.push(next);
        }

        el = next;
      }

      return new Dom(nextEls);
    },
    prev: function prev(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        } else {
          if (this[0].previousElementSibling) {
            return new Dom([this[0].previousElementSibling]);
          } else {
            return new Dom([]);
          }
        }
      } else {
        return new Dom([]);
      }
    },
    prevAll: function prevAll(selector) {
      var prevEls = [];
      var el = this[0];

      if (!el) {
        return new Dom([]);
      }

      while (el.previousElementSibling) {
        var prev = el.previousElementSibling;

        if (selector) {
          if ($(prev).is(selector)) {
            prevEls.push(prev);
          }
        } else {
          prevEls.push(prev);
        }

        el = prev;
      }

      return new Dom(prevEls);
    },
    parent: function parent(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) {
              parents.push(this[i].parentNode);
            }
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $($.unique(parents));
    },
    parents: function parents(selector) {
      var parents = [];

      for (var i = 0; i < this.length; i++) {
        var parent = this[i].parentNode;

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) {
              parents.push(parent);
            }
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $($.unique(parents));
    },
    find: function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i++) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j++) {
          foundElements.push(found[j]);
        }
      }

      return new Dom(foundElements);
    },
    children: function children(selector) {
      var children = [];

      for (var i = 0; i < this.length; i++) {
        var childNodes = this[i].childNodes;

        for (var j = 0; j < childNodes.length; j++) {
          if (!selector) {
            if (childNodes[j].nodeType === 1) {
              children.push(childNodes[j]);
            }
          } else {
            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
              children.push(childNodes[j]);
            }
          }
        }
      }

      return new Dom($.unique(children));
    },
    remove: function remove() {
      for (var i = 0; i < this.length; i++) {
        if (this[i].parentNode) {
          this[i].parentNode.removeChild(this[i]);
        }
      }

      return this;
    },
    add: function add() {
      var dom = this;
      var i, j;

      for (i = 0; i < arguments.length; i++) {
        var toAdd = $(arguments[i]);

        for (j = 0; j < toAdd.length; j++) {
          dom[dom.length] = toAdd[j];
          dom.length++;
        }
      }

      return dom;
    },
    before: function before(elm) {
      $(elm).insertBefore(this);
      return this;
    },
    after: function after(elm) {
      $(elm).insertAfter(this);
      return this;
    },
    scrollTop: function scrollTop(value) {
      if (!this.length) {
        return;
      }

      var hasScrollTop = 'scrollTop' in this[0];

      if (value === undefined) {
        return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
      }

      return this.each(hasScrollTop ? function () {
        this.scrollTop = value;
      } : function () {
        this.scrollTo(this.scrollX, value);
      });
    },
    scrollLeft: function scrollLeft(value) {
      if (!this.length) {
        return;
      }

      var hasScrollLeft = 'scrollLeft' in this[0];

      if (value === undefined) {
        return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
      }

      return this.each(hasScrollLeft ? function () {
        this.scrollLeft = value;
      } : function () {
        this.scrollTo(value, this.scrollY);
      });
    },
    contents: function contents() {
      return this.map(function (i, v) {
        return _slice.call(v.childNodes);
      });
    },
    nextUntil: function nextUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !n.filter(selector).length) {
        array.push(n[0]);
        n = n.next();
      }

      return $(array);
    },
    prevUntil: function prevUntil(selector) {
      var n = this,
          array = [];

      while (n.length && !$(n).filter(selector).length) {
        array.push(n[0]);
        n = n.prev();
      }

      return $(array);
    },
    detach: function detach() {
      return this.remove();
    }
  }; // Link to prototype

  $.fn = Dom.prototype;
  return $;
}(); // Export to local scope


var $ = Dom; // Export to mobiscroll

mobiscroll.$ = Dom; // DOM Library Utilites

$.inArray = function (elem, array, i) {
  return emptyArray.indexOf.call(array, elem, i);
};

$.extend = function (target) {
  var deep,
      args = _slice.call(arguments, 1);

  if (typeof target == 'boolean') {
    deep = target;
    target = args.shift();
  }

  target = target || {};
  args.forEach(function (arg) {
    extend(target, arg, deep);
  });
  return target;
};

$.isFunction = isFunction;

$.isArray = function (arr) {
  return Object.prototype.toString.apply(arr) === '[object Array]';
};

$.isPlainObject = function (obj) {
  return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;
};

$.each = function (obj, callback) {
  var i, prop;

  if (!isObject(obj) || !callback) {
    return;
  }

  if ($.isArray(obj) || obj instanceof Dom) {
    // Array
    for (i = 0; i < obj.length; i++) {
      if (callback.call(obj[i], i, obj[i]) === false) {
        break;
      }
    }
  } else {
    // Object
    for (prop in obj) {
      // eslint-disable-next-line no-prototype-builtins
      if (obj.hasOwnProperty(prop) && prop !== 'length') {
        if (callback.call(obj[prop], prop, obj[prop]) === false) {
          break;
        }
      }
    }
  }

  return this;
};

$.unique = function (arr) {
  var unique = [];

  for (var i = 0; i < arr.length; i++) {
    if (unique.indexOf(arr[i]) === -1) {
      unique.push(arr[i]);
    }
  }

  return unique;
};

$.map = function (elements, callback) {
  var value,
      values = [],
      i,
      key;

  if (likeArray(elements)) {
    for (i = 0; i < elements.length; i++) {
      value = callback(elements[i], i);

      if (value !== null) {
        values.push(value);
      }
    }
  } else {
    for (key in elements) {
      value = callback(elements[key], key);

      if (value !== null) {
        values.push(value);
      }
    }
  }

  return values.length > 0 ? $.fn.concat.apply([], values) : values;
};

function noop() {}

function objectToArray(obj) {
  var arr = [],
      i;

  for (i in obj) {
    arr.push(obj[i]);
  }

  return arr;
}

function isNumeric(a) {
  return a - parseFloat(a) >= 0;
}

function isString(s) {
  return typeof s === 'string';
}

function constrain(val, min, max) {
  return Math.max(min, Math.min(val, max));
}

function pad(num, size) {
  num = num + '';
  size = size || 2;

  while (num.length < size) {
    num = '0' + num;
  }

  return num;
}

function throttle(fn, threshhold) {
  var last, timer;
  threshhold = threshhold || 100;
  return function () {
    var context = this,
        now = +new Date(),
        args = arguments;

    if (last && now < last + threshhold) {
      clearTimeout(timer);
      timer = setTimeout(function () {
        last = now;
        fn.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      fn.apply(context, args);
    }
  };
}

function vibrate(time) {
  if ('vibrate' in navigator) {
    navigator.vibrate(time || 50);
  }
}

var tapped = 0;
var allowQuick;

function preventClick() {
  // Prevent ghost click
  tapped++;
  setTimeout(function () {
    tapped--;
  }, 500);
}

function triggerClick(ev, control) {
  // Prevent duplicate triggers on the same element
  // e.g. a form checkbox inside a listview item
  if (control.mbscClick) {
    return;
  }

  var touch = (ev.originalEvent || ev).changedTouches[0],
      evt = document.createEvent('MouseEvents');
  evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  evt.isMbscTap = true; // Prevent ionic to bust our click
  // This works for Ionic 1 - 3, not sure about 4

  evt.isIonicTap = true; // This will allow a click fired together with this click
  // We need this, because clicking on a label will trigger a click
  // on the associated input as well, which should not be busted

  allowQuick = true;
  control.mbscChange = true;
  control.mbscClick = true;
  control.dispatchEvent(evt);
  allowQuick = false; // Prevent ghost click

  preventClick();
  setTimeout(function () {
    delete control.mbscClick;
  });
}

function getCoord(e, c, page) {
  var ev = e.originalEvent || e,
      prop = (page ? 'page' : 'client') + c; // Multi touch support

  if (ev.targetTouches && ev.targetTouches[0]) {
    return ev.targetTouches[0][prop];
  }

  if (ev.changedTouches && ev.changedTouches[0]) {
    return ev.changedTouches[0][prop];
  }

  return e[prop];
}

function getControlType($elm) {
  var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];
  var elm = $elm[0];
  var role = $elm.attr('data-role');
  var type = $elm.attr('type') || elm.nodeName.toLowerCase();

  if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {
    type = role;
  } else {
    for (var i = 0; i < attrs.length; i++) {
      if ($elm.is('[mbsc-' + attrs[i] + ']')) {
        type = attrs[i];
      }
    }
  }

  return type;
}

function activateControl(control, type, ev) {
  control.focus();

  if (/(button|submit|checkbox|switch|radio)/.test(type)) {
    ev.preventDefault();
  }

  if (!/select/.test(type)) {
    triggerClick(ev, control);
  }
}

function tap(that, el, handler, prevent, tolerance, time) {
  var startX,
      startY,
      target,
      moved,
      startTime,
      $ = mobiscroll.$,
      $elm = $(el);
  tolerance = tolerance || 9;

  function onStart(ev) {
    if (!target) {
      // Can't always call preventDefault here, it kills page scroll
      // if (prevent) {
      //     ev.preventDefault();
      // }
      target = this;
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      moved = false;
      startTime = new Date();
    }
  }

  function onMove(ev) {
    // If movement is more than 20px, don't fire the click event handler
    if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {
      moved = true;
    }
  }

  function onEnd(ev) {
    if (target) {
      if (time && new Date() - startTime < 100 || !moved) {
        // ev.preventDefault();
        // handler.call(target, ev, that);
        triggerClick(ev, ev.target);
      } else {
        preventClick();
      }

      target = false;
    }
  }

  function onClick(ev) {
    if (prevent) {
      ev.preventDefault();
    } // If handler was not called on touchend, call it on click;


    handler.call(this, ev, that);
  }

  function onCancel() {
    target = false;
  }

  $elm.each(function (i, elm) {
    if (that.settings.tap) {
      listen(elm, 'touchstart', onStart, {
        passive: true
      });
      listen(elm, 'touchcancel', onCancel);
      listen(elm, 'touchmove', onMove, {
        passive: true
      });
      listen(elm, 'touchend', onEnd);
    }

    listen(elm, 'click', onClick);

    elm.__mbscOff = function () {
      unlisten(elm, 'touchstart', onStart, {
        passive: true
      });
      unlisten(elm, 'touchcancel', onCancel);
      unlisten(elm, 'touchmove', onMove, {
        passive: true
      });
      unlisten(elm, 'touchend', onEnd);
      unlisten(elm, 'click', onClick);
      delete elm.__mbscOff;
    };
  });
}

function tapOff($elm) {
  if ($elm && $elm[0] && $elm[0].__mbscOff) {
    $elm[0].__mbscOff();
  }
} // Prevent standard behaviour on body click


function bustClick(ev) {
  // Textarea needs the mousedown event
  if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {
    ev.stopPropagation();
    ev.preventDefault();
    return false;
  }
}

if (isBrowser) {
  ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {
    document.addEventListener(ev, bustClick, true);
  });

  if (os == 'android' && majorVersion < 5) {
    document.addEventListener('change', function (ev) {
      if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {
        ev.stopPropagation();
        ev.preventDefault();
      }

      delete ev.target.mbscChange;
    }, true);
  }
}

/*!
 * Mobiscroll v4.10.6
 * http://mobiscroll.com
 *
 *
 * Copyright 2010-2018, Acid Media
 *
 */
mobiscroll.uid = "5f826c07";

function getWidth(el) {
  return el[0].innerWidth || el.innerWidth();
}

function getThemeName(s) {
  var themeName = s.theme,
      themeVariant = s.themeVariant;

  if (themeName == 'auto' || !themeName) {
    themeName = ms.autoTheme;
  }

  if (themeName == 'default') {
    themeName = 'mobiscroll';
  }

  if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {
    themeName = themeName + '-dark';
  } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {
    themeName = themeName.replace(/-dark$/, '');
  }

  return themeName;
}

function autoInit(selector, Component, hasRefresh) {
  if (isBrowser) {
    $$1(function () {
      $$1(selector).each(function () {
        new Component(this, {});
      });
      $$1(document).on('mbsc-enhance', function (ev, settings) {
        if ($$1(ev.target).is(selector)) {
          new Component(ev.target, settings || {});
        } else {
          $$1(selector, ev.target).each(function () {
            new Component(this, settings || {});
          });
        }
      });

      if (hasRefresh) {
        $$1(document).on('mbsc-refresh', function (ev) {
          var inst;

          if ($$1(ev.target).is(selector)) {
            inst = instances[ev.target.id];

            if (inst) {
              inst.refresh();
            }
          } else {
            $$1(selector, ev.target).each(function () {
              inst = instances[this.id];

              if (inst) {
                inst.refresh();
              }
            });
          }
        });
      }
    });
  }
}

var ms,
    $$1 = mobiscroll.$,
    id = +new Date(),
    instances = {},
    classes = {},
    empty = {},
    breakpoints = {
  xsmall: 0,
  small: 576,
  medium: 768,
  large: 992,
  xlarge: 1200
},
    extend$1 = $$1.extend;
extend$1(util, {
  getCoord: getCoord,
  preventClick: preventClick,
  vibrate: vibrate
});
ms = extend$1(mobiscroll, {
  $: $$1,
  version: '4.10.6',
  autoTheme: 'mobiscroll',
  themes: {
    form: {},
    page: {},
    frame: {},
    scroller: {},
    listview: {},
    navigation: {},
    progress: {},
    card: {}
  },
  platform: {
    name: os,
    majorVersion: majorVersion,
    minorVersion: minorVersion
  },
  i18n: {},
  instances: instances,
  classes: classes,
  util: util,
  settings: {},
  setDefaults: function setDefaults(o) {
    extend$1(this.settings, o);
  },
  customTheme: function customTheme(name, baseTheme) {
    var i,
        themes = mobiscroll.themes,
        comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];

    for (i = 0; i < comps.length; i++) {
      themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {
        baseTheme: baseTheme
      });
    }
  }
});

var Base = function Base(el, settings) {
  var ctx,
      lang,
      preset,
      resp,
      s,
      theme,
      themeName,
      trigger,
      defaults,
      that = this;
  that.settings = {};
  that.element = el;
  that._init = noop;
  that._destroy = noop;
  that._processSettings = noop;

  that._checkResp = function (width) {
    if (that && that._responsive) {
      var newResp = getResponsiveSettings(width);

      if (resp !== newResp) {
        resp = newResp;
        that.init({});
        return true;
      }
    }
  };

  that._getRespCont = function () {
    return $$1(s.context == 'body' ? window : s.context);
  };

  that.init = function (newSettings, newValue) {
    var key, value; // In case of settings update save the old value

    if (newSettings && that.getVal) {
      value = that.getVal();
    } // Reset settings object


    for (key in that.settings) {
      delete that.settings[key];
    }

    s = that.settings; // Update original user settings

    extend$1(settings, newSettings); // Load user defaults

    if (that._hasDef) {
      defaults = ms.settings;
    } // Create settings object


    extend$1(s, that._defaults, defaults, settings); // Get theme defaults

    if (that._hasTheme) {
      themeName = getThemeName(s);
      settings.theme = themeName;
      theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};
    } // Get language defaults


    if (that._hasLang) {
      lang = ms.i18n[s.lang];
    } // Update settings object


    extend$1(s, theme, lang, defaults, settings);
    ctx = that._getRespCont();

    if (that._responsive) {
      if (!resp) {
        resp = getResponsiveSettings();
      }

      extend$1(s, resp);
    }

    that._processSettings(resp || {}); // Load preset settings


    if (that._presets) {
      preset = that._presets[s.preset];

      if (preset) {
        preset = preset.call(el, that, settings);
        extend$1(s, preset, settings, resp);
      }
    }

    that._init(newSettings); // In case of settings update reset the value.
    // This is needed to adapt the value for the updated settings
    // E.g. min/max, date format, etc.


    if (newSettings && that.setVal) {
      that.setVal(newValue === undefined ? value : newValue, true);
    }

    trigger('onInit');
  };

  that.destroy = function () {
    if (that) {
      that._destroy();

      trigger('onDestroy'); // Delete scroller instance

      delete instances[el.id];
      that = null;
    }
  };
  /**
   * Attach tap event to the given element.
   */


  that.tap = function (el, handler, prevent, tolerance, time) {
    tap(that, el, handler, prevent, tolerance, time);
  };
  /**
   * Triggers an event
   */


  that.trigger = function (name, ev) {
    var ret,
        i,
        v,
        s = [defaults, theme, preset, settings];

    for (i = 0; i < 4; i++) {
      v = s[i];

      if (v && v[name]) {
        ret = v[name].call(el, ev || {}, that);
      }
    }

    return ret;
  };
  /**
   * Sets one ore more options.
   */


  that.option = function (opt, value, newValue) {
    var obj = {},
        // preserve settings that are possible to change runtime
    dynamic = ['data', 'invalid', 'valid', 'readonly'];

    if (/calendar|eventcalendar|range/.test(s.preset)) {
      dynamic.push('marked', 'labels', 'colors');
    }

    if (typeof opt === 'object') {
      obj = opt;
    } else {
      obj[opt] = value;
    }

    dynamic.forEach(function (v) {
      settings[v] = s[v];
    });
    that.init(obj, newValue);
  };
  /**
   * Returns the mobiscroll instance.
   */


  that.getInst = function () {
    return that;
  };

  settings = settings || {};
  trigger = that.trigger;

  function getResponsiveSettings(w) {
    var result = empty,
        width;

    if (s.responsive) {
      width = w || getWidth(ctx);
      $$1.each(s.responsive, function (key, value) {
        if (width >= (value.breakpoint || breakpoints[key])) {
          result = value;
        }
      });
    }

    return result;
  }

  function construct() {
    $$1(el).addClass('mbsc-comp'); // Autogenerate id

    if (!el.id) {
      el.id = 'mobiscroll' + ++id;
    } else if (instances[el.id]) {
      instances[el.id].destroy();
    } // Save instance


    instances[el.id] = that;
    that.__ready = true;
  }

  if (!that.__ready) {
    construct();
  }
};

var Observable = function () {
  function Observable() {
    this.keyCount = 0;
    this.subscribers = new Map();
  }

  Observable.prototype.subscribe = function (handler) {
    var key = this.keyCount++;
    this.subscribers.set(key, handler);
    return key;
  };

  Observable.prototype.unsubscribe = function (handler) {
    if (typeof handler === 'number') {
      this.subscribers.delete(handler);
    } else {
      var foundKey_1 = null;
      this.subscribers.forEach(function (fn, key) {
        if (fn === handler) {
          foundKey_1 = key;
        }
      });
      this.subscribers.delete(foundKey_1);
    }
  };

  Observable.prototype.next = function (value) {
    this.subscribers.forEach(function (handler) {
      handler(value);
    });
  };

  return Observable;
}();

var MbscRouterToken = (function () {
    function MbscRouterToken() {
    }
    return MbscRouterToken;
}());
var MbscOptionsService = (function () {
    function MbscOptionsService() {
    }
    Object.defineProperty(MbscOptionsService.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (o) {
            this._options = o;
        },
        enumerable: true,
        configurable: true
    });
    MbscOptionsService = __decorate([
        Injectable()
    ], MbscOptionsService);
    return MbscOptionsService;
}());
var MbscInputService = (function () {
    function MbscInputService() {
        this._controlSet = false;
        this._componentRef = undefined;
    }
    Object.defineProperty(MbscInputService.prototype, "isControlSet", {
        get: function () {
            return this._controlSet;
        },
        set: function (v) {
            this._controlSet = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscInputService.prototype, "input", {
        get: function () {
            return this._componentRef;
        },
        set: function (v) {
            this._componentRef = v;
        },
        enumerable: true,
        configurable: true
    });
    MbscInputService = __decorate([
        Injectable()
    ], MbscInputService);
    return MbscInputService;
}());
var MbscListService = (function () {
    function MbscListService() {
        this.addRemoveObservable = new Observable();
    }
    MbscListService.prototype.notifyAddRemove = function (item) {
        this.addRemoveObservable.next(item);
    };
    MbscListService.prototype.onAddRemove = function () {
        return this.addRemoveObservable;
    };
    MbscListService = __decorate([
        Injectable()
    ], MbscListService);
    return MbscListService;
}());
var MbscBase = (function () {
    function MbscBase(initialElem, zone) {
        this.initialElem = initialElem;
        this.zone = zone;
        this.options = {};
        this.onInit = new EventEmitter();
        this.onDestroy = new EventEmitter();
        this.inlineOptionsObj = {};
        this.pendingValue = undefined;
        this.themeClassesSet = false;
        this.instance = null;
        this.element = null;
        this.inlineOptionsObj.zone = zone;
    }
    MbscBase.prototype.getInlineEvents = function () {
        var _this = this;
        var _loop_1 = function (prop) {
            if (this_1[prop] instanceof (EventEmitter) && (!this_1.options || !(this_1.options[prop]))) {
                this_1.inlineOptionsObj[prop] = function (event, inst) {
                    event.inst = inst;
                    _this[prop].emit(event);
                };
            }
        };
        var this_1 = this;
        for (var prop in this) {
            _loop_1(prop);
        }
    };
    MbscBase.prototype.setThemeClasses = function () {
        $$1(this.initialElem.nativeElement).addClass(this.getThemeClasses());
        this.themeClassesSet = true;
    };
    MbscBase.prototype.clearThemeClasses = function () {
        $$1(this.initialElem.nativeElement).removeClass(this.getThemeClasses());
    };
    MbscBase.prototype.getThemeClasses = function () {
        var s = this.instance.settings;
        return 'mbsc-control-ng mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '');
    };
    MbscBase.prototype.setElement = function () {
        this.element = this.initialElem.nativeElement;
        var contentInput = $$1('input', this.initialElem.nativeElement);
        if (contentInput.length) {
            this.element = contentInput[0];
        }
    };
    MbscBase.prototype.ngAfterViewInit = function () {
        this.setElement();
        this.startInit();
    };
    MbscBase.prototype.startInit = function () {
        var _this = this;
        this.getInlineEvents();
        var ionInput = this.getIonInput();
        if (ionInput && (ionInput.getInputElement || ionInput.then) && this.element.nodeName !== "INPUT") {
            if (ionInput.getInputElement) {
                ionInput.getInputElement().then(function (inp) {
                    _this.setElement();
                    _this.initControl();
                });
            }
            else {
                ionInput.then(function (ionInpComponent) {
                    ionInpComponent
                        .getInputElement()
                        .then(function (inp) {
                        _this.setElement();
                        _this.initControl();
                    });
                });
            }
        }
        else if (!this.instance) {
            this.initControl();
        }
    };
    MbscBase.prototype.getIonInput = function () {
        var v = this._view;
        var native = this.initialElem.nativeElement;
        var ionInputNode = native.nodeName === "ION-INPUT";
        var inp1 = ionInputNode && v && v._data && v._data.componentView && v._data.componentView.component;
        var inp2 = ionInputNode && native.componentOnReady && native.componentOnReady();
        return inp1 || inp2;
    };
    MbscBase.prototype.initControl = function () { };
    MbscBase.prototype.ngOnDestroy = function () {
        if (this.instance) {
            this.instance.destroy();
        }
    };
    MbscBase.prototype.updateOptions = function (newOptions, optionChanged, invalidChanged, dataChanged) {
        var _this = this;
        if (optionChanged || invalidChanged) {
            setTimeout(function () {
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.clearThemeClasses();
                }
                _this.instance.option(newOptions, undefined, _this.pendingValue);
                if (newOptions.theme && _this.themeClassesSet) {
                    _this.setThemeClasses();
                }
            });
        }
        else if (dataChanged) {
            this.refreshData(this.data);
        }
        else if (this.instance.redraw) {
            this.instance.redraw();
        }
    };
    MbscBase.prototype.ngOnChanges = function (changes) {
        var optionChange = false, cloneChange = false, invalidChange = false, dataChange = false, newOptions = {};
        for (var prop in changes) {
            if (!changes[prop].firstChange && prop !== 'options' && prop !== 'value') {
                if (this.cloneDictionary && this.cloneDictionary[prop]) {
                    this.makeClone(prop, changes[prop].currentValue);
                    if (this.instance) {
                        this.instance.settings[prop] = changes[prop].currentValue;
                    }
                    if (prop == 'invalid') {
                        invalidChange = true;
                    }
                    if (prop == 'data') {
                        dataChange = true;
                    }
                    cloneChange = true;
                }
                else {
                    newOptions[prop] = changes[prop].currentValue;
                    optionChange = true;
                }
            }
            else if (!changes[prop].firstChange && prop !== 'value') {
                newOptions = extend$1(changes[prop].currentValue, newOptions);
                optionChange = true;
            }
            else if (changes[prop].firstChange) {
                if (prop !== 'options' && prop !== 'value') {
                    this.inlineOptionsObj[prop] = changes[prop].currentValue;
                }
            }
        }
        if (cloneChange) {
            extend$1(newOptions, this.cloneDictionary);
        }
        if (optionChange || cloneChange) {
            this.updateOptions(newOptions, optionChange, invalidChange, dataChange);
        }
    };
    __decorate([
        Input$1('mbsc-options'),
        __metadata("design:type", Object)
    ], MbscBase.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscBase.prototype, "cssClass", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscBase.prototype, "theme", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscBase.prototype, "themeVariant", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscBase.prototype, "lang", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscBase.prototype, "rtl", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscBase.prototype, "responsive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscBase.prototype, "onInit", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscBase.prototype, "onDestroy", void 0);
    MbscBase = __decorate([
        Directive({ selector: '[mbsc-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone])
    ], MbscBase);
    return MbscBase;
}());
var MbscValueBase = (function (_super) {
    __extends(MbscValueBase, _super);
    function MbscValueBase(initialElem, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.initialValue = undefined;
        return _this;
    }
    MbscValueBase.prototype.setNewValue = function (v) { };
    MbscValueBase.prototype.setNewValueProxy = function (v) {
        if (!this.instance) {
            this.initialValue = v;
        }
        this.setNewValue(v);
    };
    MbscValueBase = __decorate([
        Directive({ selector: '[mbsc-v-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone])
    ], MbscValueBase);
    return MbscValueBase;
}(MbscBase));
var MbscCloneBase = (function (_super) {
    __extends(MbscCloneBase, _super);
    function MbscCloneBase(initElem, zone) {
        var _this = _super.call(this, initElem, zone) || this;
        _this.cloneDictionary = {};
        return _this;
    }
    MbscCloneBase.prototype.makeClone = function (setting, value) {
        if (value) {
            this.cloneDictionary[setting] = [];
            for (var i = 0; i < value.length; i++) {
                this.cloneDictionary[setting].push(value[i]);
            }
        }
        else {
            this.cloneDictionary[setting] = value;
        }
    };
    MbscCloneBase.prototype.ngDoCheck = function () {
        var changed = false, data = false, invalid = false;
        for (var key in this.cloneDictionary) {
            if (this[key] !== undefined && !deepEqualsArray(this[key], this.cloneDictionary[key])) {
                this.makeClone(key, this[key]);
                this.instance.settings[key] = this[key];
                changed = true;
                if (key == 'invalid') {
                    invalid = true;
                }
                if (key == 'data') {
                    data = true;
                }
            }
        }
        if (changed && this.instance) {
            this.updateOptions(this.cloneDictionary, false, invalid, data);
        }
    };
    MbscCloneBase.prototype.ngOnInit = function () {
        for (var key in this.cloneDictionary) {
            this.makeClone(key, this[key]);
        }
    };
    MbscCloneBase = __decorate([
        Directive({ selector: '[mbsc-c-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone])
    ], MbscCloneBase);
    return MbscCloneBase;
}(MbscValueBase));
var MbscControlBase = (function (_super) {
    __extends(MbscControlBase, _super);
    function MbscControlBase(initialElement, zone, control, _inputService, _view) {
        var _this = _super.call(this, initialElement, zone) || this;
        _this.control = control;
        _this._inputService = _inputService;
        _this._view = _view;
        _this._needsTimeout = true;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.onChangeEmitter = new EventEmitter();
        _this.oldAccessor = null;
        _this.overwriteAccessor();
        if (_inputService) {
            _inputService.isControlSet = true;
        }
        return _this;
    }
    Object.defineProperty(MbscControlBase.prototype, "optionExtensions", {
        get: function () {
            var _this = this;
            var externalOnClose = this.options && this.options.onClose;
            var externalOnFill = this.options && this.options.onFill;
            var onCloseEmitter = this.onClose;
            return {
                onFill: function (event, inst) {
                    if (_this.oldAccessor) {
                        _this.oldAccessor.writeValue(event.valueText);
                    }
                    else {
                        var ionInput = _this.getIonInput();
                        if (ionInput) {
                            ionInput.value = event.valueText;
                        }
                    }
                    if (externalOnFill) {
                        externalOnFill(event, inst);
                    }
                },
                onClose: function (event, inst) {
                    _this.onTouch();
                    if (externalOnClose) {
                        externalOnClose(event, inst);
                    }
                    if (onCloseEmitter) {
                        event.inst = inst;
                        onCloseEmitter.emit(event);
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscControlBase.prototype, "enableManualEdit", {
        get: function () {
            var nsf = this.showOnFocus === false || this.options.showOnFocus === false, nst = this.showOnTap === false || this.options.showOnTap === false;
            return nsf && nst;
        },
        enumerable: true,
        configurable: true
    });
    MbscControlBase.prototype.handleChange = function (element) {
        var that = this;
        $$1(element || this.element).on('change', function () {
            that.zone.run(function () {
                if (that.element.value !== that.instance._value && that.enableManualEdit) {
                    that.instance.setVal(that.element.value, true, true);
                }
                else {
                    var value = that.instance.getVal();
                    if (that.control) {
                        if (!valueEquals(value, that.control.model)) {
                            that.onChange(value);
                            that.control.control.patchValue(value);
                        }
                    }
                    else {
                        that.onChangeEmitter.emit(value);
                    }
                }
            });
        });
        function valueEquals(v1, v2) {
            if (v1 === v2) {
                return true;
            }
            if (v1 instanceof Date && v2 instanceof Date) {
                return (+v1) === (+v2);
            }
            return false;
        }
    };
    MbscControlBase.prototype.overwriteAccessor = function () {
        if (this.control) {
            if (this.control.valueAccessor !== this) {
                this.oldAccessor = this.control.valueAccessor;
            }
            this.control.valueAccessor = this;
        }
    };
    MbscControlBase.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.handleChange();
        this.overwriteAccessor();
        if (this.control && this.control._setUpControl) {
            this.control._setUpControl();
        }
    };
    MbscControlBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscControlBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscControlBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.oldAccessor && this.oldAccessor.setDisabledState) {
            this.oldAccessor.setDisabledState(isDisabled);
        }
        if (this.instance && this.instance.disable && this.instance.enable) {
            if (isDisabled) {
                this.instance.disable();
            }
            else {
                this.instance.enable();
            }
        }
    };
    MbscControlBase.prototype.writeValue = function (v) {
        var _this = this;
        if (this._needsTimeout) {
            this.pendingValue = v;
            setTimeout(function () {
                _this.pendingValue = undefined;
                _this.setNewValueProxy(v);
            });
        }
        else {
            this.setNewValueProxy(v);
        }
    };
    __decorate([
        Input$1('label-style'),
        __metadata("design:type", String)
    ], MbscControlBase.prototype, "labelStyle", void 0);
    __decorate([
        Input$1('input-style'),
        __metadata("design:type", String)
    ], MbscControlBase.prototype, "inputStyle", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscControlBase.prototype, "showOnFocus", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscControlBase.prototype, "showOnTap", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscControlBase.prototype, "disabled", void 0);
    MbscControlBase = __decorate([
        Directive({ selector: '[mbsc-cc-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])
    ], MbscControlBase);
    return MbscControlBase;
}(MbscCloneBase));
var MbscFrameBase = (function (_super) {
    __extends(MbscFrameBase, _super);
    function MbscFrameBase(initialElem, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElem, zone, control, _inputService, view) || this;
        _this.onBeforeClose = new EventEmitter();
        _this.onBeforeShow = new EventEmitter();
        _this.onCancel = new EventEmitter();
        _this.onClose = new EventEmitter();
        _this.onFill = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onPosition = new EventEmitter();
        _this.onShow = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscFrameBase.prototype, "inline", {
        get: function () {
            return (this.display || (this.options && this.options.display)) === 'inline';
        },
        enumerable: true,
        configurable: true
    });
    MbscFrameBase.prototype.ngOnInit = function () {
        this.cloneDictionary.invalid = [];
        this.cloneDictionary.valid = [];
        _super.prototype.ngOnInit.call(this);
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFrameBase.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFrameBase.prototype, "dropdown", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFrameBase.prototype, "anchor", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFrameBase.prototype, "animate", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscFrameBase.prototype, "buttons", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFrameBase.prototype, "closeOnOverlayTap", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFrameBase.prototype, "context", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscFrameBase.prototype, "display", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFrameBase.prototype, "showInput", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFrameBase.prototype, "focusOnClose", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFrameBase.prototype, "focusTrap", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFrameBase.prototype, "headerText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFrameBase.prototype, "scrollLock", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFrameBase.prototype, "touchUi", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onBeforeClose", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onBeforeShow", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onCancel", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onClose", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onFill", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onMarkupReady", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onPosition", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscFrameBase.prototype, "onShow", void 0);
    MbscFrameBase = __decorate([
        Directive({ selector: '[mbsc-fr-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])
    ], MbscFrameBase);
    return MbscFrameBase;
}(MbscControlBase));
var MbscScrollerBase = (function (_super) {
    __extends(MbscScrollerBase, _super);
    function MbscScrollerBase(initialElement, zone, control, _inputService, view) {
        var _this = _super.call(this, initialElement, zone, control, _inputService, view) || this;
        _this.onWheelChange = new EventEmitter();
        _this.onSet = new EventEmitter();
        _this.onItemTap = new EventEmitter();
        _this.onClear = new EventEmitter();
        return _this;
    }
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscScrollerBase.prototype, "circular", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscScrollerBase.prototype, "height", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscScrollerBase.prototype, "layout", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscScrollerBase.prototype, "maxWidth", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscScrollerBase.prototype, "minWidth", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscScrollerBase.prototype, "multiline", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscScrollerBase.prototype, "readonly", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscScrollerBase.prototype, "rows", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscScrollerBase.prototype, "showLabel", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscScrollerBase.prototype, "showScrollArrows", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscScrollerBase.prototype, "wheels", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscScrollerBase.prototype, "width", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Function)
    ], MbscScrollerBase.prototype, "validate", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscScrollerBase.prototype, "cancelText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscScrollerBase.prototype, "clearText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscScrollerBase.prototype, "selectedText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscScrollerBase.prototype, "setText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Function)
    ], MbscScrollerBase.prototype, "formatValue", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Function)
    ], MbscScrollerBase.prototype, "parseValue", void 0);
    __decorate([
        Output('onChange'),
        __metadata("design:type", EventEmitter)
    ], MbscScrollerBase.prototype, "onWheelChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscScrollerBase.prototype, "onSet", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscScrollerBase.prototype, "onItemTap", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscScrollerBase.prototype, "onClear", void 0);
    MbscScrollerBase = __decorate([
        Directive({ selector: '[mbsc-s-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])
    ], MbscScrollerBase);
    return MbscScrollerBase;
}(MbscFrameBase));
var MbscBaseModule = (function () {
    function MbscBaseModule() {
    }
    MbscBaseModule = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase],
        })
    ], MbscBaseModule);
    return MbscBaseModule;
}());
var MbscFrameBaseModule = (function () {
    function MbscFrameBaseModule() {
    }
    MbscFrameBaseModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscBaseModule],
            declarations: [MbscFrameBase],
        })
    ], MbscFrameBaseModule);
    return MbscFrameBaseModule;
}());
var MbscScrollerBaseModule = (function () {
    function MbscScrollerBaseModule() {
    }
    MbscScrollerBaseModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscFrameBaseModule],
            declarations: [MbscScrollerBase],
        })
    ], MbscScrollerBaseModule);
    return MbscScrollerBaseModule;
}());
function deepEqualsArray(a1, a2) {
    if (a1 === a2) {
        return true;
    }
    else if (!a1 || !a2 || a1.length !== a2.length) {
        return false;
    }
    else {
        for (var i = 0; i < a1.length; i++) {
            if (a1[i] !== a2[i]) {
                return false;
            }
        }
        return true;
    }
}
function isDateEqual(d1, d2) {
    if ((d1 && !d2) || (d2 && !d1)) {
        return false;
    }
    else if (!d1 && !d2) {
        return true;
    }
    else {
        return d1 && d2 && d1.toString() === d2.toString();
    }
}
function emptyOrTrue(val) {
    return (typeof (val) === 'string' && (val === 'true' || val === '')) || !!val;
}
var INPUT_TEMPLATE = "<mbsc-input *ngIf=\"!inline || showInput\"\n    [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [themeVariant]=\"themeVariant\" [label-style]=\"labelStyle\" [input-style]=\"inputStyle\" [disabled]=\"disabled\" [dropdown]=\"dropdown\" [placeholder]=\"placeholder\"\n    [error]=\"error\" [errorMessage]=\"errorMessage\"\n    [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n    <ng-content></ng-content>\n</mbsc-input>";

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var wrapClass = 'mbsc-input-wrap';
var events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];
var defaults = {
  tap: hasGhostClick
};
var $active;

function addIcon($control, ic) {
  var icons = {},
      control = $control[0],
      $parent = $control.parent(),
      errorMsg = $parent.find('.mbsc-err-msg'),
      align = $control.attr('data-icon-align') || 'left',
      icon = $control.attr('data-icon');

  if ($parent.hasClass(wrapClass)) {
    $parent = $parent.parent();
  } else {
    // Wrap input
    $$1('<span class="' + wrapClass + '"></span>').insertAfter($control).append($control);
  }

  if (errorMsg) {
    $parent.find('.' + wrapClass).append(errorMsg);
  }

  if (icon) {
    if (icon.indexOf('{') !== -1) {
      icons = JSON.parse(icon);
    } else {
      icons[align] = icon;
    }
  }

  if (control.type == 'file') {
    // Set icon
    icons.right = $control.attr('data-icon-upload') || 'upload';
  }

  if (icon || ic) {
    extend$1(icons, ic);
    $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class="mbsc-input-fill"></span>').append(icons.left ? '<span class="mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '"></span>' : '').append(icons.right ? '<span class="mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '"></span>' : '');
  }
}

function addIconToggle(that, $parent, $control) {
  var icons = {},
      control = $control[0],
      toggle = $control.attr('data-password-toggle'),
      iconShow = $control.attr('data-icon-show') || 'eye',
      iconHide = $control.attr('data-icon-hide') || 'eye-blocked';

  if (toggle) {
    icons.right = control.type == 'password' ? iconShow : iconHide;
  }

  addIcon($control, icons);

  if (toggle) {
    tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {
      if (control.type == "text") {
        control.type = "password";
        $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);
      } else {
        control.type = "text";
        $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);
      }
    });
  }
}

function wrapLabel($parent, type, inputStyle, labelStyle, elm) {
  // Wrap non-empty text nodes in span with mbsc-label class
  if (type == 'segmented') {
    $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');
  } else if (type != 'button' && type != 'submit') {
    $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {
      $$1(v).attr('title', $$1(v).text());
    });
    $parent.contents().filter(function () {
      return this.nodeType == 3 && this.nodeValue && /\S/.test(this.nodeValue);
    }).each(function () {
      $$1('<span class="mbsc-label" title="' + this.textContent.trim() + '"></span>').insertAfter(this).append(this);
    });
  }
}

function getRipple(theme) {
  var ripple = mobiscroll.themes.form[theme];
  return ripple && ripple.addRipple ? ripple : null;
}

function getAttr($elm, attr, def) {
  var v = $elm.attr(attr);
  return v === undefined || v === '' ? def : v;
}

function getCssClass(s) {
  var theme = getThemeName(s);
  var baseTheme = mobiscroll.themes.form[theme].baseTheme;
  return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');
}

var FormControl =
/*#__PURE__*/
function () {
  function FormControl(elm, settings) {
    var _this = this;

    var s = extend$1({}, defaults, mobiscroll.settings, settings);
    var $elm = $$1(elm);
    var $p = $elm.parent();
    var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components

    var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;
    var type = getControlType($elm);
    var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);
    var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);

    if (elm.mbscInst) {
      elm.mbscInst.destroy();
    }

    if ($frame) {
      $frame.insertAfter($parent);
    }

    s.theme = getThemeName(s);

    if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {
      s.rtl = mobiscroll.i18n[s.lang].rtl;
    }

    wrapLabel($parent, type, inputStyle, labelStyle, elm);
    $elm.addClass('mbsc-control'); // Attach events

    this._handle = this._handle.bind(this); // Prevent 300ms click latency

    events.forEach(function (ev) {
      $elm.on(ev, _this._handle);
    }); // Touch events are added separately, needs to be passive listener

    listen(elm, 'touchstart', this._handle, {
      passive: true
    });
    listen(elm, 'touchmove', this._handle, {
      passive: true
    });
    this.settings = s;
    this._type = type;
    this._elm = elm;
    this._$elm = $elm;
    this._$parent = $parent;
    this._$frame = $frame;
    this._ripple = getRipple(s.theme);
    this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');
    this.cssClass = getCssClass(s);
    this.getClassElm().addClass(this.cssClass);
    elm.mbscInst = this;
  }

  var _proto = FormControl.prototype;

  _proto.getClassElm = function getClassElm() {
    return this._$parent;
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    var $elm = this._$elm;
    var elm = this._elm;
    $elm.removeClass('mbsc-control');
    this.getClassElm().removeClass(this.cssClass);
    events.forEach(function (ev) {
      $elm.off(ev, _this2._handle);
    });
    unlisten(elm, 'touchstart', this._handle, {
      passive: true
    });
    unlisten(elm, 'touchmove', this._handle, {
      passive: true
    });
    delete elm.mbscInst;
  };

  _proto.option = function option(s) {
    extend$1(this.settings, s);
    var classElm = this.getClassElm();

    if (this.cssClass) {
      classElm.removeClass(this.cssClass);
    }

    this.cssClass = getCssClass(this.settings);
    classElm.addClass(this.cssClass);
    this._ripple = getRipple(this.settings.theme);
  };

  _proto._handle = function _handle(ev) {
    switch (ev.type) {
      case 'touchstart':
      case 'mousedown':
        this._onStart(ev);

        break;

      case 'touchmove':
      case 'mousemove':
        this._onMove(ev);

        break;

      case 'touchend':
      case 'touchcancel':
      case 'mouseup':
      case 'mouseleave':
        this._onEnd(ev);

        break;
    }
  };

  _proto._addRipple = function _addRipple(ev) {
    if (this._ripple && this._$rippleElm) {
      this._ripple.addRipple(this._$rippleElm, ev);
    }
  };

  _proto._removeRipple = function _removeRipple() {
    if (this._ripple && this._$rippleElm) {
      this._ripple.removeRipple();
    }
  };

  _proto._onStart = function _onStart(ev) {
    var elm = this._elm;

    if (testTouch(ev, elm)) {
      this._startX = getCoord(ev, 'X');
      this._startY = getCoord(ev, 'Y');

      if ($active) {
        $active.removeClass('mbsc-active');
      }

      if (!elm.disabled) {
        this._isActive = true;
        $active = this._$elm;
        $active.addClass('mbsc-active');

        this._addRipple(ev);
      }
    }

    if (ev.type == 'touchstart') {
      this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }
  };

  _proto._onMove = function _onMove(ev) {
    // If movement is more than 9px, don't fire the click event handler
    if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {
      this._$elm.removeClass('mbsc-active');

      this._removeRipple();

      this._isActive = false;
    }
  };

  _proto._onEnd = function _onEnd(ev) {
    var _this3 = this;

    var control = this._elm;
    var type = this._type;

    if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {
      activateControl(control, type, ev);
    }

    if (this._isActive) {
      setTimeout(function () {
        _this3._$elm.removeClass('mbsc-active');

        _this3._removeRipple();
      }, 100);
    }

    this._isActive = false;
    $active = null;
  };

  return FormControl;
}();
mobiscroll.themes.form.mobiscroll = {};

var events$1 = ['focus', 'change', 'blur', 'animationstart'];
var Input =
/*#__PURE__*/
function (_FormControl) {
  _inheritsLoose(Input, _FormControl);

  function Input(elm, settings) {
    var _this;

    _this = _FormControl.call(this, elm, settings) || this;
    var $elm = _this._$elm;
    var $parent = _this._$parent;
    var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');
    addIconToggle(_assertThisInitialized(_this), $parent, $elm);
    _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));
    _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));
    _this._setText = _this._setText.bind(_assertThisInitialized(_this));

    if (elm.type == 'file') {
      // Copy attributes and create dummy input
      var $existing = $parent.find('.mbsc-file-input');
      _this._$input = $existing.length ? $existing : $$1('<input type="text" class="' + ($elm.attr('class') || '') + ' mbsc-file-input" placeholder="' + ($elm.attr('placeholder') || '') + '"/>').insertAfter($elm); // Copy value on file upload

      $elm.on('change', _this._setText);
    }

    $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events

    events$1.forEach(function (ev) {
      $elm.on(ev, _this._checkLabel);
    }); // Move the dummy input after the element for correct styling

    if ($dummy.length) {
      $elm.after($dummy);

      if ($dummy.hasClass('mbsc-select-input')) {
        _this._delm = $dummy[0];

        _this.refresh();
      }
    }

    return _this;
  }

  var _proto = Input.prototype;

  _proto._setText = function _setText(ev) {
    var files = ev.target.files;
    var names = [];

    for (var i = 0; i < files.length; ++i) {
      names.push(files[i].name);
    }

    this._$input.val(names);
  };

  _proto._checkLabel = function _checkLabel(ev) {
    if (this._isFloating) {
      // In case of select we need to check the dummy element
      var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire 
      // due to the empty animation added in the css,
      // because there's no other event in case of the initial autofill

      if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {
        this._$parent.addClass('mbsc-label-floating-active');
      } else {
        this._$parent.removeClass('mbsc-label-floating-active');
      }
    }
  };

  _proto._mouseDown = function _mouseDown(ev) {
    // Will prevent floating label animation when loosing focus only for a brief moment
    if (document.activeElement === this._elm && ev.target !== this._elm) {
      ev.preventDefault();
    }
  };

  _proto.refresh = function refresh() {
    this._checkLabel();
  };

  _proto.destroy = function destroy() {
    var _this2 = this;

    _FormControl.prototype.destroy.call(this);

    this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();

    this._$parent.find('.mbsc-input-fill').remove();

    events$1.forEach(function (ev) {
      _this2._$elm.off(ev, _this2._checkLabel);
    });

    this._$elm.off('change', this._setText);
  };

  return Input;
}(FormControl); // Init mbsc-input elements on page load

autoInit('[mbsc-input]', Input);

var MbscFormBase = (function (_super) {
    __extends(MbscFormBase, _super);
    function MbscFormBase(hostElem, _formService, zone) {
        var _this = _super.call(this, hostElem, zone) || this;
        _this._formService = _formService;
        _this.disabled = false;
        return _this;
    }
    MbscFormBase.prototype.ngOnInit = function () {
        this._inheritedOptions = this._formService ? this._formService.options : {};
    };
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscFormBase.prototype, "color", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscFormBase.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFormBase.prototype, "disabled", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscFormBase.prototype, "name", void 0);
    __decorate([
        ViewChild('initElement', { static: false }),
        __metadata("design:type", ElementRef)
    ], MbscFormBase.prototype, "_initElem", void 0);
    MbscFormBase = __decorate([
        Directive({ selector: '[mbsc-f-b]' }),
        __metadata("design:paramtypes", [ElementRef, MbscOptionsService, NgZone])
    ], MbscFormBase);
    return MbscFormBase;
}(MbscBase));
var MbscFormValueBase = (function (_super) {
    __extends(MbscFormValueBase, _super);
    function MbscFormValueBase(hostElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, hostElem, _formService, zone) || this;
        _this._control = _control;
        _this.onChange = function () { };
        _this.onTouch = function () { };
        _this.errorMessage = '';
        _this.valueChangeEmitter = new EventEmitter();
        if (_control && (!_inputService || !_inputService.isControlSet)) {
            if (_control.valueAccessor && _control.valueAccessor.oldAccessor !== undefined) {
                _control.valueAccessor.oldAccessor = _this;
            }
            else {
                _control.valueAccessor = _this;
            }
        }
        return _this;
    }
    Object.defineProperty(MbscFormValueBase.prototype, "readonly", {
        set: function (val) {
            this._readonly = emptyOrTrue(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "innerValue", {
        get: function () {
            return this._value;
        },
        set: function (v) {
            this._value = v;
            this.onChange(v);
            this.valueChangeEmitter.emit(v);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscFormValueBase.prototype, "value", {
        set: function (v) {
            this._value = v;
            this.refresh();
        },
        enumerable: true,
        configurable: true
    });
    MbscFormValueBase.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscFormValueBase.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscFormValueBase.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    MbscFormValueBase.prototype.writeValue = function (v) {
        this._value = v;
        this.refresh();
    };
    MbscFormValueBase.prototype.refresh = function () {
        var _this = this;
        if (this.instance && this.instance.refresh) {
            setTimeout(function () {
                _this.instance.refresh();
            });
        }
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MbscFormValueBase.prototype, "readonly", null);
    __decorate([
        Input$1(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MbscFormValueBase.prototype, "value", null);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscFormValueBase.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscFormValueBase.prototype, "errorMessage", void 0);
    __decorate([
        Output('valueChange'),
        __metadata("design:type", EventEmitter)
    ], MbscFormValueBase.prototype, "valueChangeEmitter", void 0);
    MbscFormValueBase = __decorate([
        Directive({ selector: '[mbsc-fv-b]' }),
        __param(1, Optional()), __param(2, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])
    ], MbscFormValueBase);
    return MbscFormValueBase;
}(MbscFormBase));
var MbscInputBase = (function (_super) {
    __extends(MbscInputBase, _super);
    function MbscInputBase(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this.type = 'text';
        _this.placeholder = '';
        return _this;
    }
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "autocomplete", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "autocapitalize", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "autocorrect", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "spellcheck", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "autofocus", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscInputBase.prototype, "minlength", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscInputBase.prototype, "maxlength", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "required", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "icon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "type", void 0);
    __decorate([
        Input$1('password-toggle'),
        __metadata("design:type", Boolean)
    ], MbscInputBase.prototype, "passwordToggle", void 0);
    __decorate([
        Input$1('icon-show'),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "iconShow", void 0);
    __decorate([
        Input$1('icon-hide'),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "iconHide", void 0);
    __decorate([
        Input$1('icon-upload'),
        __metadata("design:type", Boolean)
    ], MbscInputBase.prototype, "iconUpload", void 0);
    __decorate([
        Input$1('input-style'),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "inputStyle", void 0);
    __decorate([
        Input$1('label-style'),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "labelStyle", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInputBase.prototype, "placeholder", void 0);
    MbscInputBase = __decorate([
        Directive({ selector: '[mbsc-i-b]' }),
        __param(1, Optional()), __param(2, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])
    ], MbscInputBase);
    return MbscInputBase;
}(MbscFormValueBase));
var MbscInput = (function (_super) {
    __extends(MbscInput, _super);
    function MbscInput(initialElem, _formService, _inputService, _control, zone) {
        var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;
        _this._inputService = _inputService;
        _this.controlNg = true;
        _this.dropdown = false;
        _inputService.input = _this;
        return _this;
    }
    MbscInput.prototype.initControl = function () {
        var _this = this;
        var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);
        this.instance = new Input(this._initElem.nativeElement, options);
        setTimeout(function () {
            _this.instance.refresh();
        });
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscInput.prototype, "min", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscInput.prototype, "max", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscInput.prototype, "step", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInput.prototype, "pattern", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInput.prototype, "accept", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscInput.prototype, "multiple", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscInput.prototype, "controlNg", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscInput.prototype, "dropdown", void 0);
    MbscInput = __decorate([
        Component({
            selector: 'mbsc-input',
            host: {
                '[class.mbsc-control-ng]': 'controlNg',
                '[class.mbsc-err]': 'error'
            },
            template: "\n        <label\n            [class.mbsc-err]=\"error\" [class.mbsc-select]=\"dropdown\"\n            [class.mbsc-input-box]=\"inputStyle == 'box'\"\n            [class.mbsc-input-outline]=\"inputStyle == 'outline'\"\n            [class.mbsc-label-stacked]=\"labelStyle == 'stacked'\"\n            [class.mbsc-label-inline]=\"labelStyle == 'inline'\"\n            [class.mbsc-label-floating]=\"labelStyle == 'floating'\"\n        >\n            <ng-content></ng-content>\n            <span class=\"mbsc-input-wrap\">\n                <input #initElement [type]=\"type\" [placeholder]=\"placeholder\" [(ngModel)]=\"innerValue\" (blur)=\"onTouch($event)\"\n                    [attr.name]=\"name\"\n                    [attr.data-icon]=\"icon ? icon : null\"\n                    [attr.data-icon-align]=\"iconAlign ? iconAlign : null\"\n                    [attr.data-password-toggle]=\"passwordToggle ? 'true': null\"\n                    [attr.data-icon-show]=\"iconShow ? iconShow : null\"\n                    [attr.data-icon-hide]=\"iconHide ? iconHide : null\"\n                    [attr.data-icon-upload]=\"iconUpload ? iconUpload : null\"\n                    [attr.min]=\"min\"\n                    [attr.max]=\"max\"\n                    [attr.minlength]=\"minlength\"\n                    [attr.maxlength]=\"maxlength\"\n                    [attr.autocomplete]=\"autocomplete\"\n                    [attr.autocapitalize]=\"autocapitalize\"\n                    [attr.autocorrect]=\"autocorrect\"\n                    [attr.spellcheck]=\"spellcheck\"\n                    [attr.autofocus]=\"autofocus\"\n                    [attr.step]=\"step\"\n                    [attr.pattern]=\"pattern\"\n                    [attr.required]=\"required\"\n                    [attr.accept]=\"accept\"\n                    [attr.multiple]=\"multiple\"\n                    [disabled]=\"disabled\"\n                    [readonly]=\"_readonly\" />\n                <span *ngIf=\"dropdown\" class=\"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\"></span>\n                <span *ngIf=\"error && errorMessage\" class=\"mbsc-err-msg\">{{errorMessage}}</span>\n            </span>\n        </label>\n    ",
            providers: [MbscInputService]
        }),
        __param(1, Optional()), __param(3, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])
    ], MbscInput);
    return MbscInput;
}(MbscInputBase));
var MbscInputModule = (function () {
    function MbscInputModule() {
    }
    MbscInputModule = __decorate([
        NgModule({
            imports: [FormsModule, CommonModule, MbscBaseModule],
            declarations: [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase],
            exports: [MbscInput]
        })
    ], MbscInputModule);
    return MbscInputModule;
}());

function adjustedDate(y, m, d, h, i, s, u) {
  var date = new Date(y, m, d, h || 0, i || 0, s || 0, u || 0);

  if (date.getHours() == 23 && (h || 0) === 0) {
    date.setHours(date.getHours() + 2);
  }

  return date;
}
/**
 * Format a date into a string value with a specified format.
 * @param {String} format Output format.
 * @param {Date} date Date to format.
 * @param {Object} [settings={}] Settings.
 * @return {String} Returns the formatted date string.
 */


function formatDate(format, date, settings) {
  if (!date) {
    return null;
  }

  var s = extend$1({}, dateTimeDefaults, settings),
      look = function look(m) {
    // Check whether a format character is doubled
    var n = 0;

    while (i + 1 < format.length && format.charAt(i + 1) == m) {
      n++;
      i++;
    }

    return n;
  },
      f1 = function f1(m, val, len) {
    // Format a number, with leading zero if necessary
    var n = '' + val;

    if (look(m)) {
      while (n.length < len) {
        n = '0' + n;
      }
    }

    return n;
  },
      f2 = function f2(m, val, s, l) {
    // Format a name, short or long as requested
    return look(m) ? l[val] : s[val];
  },
      i,
      year,
      output = '',
      literal = false;

  for (i = 0; i < format.length; i++) {
    if (literal) {
      if (format.charAt(i) == "'" && !look("'")) {
        literal = false;
      } else {
        output += format.charAt(i);
      }
    } else {
      switch (format.charAt(i)) {
        case 'd':
          output += f1('d', s.getDay(date), 2);
          break;

        case 'D':
          output += f2('D', date.getDay(), s.dayNamesShort, s.dayNames);
          break;

        case 'o':
          output += f1('o', (date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);
          break;

        case 'm':
          output += f1('m', s.getMonth(date) + 1, 2);
          break;

        case 'M':
          output += f2('M', s.getMonth(date), s.monthNamesShort, s.monthNames);
          break;

        case 'y':
          year = s.getYear(date);
          output += look('y') ? year : (year % 100 < 10 ? '0' : '') + year % 100; //output += (look('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);

          break;

        case 'h':
          var h = date.getHours();
          output += f1('h', h > 12 ? h - 12 : h === 0 ? 12 : h, 2);
          break;

        case 'H':
          output += f1('H', date.getHours(), 2);
          break;

        case 'i':
          output += f1('i', date.getMinutes(), 2);
          break;

        case 's':
          output += f1('s', date.getSeconds(), 2);
          break;

        case 'a':
          output += date.getHours() > 11 ? s.pmText : s.amText;
          break;

        case 'A':
          output += date.getHours() > 11 ? s.pmText.toUpperCase() : s.amText.toUpperCase();
          break;

        case "'":
          if (look("'")) {
            output += "'";
          } else {
            literal = true;
          }

          break;

        default:
          output += format.charAt(i);
      }
    }
  }

  return output;
} // --- TRIAL SERVER CODE END ---

/**
 * Extract a date from a string value with a specified format.
 * @param {String} format Input format.
 * @param {String} value String to parse.
 * @param {Object} [settings={}] Settings.
 * @return {Date} Returns the extracted date.
 */


function parseDate(format, value, settings) {
  var s = extend$1({}, dateTimeDefaults, settings),
      def = makeDate(s.defaultValue || new Date());

  if (!format || !value) {
    return def;
  } // If already a date object


  if (value.getTime) {
    return value;
  }

  value = typeof value == 'object' ? value.toString() : value + '';

  var shortYearCutoff = s.shortYearCutoff,
      year = s.getYear(def),
      month = s.getMonth(def) + 1,
      day = s.getDay(def),
      doy = -1,
      hours = def.getHours(),
      minutes = def.getMinutes(),
      seconds = 0,
      //def.getSeconds(),
  ampm = -1,
      literal = false,
      // Check whether a format character is doubled
  lookAhead = function lookAhead(match) {
    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) == match;

    if (matches) {
      iFormat++;
    }

    return matches;
  },
      getNumber = function getNumber(match) {
    // Extract a number from the string value
    lookAhead(match);
    var size = match == '@' ? 14 : match == '!' ? 20 : match == 'y' ? 4 : match == 'o' ? 3 : 2,
        digits = new RegExp('^\\d{1,' + size + '}'),
        num = value.substr(iValue).match(digits);

    if (!num) {
      return 0;
    }

    iValue += num[0].length;
    return parseInt(num[0], 10);
  },
      getName = function getName(match, s, l) {
    // Extract a name from the string value and convert to an index
    var names = lookAhead(match) ? l : s,
        i;

    for (i = 0; i < names.length; i++) {
      if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {
        iValue += names[i].length;
        return i + 1;
      }
    }

    return 0;
  },
      checkLiteral = function checkLiteral() {
    iValue++;
  },
      iValue = 0,
      iFormat;

  for (iFormat = 0; iFormat < format.length; iFormat++) {
    if (literal) {
      if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
        literal = false;
      } else {
        checkLiteral();
      }
    } else {
      switch (format.charAt(iFormat)) {
        case 'd':
          day = getNumber('d');
          break;

        case 'D':
          getName('D', s.dayNamesShort, s.dayNames);
          break;

        case 'o':
          doy = getNumber('o');
          break;

        case 'm':
          month = getNumber('m');
          break;

        case 'M':
          month = getName('M', s.monthNamesShort, s.monthNames);
          break;

        case 'y':
          year = getNumber('y');
          break;

        case 'H':
          hours = getNumber('H');
          break;

        case 'h':
          hours = getNumber('h');
          break;

        case 'i':
          minutes = getNumber('i');
          break;

        case 's':
          seconds = getNumber('s');
          break;

        case 'a':
          ampm = getName('a', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
          break;

        case 'A':
          ampm = getName('A', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
          break;

        case "'":
          if (lookAhead("'")) {
            checkLiteral();
          } else {
            literal = true;
          }

          break;

        default:
          checkLiteral();
      }
    }
  }

  if (year < 100) {
    year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)) ? 0 : -100);
  }

  if (doy > -1) {
    month = 1;
    day = doy;

    do {
      var dim = 32 - new Date(year, month - 1, 32, 12).getDate();

      if (day > dim) {
        month++;
        day -= dim;
      }
    } while (day > dim);
  }

  hours = ampm == -1 ? hours : ampm && hours < 12 ? hours + 12 : !ampm && hours == 12 ? 0 : hours;
  var date = s.getDate(year, month - 1, day, hours, minutes, seconds);

  if (s.getYear(date) != year || s.getMonth(date) + 1 != month || s.getDay(date) != day) {
    return def; // Invalid date
  }

  return date;
}

function getDayDiff(d1, d2) {
  return Math.round((d2 - d1) / (24 * 60 * 60 * 1000));
}

function getDateOnly(d) {
  return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
}

function getDateStr(d) {
  return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();
}

function getISOString(d, parts) {
  var ret = '',
      time = '';

  if (d) {
    if (parts.h) {
      time += pad(d.getHours()) + ':' + pad(d.getMinutes());

      if (parts.s) {
        time += ':' + pad(d.getSeconds());
      }

      if (parts.u) {
        time += '.' + pad(d.getMilliseconds(), 3);
      }

      if (parts.tz) {
        time += parts.tz; // Just put what we got
      }
    }

    if (parts.y) {
      ret += d.getFullYear();

      if (parts.m) {
        ret += '-' + pad(d.getMonth() + 1);

        if (parts.d) {
          ret += '-' + pad(d.getDate());
        }

        if (parts.h) {
          ret += 'T' + time;
        }
      }
    } else if (parts.h) {
      ret = time;
    }
  }

  return ret;
}

function setISOParts(parsed, offset, parts) {
  var part,
      v,
      p = {
    y: 1,
    m: 2,
    d: 3,
    h: 4,
    i: 5,
    s: 6,
    u: 7,
    tz: 8
  };

  if (parts) {
    for (part in p) {
      v = parsed[p[part] - offset];

      if (v) {
        parts[part] = part == 'tz' ? v : 1;
      }
    }
  }
}

function returnDate(d, s, displayFormat) {
  var moment = window.moment || s.moment,
      format = s.returnFormat;

  if (d) {
    if (format == 'moment' && moment) {
      return moment(d);
    }

    if (format == 'locale') {
      return formatDate(displayFormat, d, s);
    }

    if (format == 'iso8601') {
      return getISOString(d, s.isoParts);
    }
  }

  return d;
}

function makeDate(d, format, s, parts) {
  var parse;

  if (!d) {
    return null;
  } // If already date object


  if (d.getTime) {
    return d;
  } // Moment object


  if (d.toDate) {
    return d.toDate();
  }

  if (typeof d == 'string') {
    d = d.trim();
  }

  parse = ISO_8601_TIME.exec(d); // If ISO 8601 time string

  if (parse) {
    setISOParts(parse, 2, parts);
    return new Date(1970, 0, 1, parse[2] ? +parse[2] : 0, parse[3] ? +parse[3] : 0, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0);
  }

  if (!parse) {
    parse = ISO_8601_FULL.exec(d);
  } // If ISO 8601 date string


  if (parse) {
    setISOParts(parse, 0, parts);
    return new Date(parse[1] ? +parse[1] : 1970, parse[2] ? parse[2] - 1 : 0, parse[3] ? +parse[3] : 1, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0, parse[6] ? +parse[6] : 0, parse[7] ? +parse[7] : 0);
  } // Parse date based on format


  return parseDate(format, d, s);
}

function isSameDay(d1, d2) {
  return d1.getFullYear() == d2.getFullYear() && d1.getMonth() == d2.getMonth() && d1.getDate() == d2.getDate();
}

var ISO_8601_FULL = /^(\d{4}|[+-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?((Z)|([+-])(\d{2})(?::(\d{2}))?)?)?$/;
var ISO_8601_TIME = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+-])(\d{2})(?::(\d{2}))?)?)?$/;
var DAY_OF_MONTH = /^\d{1,2}(\/\d{1,2})?$/;
var DAY_OF_WEEK = /^w\d$/i;
var dateTimeDefaults = {
  shortYearCutoff: '+10',
  monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  amText: 'am',
  pmText: 'pm',
  getYear: function getYear(d) {
    return d.getFullYear();
  },
  getMonth: function getMonth(d) {
    return d.getMonth();
  },
  getDay: function getDay(d) {
    return d.getDate();
  },
  getDate: adjustedDate,
  getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {
    return 32 - new Date(y, m, 32, 12).getDate();
  },
  getWeekNumber: function getWeekNumber(d) {
    // Copy date so don't modify original
    d = new Date(d);
    d.setHours(0, 0, 0); // Set to nearest Thursday: current date + 4 - current day number
    // Make Sunday's day number 7

    d.setDate(d.getDate() + 4 - (d.getDay() || 7)); // Get first day of year

    var yearStart = new Date(d.getFullYear(), 0, 1); // Calculate full weeks to nearest Thursday

    return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
  }
};
util.datetime = {
  formatDate: formatDate,
  parseDate: parseDate
};

function createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {
  var $btn,
      changed,
      index,
      running,
      source,
      startX,
      startY,
      step,
      timer,
      check = isReadOnly || noop;

  function onBtnStart(ev) {
    var proceed;
    $btn = $$1(this);
    step = +$btn.attr('data-step');
    index = +$btn.attr('data-index');
    changed = true;

    if (stopProp) {
      ev.stopPropagation();
    }

    if (ev.type == 'touchstart') {
      $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');
    }

    if (ev.type == 'mousedown') {
      // Prevent focus
      ev.preventDefault();
    }

    if (ev.type != 'keydown') {
      //e.preventDefault();
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      proceed = testTouch(ev, this);
    } else {
      proceed = ev.keyCode === 32;
    }

    if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {
      if (start(index, step, ev)) {
        $btn.addClass('mbsc-active');

        if (ripple) {
          ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);
        }
      }

      if (ev.type == 'mousedown') {
        $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);
      }
    }
  }

  function onBtnMove(ev) {
    if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {
      changed = true;
      stop();
    }
  }

  function onBtnEnd(ev) {
    if (ev.type == 'touchend') {
      // Prevents iOS scroll on double tap
      ev.preventDefault();
    }

    stop();

    if (ev.type == 'mouseup') {
      $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);
    }
  }

  function stop() {
    running = false;
    clearInterval(timer);

    if ($btn) {
      $btn.removeClass('mbsc-active');

      if (ripple) {
        setTimeout(function () {
          ripple.removeRipple();
        }, 100);
      }
    }
  }

  function start(i, st, ev) {
    if (!running && !check(i)) {
      index = i;
      step = st;
      source = ev;
      running = true;
      changed = false;
      setTimeout(tick, 100);
    }

    return running;
  }

  function tick() {
    if ($btn && $btn.hasClass('mbsc-disabled')) {
      stop();
      return;
    }

    if (running || !changed) {
      changed = true;
      action(index, step, source, tick);
    }

    if (running && delay) {
      clearInterval(timer);
      timer = setInterval(function () {
        action(index, step, source);
      }, delay);
    }
  }

  function destroy() {
    $elm.each(function (i, el) {
      unlisten(el, 'touchstart', onBtnStart, {
        passive: true
      });
      unlisten(el, 'mousedown', onBtnStart);
      unlisten(el, 'keydown', onBtnStart);
      unlisten(el, 'touchmove', onBtnMove, {
        passive: true
      });
      unlisten(el, 'touchend', onBtnEnd);
      unlisten(el, 'touchcancel', onBtnEnd);
      unlisten(el, 'keyup', onBtnEnd);
    });
  }

  $elm.each(function (i, el) {
    listen(el, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(el, 'mousedown', onBtnStart);
    listen(el, 'keydown', onBtnStart);
    listen(el, 'touchmove', onBtnMove, {
      passive: true
    });
    listen(el, 'touchend', onBtnEnd);
    listen(el, 'touchcancel', onBtnEnd);
    listen(el, 'keyup', onBtnEnd);
  });
  return {
    start: start,
    stop: stop,
    destroy: destroy
  };
}

var innerStyle = 'position:absolute;left:0;top:0;';
var style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';
var markup = '<div style="' + style + '"><div style="' + innerStyle + '"></div></div>' + '<div style="' + style + '"><div style="' + innerStyle + 'width:200%;height:200%;"></div></div>';
var observer;
var count = 0;
function resizeObserver(el, callback, zone) {
  function reset() {
    expandChild.style.width = '100000px';
    expandChild.style.height = '100000px';
    expand.scrollLeft = 100000;
    expand.scrollTop = 100000;
    shrink.scrollLeft = 100000;
    shrink.scrollTop = 100000;
  }

  function checkHidden() {
    var now = new Date();
    hiddenRafId = 0;

    if (!stopCheck) {
      if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
        lastCheck = now;
        reset();
      }

      if (!hiddenRafId) {
        hiddenRafId = raf(checkHidden);
      }
    }
  }

  function onScroll() {
    if (!rafId) {
      rafId = raf(onResize);
    }
  }

  function onResize() {
    rafId = 0;
    reset();
    callback();
  }

  var expand;
  var expandChild;
  var helper;
  var hiddenRafId;
  var rafId;
  var shrink;
  var stopCheck;
  var lastCheck = 0; //let isHidden = true;

  if (window.ResizeObserver) {
    if (!observer) {
      observer = new ResizeObserver(function (entries) {
        for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var entry = _ref;

          entry.target.__mbscResize();
        }
      });
    }

    count++;
    el.__mbscResize = callback;
    observer.observe(el);
  } else {
    helper = document.createElement('div');
    helper.innerHTML = markup;
    helper.dir = 'ltr'; // Need this to work in rtl as well;

    shrink = helper.childNodes[1];
    expand = helper.childNodes[0];
    expandChild = expand.childNodes[0];
    el.appendChild(helper);
    expand.addEventListener('scroll', onScroll);
    shrink.addEventListener('scroll', onScroll);

    if (zone) {
      zone.runOutsideAngular(function () {
        raf(checkHidden);
      });
    } else {
      raf(checkHidden);
    }
  }

  return {
    detach: function detach() {
      if (observer) {
        count--;
        observer.unobserve(el);

        if (!count) {
          observer = null;
        }
      } else {
        el.removeChild(helper);
        stopCheck = true;
      }
    }
  };
}

var $activeElm,
    preventShow,
    themes = mobiscroll.themes,
    needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,
    isAndroid = os == 'android',
    isIOS = os == 'ios',
    isIOS8 = isIOS && majorVersion == 8,
    halfBorder = isIOS && majorVersion > 7,
    prevdef = function prevdef(ev) {
  ev.preventDefault();
};

var EDITABLE = 'input,select,textarea,button';
var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
var Frame = function Frame(el, settings, inherit) {
  var //$ariaDiv,
  $ctx,
      $header,
      $lock,
      $markup,
      $overlay,
      $persp,
      $popup,
      $wnd,
      $wrapper,
      buttons,
      btn,
      ctx,
      doAnim,
      hasContext,
      isModal,
      isInserted,
      isPointer,
      markup,
      modalWidth,
      modalHeight,
      needsDimensions,
      needsLock,
      observer,
      overlay,
      popup,
      posDebounce,
      prevInst,
      s,
      scrollLock,
      touched,
      trigger,
      wndWidth,
      wndHeight,
      that = this,
      $elm = $$1(el),
      elmList = [],
      lastFocus = new Date();

  function onBtnStart(ev) {
    // Need this to prevent opening of sidemenus or similar
    if (s.stopProp) {
      ev.stopPropagation();
    }

    var b = closest(this, ev.target, '.mbsc-fr-btn-e');

    if (!b) {
      return;
    } // Can't call preventDefault here, it kills page scroll


    if (btn) {
      btn.removeClass('mbsc-active');
    }

    btn = $$1(b); // Active button

    if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {
      btn.addClass('mbsc-active');
    }

    if (ev.type === 'mousedown') {
      $$1(document).on('mouseup', onBtnEnd);
    }
  }

  function onBtnEnd(ev) {
    if (btn) {
      btn.removeClass('mbsc-active');
      btn = null;
    }

    if (ev.type === 'mouseup') {
      $$1(document).off('mouseup', onBtnEnd);
    }
  }

  function onScroll(ev) {
    if (scrollLock && markup.contains(ev.target)) {
      ev.preventDefault();
    }
  }

  function onWndKeyDown(ev) {
    if (mobiscroll.activeInstance == that) {
      if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {
        that.select();
      } else if (ev.keyCode == 27) {
        that.cancel();
      }
    }
  }

  function onShow(prevFocus) {
    if (!prevFocus && !isAndroid && that._activeElm) {
      //overlay.focus();
      lastFocus = new Date();

      that._activeElm.focus();
    } //that.ariaMessage(s.ariaMessage);

  }

  function onHide(prevAnim) {
    var $activeEl = $activeElm,
        focus = s.focusOnClose;

    that._markupRemove();

    $markup.remove();

    if (isModal) {
      ctx.mbscModals--;

      if (s.scrollLock) {
        ctx.mbscLock--;
      }

      if (!ctx.mbscLock) {
        $lock.removeClass('mbsc-fr-lock');
      }

      if (needsLock) {
        ctx.mbscIOSLock--;

        if (!ctx.mbscIOSLock) {
          $lock.removeClass('mbsc-fr-lock-ios');
          $ctx.css({
            top: '',
            left: ''
          });
          $wnd.scrollLeft(ctx.mbscScrollLeft);
          $wnd.scrollTop(ctx.mbscScrollTop);
        }
      } // The follwing should be done only if no other
      // instance was opened during the hide animation


      if (!ctx.mbscModals) {
        $lock.removeClass('mbsc-fr-lock-ctx');
      }

      if (!ctx.mbscModals || prevInst) {
        // Put focus back to the last active element
        if (!prevAnim) {
          if (!$activeEl) {
            $activeEl = $elm;
          }

          setTimeout(function () {
            if (focus === undefined || focus === true) {
              preventShow = true;
              $activeEl[0].focus();
            } else if (focus) {
              $$1(focus)[0].focus();
            }
          }, 200);
        }
      }
    }

    prevInst = undefined;
    isInserted = false;
    trigger('onHide');
  }

  function onPosition() {
    clearTimeout(posDebounce);
    posDebounce = setTimeout(function () {
      if (that.position(true)) {
        // Trigger reflow, needed on iOS safari, when orientation is changed
        popup.style.visibility = 'hidden';
        popup.offsetHeight;
        popup.style.visibility = '';
      }
    }, 200);
  }

  function onFocus(ev) {
    if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {
      lastFocus = new Date();

      that._activeElm.focus();
    }
  }

  function insertMarkup(prevAnim, prevFocus) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);
      onShow(prevFocus);
    }

    function onOverlayStart(ev) {
      if (!target && ev.target == overlay) {
        target = true;
        moved = false;
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
      }
    }

    function onOverlayMove(ev) {
      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {
        moved = true;
      }
    } // Might be not visible if immediately hidden


    if (!that._isVisible) {
      return;
    } // Show


    if (isModal) {
      $markup.appendTo($ctx);
    } else if ($elm.is('div') && !that._hasContent) {
      // Insert inside the element on which was initialized
      $elm.empty().append($markup);
    } else {
      // Insert after the element
      if ($elm.hasClass('mbsc-control')) {
        var $wrap = $elm.closest('.mbsc-control-w');
        $markup.insertAfter($wrap);

        if ($wrap.hasClass('mbsc-select')) {
          $wrap.addClass('mbsc-select-inline');
        }
      } else {
        $markup.insertAfter($elm);
      }
    }

    isInserted = true;

    that._markupInserted($markup);

    trigger('onMarkupInserted', {
      target: markup
    });

    if (isModal && s.closeOnOverlayTap) {
      var moved, target, startX, startY;
      listen(overlay, 'touchstart', onOverlayStart, {
        passive: true
      });
      listen(overlay, 'touchmove', onOverlayMove, {
        passive: true
      });
      $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {
        target = false;
      }).on('touchend click', function (ev) {
        if (target && !moved) {
          that.cancel();

          if (ev.type == 'touchend') {
            preventClick();
          }
        }

        target = false;
      });
    }

    $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {
      if (ev.keyCode == 32) {
        // Space
        ev.preventDefault();
        ev.stopPropagation();
        this.click();
      }
    }).on('keydown', function (ev) {
      // Trap focus inside modal
      if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {
        // Prevent page scroll on space press
        ev.preventDefault();
      } else if (ev.keyCode == 9 && isModal && s.focusTrap) {
        // Tab
        var $focusable = $markup.find(FOCUSABLE).filter(function () {
          return this.offsetWidth > 0 || this.offsetHeight > 0;
        }),
            index = $focusable.index($$1(':focus', $markup)),
            i = $focusable.length - 1,
            target = 0;

        if (ev.shiftKey) {
          i = 0;
          target = -1;
        }

        if (index === i) {
          $focusable.eq(target)[0].focus();
          ev.preventDefault();
        }
      }
    }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);
    listen(markup, 'touchstart', onBtnStart, {
      passive: true
    });
    listen(markup, 'mousedown', onBtnStart); // Need event capture for this

    listen(markup, 'touchstart', function () {
      if (!touched) {
        touched = true;
        $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');
      }
    }, {
      passive: true,
      capture: true
    }); // Init buttons

    $$1.each(buttons, function (i, b) {
      that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {
        b = isString(b) ? that.buttons[b] : b;
        (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);
      }, true);
    });

    that._attachEvents($markup); // Set position


    if (that.position() === false) {
      return;
    }

    if (isModal || that._checkSize) {
      observer = resizeObserver(markup, onPosition, s.zone);
    }

    if (isModal) {
      $markup.removeClass('mbsc-fr-pos');

      if (doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onShow(prevFocus);
      }
    }

    trigger('onShow', {
      target: markup,
      valueText: that._tempValue
    });
  }

  function show(beforeShow, $elm) {
    if (that._isVisible) {
      return;
    }

    if (beforeShow) {
      beforeShow();
    }

    if (that.show() !== false) {
      $activeElm = $elm;
    }
  }

  function set() {
    that._fillValue();

    trigger('onSet', {
      valueText: that._value
    });
  }

  function cancel() {
    trigger('onCancel', {
      valueText: that._value
    });
  }

  function clear() {
    that.setVal(null, true);
  } // Call the parent constructor


  Base.call(this, el, settings, true);
  /**
   * Positions the scroller on the screen.
   */

  that.position = function (check) {
    var anchor,
        anchorWidth,
        anchorHeight,
        anchorPos,
        anchorTop,
        anchorLeft,
        arrow,
        arrowWidth,
        arrowHeight,
        docHeight,
        docWidth,
        isWrapped,
        newHeight,
        newWidth,
        oldHeight,
        oldWidth,
        width,
        top,
        left,
        css = {},
        scrollLeft = 0,
        scrollTop = 0,
        minWidth = 0,
        totalWidth = 0;

    if (!isInserted) {
      return false;
    }

    oldWidth = wndWidth;
    oldHeight = wndHeight;
    newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);
    newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);

    if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {
      return;
    }

    if (that._checkResp(newWidth)) {
      return false;
    }

    wndWidth = newWidth;
    wndHeight = newHeight;

    if (that._isFullScreen || /top|bottom/.test(s.display)) {
      // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)
      $popup.width(newWidth);
    } else if (isModal) {
      // Reset width
      $wrapper.width('');
    }

    that._position($markup); // Call position for nested mobiscroll components
    // $('.mbsc-comp', $markup).each(function () {
    //     var inst = instances[this.id];
    //     if (inst && inst !== that && inst.position) {
    //         inst.position();
    //     }
    // });


    if (!that._isFullScreen && /center|bubble/.test(s.display)) {
      $$1('.mbsc-w-p', $markup).each(function () {
        // Need fractional values here, so offsetWidth is not ok
        width = this.getBoundingClientRect().width;
        totalWidth += width;
        minWidth = width > minWidth ? width : minWidth;
      });
      isWrapped = totalWidth > newWidth - 16 || s.tabs === true;
      $wrapper.css({
        'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),
        'white-space': isWrapped ? '' : 'nowrap'
      });
    }

    if (trigger('onPosition', {
      target: markup,
      popup: popup,
      hasTabs: isWrapped,
      oldWidth: oldWidth,
      oldHeight: oldHeight,
      windowWidth: newWidth,
      windowHeight: newHeight
    }) === false || !isModal) {
      return;
    }

    if (needsDimensions) {
      scrollLeft = $wnd.scrollLeft();
      scrollTop = $wnd.scrollTop();

      if (wndWidth) {
        $persp.css({
          width: '',
          height: ''
        });
      }
    }

    modalWidth = popup.offsetWidth;
    modalHeight = popup.offsetHeight;
    scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;

    if (s.display == 'center') {
      left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);
      top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);
    } else if (s.display == 'bubble') {
      anchor = s.anchor === undefined ? $elm : $$1(s.anchor);
      arrow = $$1('.mbsc-fr-arr-i', $markup)[0];
      anchorPos = anchor.offset();
      anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);
      anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);
      anchorWidth = anchor[0].offsetWidth;
      anchorHeight = anchor[0].offsetHeight;
      arrowWidth = arrow.offsetWidth;
      arrowHeight = arrow.offsetHeight; // Horizontal positioning

      left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning
      // Below the input

      top = anchorTop + anchorHeight + arrowHeight / 2;

      if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {
        $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input

        top = anchorTop - modalHeight - arrowHeight / 2;
      } else {
        $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');
      } // Set arrow position


      $$1('.mbsc-fr-arr', $markup).css({
        left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)
      }); // Lock scroll only if popup is entirely in the viewport

      scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;
    } else {
      left = scrollLeft;
      top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);
    }

    if (needsDimensions) {
      // If top + modal height > doc height, increase doc height
      docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());
      docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());
      $persp.css({
        width: docWidth,
        height: docHeight
      }); // Check if scroll needed

      if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {
        $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));
      }
    }

    css.top = Math.floor(top);
    css.left = Math.floor(left);
    $popup.css(css);
    return true;
  };
  /**
   * Show mobiscroll on focus and click event of the parameter.
   * @param {HTMLElement} elm - Events will be attached to this element.
   * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.
   */


  that.attachShow = function (elm, beforeShow) {
    var $label,
        $elm = $$1(elm).off('.mbsc'),
        readOnly = $elm.prop('readonly');
    tapOff($elm);

    if (s.display !== 'inline') {
      if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {
        $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {
          // Prevent input to get focus on tap (virtual keyboard pops up on some devices)
          ev.preventDefault();
        }).on('focus.mbsc', function () {
          if (that._isVisible) {
            // Don't allow input focus if mobiscroll is being opened
            this.blur();
          }
        });
        $label = $$1('label[for="' + $elm.attr('id') + '"]');

        if (!$label.length) {
          $label = $elm.closest('label');
        }
      }

      if (!$elm.is('select')) {
        if (s.showOnFocus) {
          $elm.on('focus.mbsc', function () {
            if (!preventShow) {
              show(beforeShow, $elm);
            } else {
              preventShow = false;
            }
          });
        }

        if (s.showOnTap) {
          $elm.on('keydown.mbsc', function (ev) {
            if (ev.keyCode == 32 || ev.keyCode == 13) {
              // Space or Enter
              ev.preventDefault();
              ev.stopPropagation();
              show(beforeShow, $elm);
            }
          });
          that.tap($elm, function (ev) {
            if (ev.isMbscTap) {
              touched = true;
            }

            show(beforeShow, $elm);
          });

          if ($label && $label.length) {
            that.tap($label, function (ev) {
              ev.preventDefault();

              if (ev.target !== $elm[0]) {
                show(beforeShow, $elm);
              }
            });
          }
        }
      }

      elmList.push({
        readOnly: readOnly,
        el: $elm,
        lbl: $label
      });
    }
  };
  /**
   * Set button handler.
   */


  that.select = function () {
    if (isModal) {
      that.hide(false, 'set', false, set);
    } else {
      set();
    }
  };
  /**
   * Cancel and hide the scroller instance.
   */


  that.cancel = function () {
    if (isModal) {
      that.hide(false, 'cancel', false, cancel);
    } else {
      cancel();
    }
  };
  /**
   * Clear button handler.
   */


  that.clear = function () {
    that._clearValue();

    trigger('onClear');

    if (isModal && that._isVisible && !that.live) {
      that.hide(false, 'clear', false, clear);
    } else {
      clear();
    }
  };
  /**
   * Enables the scroller and the associated input.
   */


  that.enable = function () {
    s.disabled = false;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = false;
      }
    });
  };
  /**
   * Disables the scroller and the associated input.
   */


  that.disable = function () {
    s.disabled = true;
    $$1.each(elmList, function (i, v) {
      if (v.el.is('input,select')) {
        v.el[0].disabled = true;
      }
    });
  };
  /**
   * Shows the scroller instance.
   * @param {Boolean} prevAnim - Prevent animation if true
   * @param {Boolean} prevFocus - Prevent focusing if true
   */


  that.show = function (prevAnim, prevFocus) {
    var hasButtons, html, scrollLeft, scrollTop;

    if (s.disabled || that._isVisible) {
      return;
    } // Parse value from input


    that._readValue();

    if (trigger('onBeforeShow') === false) {
      return false;
    }

    $activeElm = null;
    doAnim = s.animate;
    buttons = s.buttons || [];
    needsDimensions = hasContext || s.display == 'bubble';
    needsLock = needsFixed && !needsDimensions && s.scrollLock;
    hasButtons = buttons.length > 0; //touched = false;

    if (doAnim !== false) {
      if (s.display == 'top') {
        doAnim = doAnim || 'slidedown';
      } else if (s.display == 'bottom') {
        doAnim = doAnim || 'slideup';
      } else if (s.display == 'center' || s.display == 'bubble') {
        doAnim = doAnim || 'pop';
      }
    }

    if (isModal) {
      wndWidth = 0;
      wndHeight = 0;

      if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {
        //$lock.scrollTop(0);
        ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());
        ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());
        $ctx.css({
          top: -scrollTop + 'px',
          left: -scrollLeft + 'px'
        });
      }

      $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard

      if ($$1(document.activeElement).is('input,textarea')) {
        document.activeElement.blur();
      } // Save active instance to previous


      prevInst = mobiscroll.activeInstance; // Set active instance

      mobiscroll.activeInstance = that; // Keep track of modals opened per context

      ctx.mbscModals = (ctx.mbscModals || 0) + 1;

      if (needsLock) {
        ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;
      }

      if (s.scrollLock) {
        ctx.mbscLock = (ctx.mbscLock || 0) + 1;
      }
    } // Create wheels containers


    html = '<div lang="' + s.lang + '" class="mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '">' + (isModal ? '<div class="mbsc-fr-persp">' + (s.showOverlay ? '<div class="mbsc-fr-overlay"></div>' : '') + // Overlay
    '<div role="dialog" class="mbsc-fr-scroll">' : '') + '<div class="mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '">' + ( // Popup
    s.display === 'bubble' ? '<div class="mbsc-fr-arr-w"><div class="mbsc-fr-arr-i"><div class="mbsc-fr-arr"></div></div></div>' : '') + ( // Bubble arrow
    isModal ? '<div class="mbsc-fr-focus" tabindex="-1"></div>' : '') + '<div class="mbsc-fr-w">' + ( // Popup content
    //'<div aria-live="assertive" class="mbsc-fr-aria mbsc-fr-hdn"></div>' +
    s.headerText ? '<div class="mbsc-fr-hdr">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header
    '<div class="mbsc-fr-c">'; // Wheel group container

    html += that._generateContent();
    html += '</div>';

    if (hasButtons) {
      var b,
          i,
          j,
          l = buttons.length;
      html += '<div class="mbsc-fr-btn-cont">';

      for (i = 0; i < buttons.length; i++) {
        j = s.btnReverse ? l - i - 1 : i;
        b = buttons[j];
        b = isString(b) ? that.buttons[b] : b;

        if (b.handler === 'set') {
          b.parentClass = 'mbsc-fr-btn-s';
        }

        if (b.handler === 'cancel') {
          b.parentClass = 'mbsc-fr-btn-c';
        }

        html += '<div' + (s.btnWidth ? ' style="width:' + 100 / buttons.length + '%"' : '') + ' class="mbsc-fr-btn-w ' + (b.parentClass || '') + '">' + '<div tabindex="0" role="button" class="mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '">' + (b.text || '') + '</div></div>';
      }

      html += '</div>';
    }

    html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');
    $markup = $$1(html);
    $persp = $$1('.mbsc-fr-persp', $markup);
    $overlay = $$1('.mbsc-fr-scroll', $markup);
    $wrapper = $$1('.mbsc-fr-w', $markup);
    $popup = $$1('.mbsc-fr-popup', $markup);
    $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);

    markup = $markup[0];
    overlay = $overlay[0];
    popup = $popup[0];
    that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];
    that._markup = $markup;
    that._isVisible = true;
    that.markup = markup;

    that._markupReady($markup);

    trigger('onMarkupReady', {
      target: markup
    }); // Attach events

    if (isModal) {
      // Enter / ESC
      $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise

      if (s.scrollLock) {
        listen(document, 'touchmove', onScroll, {
          passive: false
        });
        listen(document, 'mousewheel', onScroll, {
          passive: false
        });
        listen(document, 'wheel', onScroll, {
          passive: false
        });
      }

      if (s.focusTrap) {
        $wnd.on('focusin', onFocus);
      }
    }

    if (isModal) {
      // Wait for the toolbar and addressbar to appear on iOS
      setTimeout(function () {
        insertMarkup(prevAnim, prevFocus);
      }, needsLock ? 100 : 0);
    } else {
      insertMarkup(prevAnim, prevFocus);
    }
  };
  /**
   * Hides the scroller instance.
   */


  that.hide = function (prevAnim, btn, force, callback) {
    function onAnimEnd() {
      $markup.off(animEnd, onAnimEnd);
      onHide(prevAnim);
    } // If onClose handler returns false, prevent hide


    if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {
      valueText: that._tempValue,
      button: btn
    }) === false) {
      return false;
    }

    that._isVisible = false;

    if (observer) {
      observer.detach();
      observer = null;
    }

    if (isModal) {
      if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {
        document.activeElement.blur();
      }

      if (mobiscroll.activeInstance == that) {
        mobiscroll.activeInstance = prevInst;
      }

      $$1(window).off('keydown', onWndKeyDown);
      $wnd.off('focusin', onFocus);
      unlisten(document, 'touchmove', onScroll, {
        passive: false
      });
      unlisten(document, 'mousewheel', onScroll, {
        passive: false
      });
      unlisten(document, 'wheel', onScroll, {
        passive: false
      });
    } // Hide wheels and overlay


    if ($markup) {
      if (isModal && doAnim && !prevAnim) {
        $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);
      } else {
        onHide(prevAnim);
      }

      that._detachEvents($markup);
    }

    if (callback) {
      callback();
    } // For validation


    $elm.trigger('blur');
    trigger('onClose', {
      valueText: that._value
    });
  }; // that.ariaMessage = function (txt) {
  //     $ariaDiv.html('');
  //     setTimeout(function () {
  //         $ariaDiv.html(txt);
  //     }, 100);
  // };

  /**
   * Return true if the scroller is currently visible.
   */


  that.isVisible = function () {
    return that._isVisible;
  }; // Protected functions to override


  that.setVal = noop;
  that.getVal = noop;
  that._generateContent = noop;
  that._attachEvents = noop;
  that._detachEvents = noop;
  that._readValue = noop;
  that._clearValue = noop;
  that._fillValue = noop;
  that._markupReady = noop;
  that._markupInserted = noop;
  that._markupRemove = noop;
  that._position = noop;
  that.__processSettings = noop;
  that.__init = noop;
  that.__destroy = noop; // Generic frame functions

  /**
   * Destroys the mobiscroll instance.
   */

  that._destroy = function () {
    // Force hide without animation
    that.hide(true, false, true);
    $elm.off('.mbsc');
    tapOff($elm); // Remove all events from elements

    $$1.each(elmList, function (i, v) {
      v.el.off('.mbsc').prop('readonly', v.readOnly);
      tapOff(v.el);

      if (v.lbl) {
        v.lbl.off('.mbsc');
        tapOff(v.lbl);
      }
    });

    that.__destroy();
  };

  that._updateHeader = function () {
    var t = s.headerText,
        txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\{value\}/i, that._tempValue) : '';
    $header.html(txt || '&nbsp;');
  };

  that._getRespCont = function () {
    hasContext = s.context != 'body';
    $wnd = $$1(hasContext ? s.context : window);
    return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;
  };

  that._processSettings = function (resp) {
    var b, i;

    that.__processSettings(resp);

    isPointer = !s.touchUi;

    if (isPointer) {
      s.display = resp.display || settings.display || 'bubble';
      s.buttons = resp.buttons || settings.buttons || [];
      s.showOverlay = resp.showOverlay || settings.showOverlay || false;
    } // Add default buttons


    s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default

    s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;
    buttons = s.buttons || [];
    isModal = s.display !== 'inline';
    $ctx = $$1(s.context);
    $lock = hasContext ? $ctx : $$1('body,html');
    ctx = $ctx[0];
    that.live = true; // If no set button is found, live mode is activated

    for (i = 0; i < buttons.length; i++) {
      b = buttons[i];

      if (b == 'ok' || b == 'set' || b.handler == 'set') {
        that.live = false;
      }
    }

    that.buttons.set = {
      text: s.setText,
      icon: s.setIcon,
      handler: 'set'
    };
    that.buttons.cancel = {
      text: s.cancelText,
      icon: s.cancelIcon,
      handler: 'cancel'
    };
    that.buttons.close = {
      text: s.closeText,
      icon: s.closeIcon,
      handler: 'cancel'
    };
    that.buttons.clear = {
      text: s.clearText,
      icon: s.clearIcon,
      handler: 'clear'
    };
    that._isInput = $elm.is('input');
  };
  /**
   * Scroller initialization.
   */


  that._init = function (newSettings) {
    var wasVisible = that._isVisible,
        wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');

    if (wasVisible) {
      that.hide(true, false, true);
    } // Unbind all events (if re-init)


    $elm.off('.mbsc');
    tapOff($elm);

    that.__init(newSettings);

    that._isLiquid = s.layout == 'liquid';

    if (isModal) {
      that._readValue();

      if (!that._hasContent && !s.skipShow) {
        that.attachShow($elm);
      }

      if (wasVisible) {
        that.show(wasReady);
      }
    } else {
      that.show();
    }

    $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {
      if (!that._preventChange) {
        that.setVal($elm.val(), true, false);
      }

      that._preventChange = false;
    });
  };

  that.buttons = {};
  that.handlers = {
    set: that.select,
    cancel: that.cancel,
    clear: that.clear
  };
  that._value = null;
  that._isValid = true;
  that._isVisible = false; // Constructor

  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
};
Frame.prototype._defaults = {
  // Localization
  lang: 'en',
  setText: 'Set',
  selectedText: '{count} selected',
  closeText: 'Close',
  cancelText: 'Cancel',
  clearText: 'Clear',
  // Options
  context: 'body',
  maxPopupWidth: 600,
  disabled: false,
  closeOnOverlayTap: true,
  showOnFocus: isAndroid || isIOS,
  // Needed for ion-input
  showOnTap: true,
  display: 'center',
  scroll: true,
  scrollLock: true,
  showOverlay: true,
  tap: true,
  touchUi: true,
  btnClass: 'mbsc-fr-btn',
  btnWidth: true,
  focusTrap: true,
  focusOnClose: !isIOS8 // Temporary for iOS8

};
classes.Frame = Frame;
themes.frame.mobiscroll = {
  headerText: false,
  btnWidth: false
};
themes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {
  rows: 5,
  showLabel: false,
  selectedLineBorder: 1,
  weekDays: 'min',
  checkIcon: 'ion-ios7-checkmark-empty',
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'
});

if (isBrowser) {
  // Prevent re-show on window focus
  $$1(window).on('focus', function () {
    if ($activeElm) {
      preventShow = true;
    }
  });
}

// eslint-disable-next-line no-unused-vars
var isIOS$1 = os == 'ios';
var ScrollViewBase = function ScrollViewBase(el, settings, inherit) {
  var $btn,
      $scrollbar,
      $scrollbarTrack,
      btnTimer,
      contSize,
      diffX,
      diffY,
      diff,
      dir,
      easing,
      elastic,
      endX,
      endY,
      eventObj,
      isBtn,
      isInfinite,
      maxScroll,
      maxSnapScroll,
      minScroll,
      move,
      moving,
      nativeScroll,
      rafID,
      //rafMoveID,
  rafRunning,
      scrollbar,
      scrollbarHeight,
      scrollbarOffset,
      scrollbarTrack,
      scrolled,
      scrollDebounce,
      scrollSnap,
      scrollTimer,
      snap,
      snapPoints,
      startPos,
      startTime,
      startX,
      startY,
      style,
      target,
      transTimer,
      threshold,
      trigger,
      vertical,
      that = this,
      currPos,
      currSnap = 0,
      currSnapDir = 1,
      s = settings,
      $elm = $$1(el);

  function onStart(ev) {
    trigger('onStart', {
      domEvent: ev
    }); // Better performance if there are tap events on document

    if (s.stopProp) {
      ev.stopPropagation();
    } //if (s.prevDef || ev.type == 'mousedown') {


    if (s.prevDef && ev.type == 'mousedown') {
      // Prevent touch highlight and focus
      ev.preventDefault();
    }

    if (s.readonly || s.lock && moving) {
      return;
    }

    if (testTouch(ev, this) && !move) {
      if ($btn) {
        $btn.removeClass('mbsc-active');
      } // Highlight button


      isBtn = false;

      if (!moving) {
        $btn = $$1(ev.target).closest('.mbsc-btn-e', this);

        if ($btn.length && !$btn.hasClass('mbsc-disabled')) {
          isBtn = true;
          btnTimer = setTimeout(function () {
            $btn.addClass('mbsc-active');
          }, 100);
        }
      }

      move = true;
      scrolled = false;
      nativeScroll = false;
      that.scrolled = moving;
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      endX = startX;
      diffX = 0;
      diffY = 0;
      diff = 0;
      startTime = new Date();
      startPos = +getPosition(target, vertical) || 0; // Stop scrolling animation, 1ms is needed for Android 4.0

      if (moving) {
        scroll(startPos, isIOS$1 ? 0 : 1);
      }

      if (ev.type === 'mousedown') {
        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
      }
    }
  }

  function onMove(ev) {
    if (move) {
      if (s.stopProp) {
        ev.stopPropagation();
      }

      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;
      diff = vertical ? diffY : diffX;

      if (isBtn && (Math.abs(diffY) > s.thresholdY || Math.abs(diffX) > s.thresholdX)) {
        clearTimeout(btnTimer);
        $btn.removeClass('mbsc-active');
        isBtn = false;
      }

      if (that.scrolled || !nativeScroll && Math.abs(diff) > threshold) {
        if (!scrolled) {
          trigger('onGestureStart', eventObj);
        }

        that.scrolled = scrolled = true;

        if (!rafRunning) {
          rafRunning = true;
          rafID = raf(onMoving);
        }
      }

      if (vertical || s.scrollLock) {
        // Always prevent native scroll, if vertical
        ev.preventDefault();
      } else {
        if (that.scrolled) {
          // Prevent native scroll
          ev.preventDefault();
        } else if (Math.abs(diffY) > 7) {
          nativeScroll = true;
          that.scrolled = true;
          onEnd();
        }
      }
    }
  }

  function onMoving() {
    //var time = new Date();
    if (maxSnapScroll) {
      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
    }

    scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic)); //if (s.momentum) {
    //    startTime = time;
    //    lastX = endX;
    //}

    rafRunning = false;
  }

  function onEnd(ev) {
    if (move) {
      var speed,
          time = new Date() - startTime; // Better performance if there are tap events on document

      if (s.stopProp && ev) {
        ev.stopPropagation();
      }

      rafc(rafID);
      rafRunning = false;

      if (!nativeScroll && that.scrolled) {
        // Calculate momentum distance
        if (s.momentum && time < 300) {
          speed = diff / time; //speed = Math.abs(lastX - endX) / time;

          diff = Math.max(Math.abs(diff), speed * speed / s.speedUnit) * (diff < 0 ? -1 : 1);
        }

        finalize(diff);
      }

      if (isBtn) {
        clearTimeout(btnTimer);
        $btn.addClass('mbsc-active');
        setTimeout(function () {
          $btn.removeClass('mbsc-active');
        }, 100);

        if (!nativeScroll && !that.scrolled) {
          trigger('onBtnTap', {
            target: $btn[0],
            domEvent: ev
          });
        }
      } // Detach document events


      if (ev && ev.type == 'mouseup') {
        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
      }

      move = false;
    }
  }

  function onClick(ev) {
    if (that.scrolled) {
      that.scrolled = false;
      ev.stopPropagation();
      ev.preventDefault();
    }
  }

  function onScroll(ev) {
    if (!el.contains(ev.target)) {
      return;
    }

    ev = ev.originalEvent || ev;
    diff = vertical ? ev.deltaY == undefined ? ev.wheelDelta || ev.detail : ev.deltaY : ev.deltaX;
    trigger('onStart', {
      domEvent: ev
    });

    if (s.stopProp) {
      ev.stopPropagation();
    }

    if (diff) {
      ev.preventDefault(); //diff = diff < 0 ? 20 : -20;

      if (ev.deltaMode && ev.deltaMode == 1) {
        diff *= 15;
      }

      diff = constrain(-diff, -scrollSnap, scrollSnap);
      startPos = currPos;

      if (s.readonly) {
        return;
      }

      if (!scrolled) {
        gestureStart();
      }

      if (startPos + diff < minScroll) {
        startPos = minScroll;
        diff = 0;
      }

      if (startPos + diff > maxScroll) {
        startPos = maxScroll;
        diff = 0;
      }

      if (!rafRunning) {
        rafRunning = true;
        rafID = raf(onMoving);
      }

      if (!diff && scrolled) {
        return;
      }

      scrolled = true;
      clearTimeout(scrollDebounce);
      scrollDebounce = setTimeout(function () {
        rafc(rafID);
        rafRunning = false;
        scrolled = false;
        finalize(diff);
      }, 200);
    }
  }

  function onScrollBarStart(ev) {
    trigger('onStart', {
      domEvent: ev
    });

    if (s.readonly) {
      return;
    }

    ev.stopPropagation();
    startPos = currPos;
    scrolled = false;

    if (ev.target == scrollbar) {
      startY = getCoord(ev, 'Y', true);
      $$1(document).on('mousemove', onScrollBarMove).on('mouseup', onScrollBarEnd);
    } else {
      startY = $scrollbar.offset().top;
      onScrollBarMove(ev);
      onScrollBarEnd();
    }
  }

  function onScrollBarMove(ev) {
    var percent = (getCoord(ev, 'Y', true) - startY) / contSize;

    if (isInfinite) {
      diff = -(maxSnapScroll * snap * 2 + contSize) * percent;
      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
    } else {
      diff = (minScroll - maxScroll - contSize) * percent;
    }

    if (!scrolled) {
      gestureStart();
    }

    scrolled = true;
    scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic));
  }

  function onScrollBarEnd() {
    startPos = currPos;
    finalize(0);
    $$1(document).off('mousemove', onScrollBarMove).off('mouseup', onScrollBarEnd);
  }

  function onScrollBarClick(ev) {
    ev.stopPropagation();
  }

  function gestureStart() {
    eventObj = {
      posX: vertical ? 0 : currPos,
      posY: vertical ? currPos : 0,
      originX: vertical ? 0 : startPos,
      originY: vertical ? startPos : 0,
      direction: diff > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
    };
    trigger('onGestureStart', eventObj);
  }

  function finalize(diff) {
    var i, time, newPos; // Limit scroll to snap size

    if (maxSnapScroll) {
      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);
    } // Calculate snap and limit between min and max


    newPos = constrain(Math.round((startPos + diff) / snap) * snap, minScroll, maxScroll); // Snap to nearest element

    if (snapPoints) {
      if (diff < 0) {
        for (i = snapPoints.length - 1; i >= 0; i--) {
          if (Math.abs(newPos) + contSize >= snapPoints[i].breakpoint) {
            currSnap = i;
            currSnapDir = 2;
            newPos = snapPoints[i].snap2;
            break;
          }
        }
      } else if (diff >= 0) {
        for (i = 0; i < snapPoints.length; i++) {
          if (Math.abs(newPos) <= snapPoints[i].breakpoint) {
            currSnap = i;
            currSnapDir = 1;
            newPos = snapPoints[i].snap1;
            break;
          }
        }
      }

      newPos = constrain(newPos, minScroll, maxScroll);
    }

    time = s.time || (currPos < minScroll || currPos > maxScroll ? 1000 : Math.max(1000, Math.abs(newPos - currPos) * s.timeUnit));
    eventObj.destinationX = vertical ? 0 : newPos;
    eventObj.destinationY = vertical ? newPos : 0;
    eventObj.duration = time;
    eventObj.transitionTiming = easing;
    trigger('onGestureEnd', eventObj); // Scroll to the calculated position

    that.scroll(newPos, time);
  }

  function scroll(pos, time, tap, callback) {
    var percent,
        changed = pos != currPos,
        anim = time > 1,
        timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '',
        done = function done() {
      clearInterval(scrollTimer);
      clearTimeout(transTimer); //rafc(rafMoveID);

      moving = false;
      currPos = pos;
      eventObj.posX = vertical ? 0 : pos;
      eventObj.posY = vertical ? pos : 0;

      if (changed) {
        trigger('onMove', eventObj);
      }

      if (anim) {
        //that.scrolled = false;
        trigger('onAnimationEnd', eventObj);
      }

      if (callback) {
        callback();
      }
    };

    eventObj = {
      posX: vertical ? 0 : currPos,
      posY: vertical ? currPos : 0,
      originX: vertical ? 0 : startPos,
      originY: vertical ? startPos : 0,
      direction: pos - currPos > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180
    };
    currPos = pos;

    if (anim) {
      eventObj.destinationX = vertical ? 0 : pos;
      eventObj.destinationY = vertical ? pos : 0;
      eventObj.duration = time;
      eventObj.transitionTiming = easing;
      trigger('onAnimationStart', eventObj);
    }

    style[jsPrefix + 'Transition'] = timing;
    style[jsPrefix + 'Transform'] = 'translate3d(' + (vertical ? '0,' + pos + 'px,' : pos + 'px,' + '0,') + '0)';

    if (scrollbar && scrollbarHeight) {
      percent = isInfinite ? (scrollbarOffset - pos) / (maxSnapScroll * snap * 2) : (pos - maxScroll) / (minScroll - maxScroll);
      scrollbar.style[jsPrefix + 'Transition'] = timing;
      scrollbar.style[jsPrefix + 'Transform'] = 'translate3d(0,' + Math.max(0, Math.min((contSize - scrollbarHeight) * percent, contSize - scrollbarHeight)) + 'px,0)';
    }

    if (!changed && !moving || !time || time <= 1) {
      done();
    } else if (time) {
      moving = !tap;
      clearInterval(scrollTimer);
      scrollTimer = setInterval(function () {
        //rafMoveID = raf(function () {
        var p = +getPosition(target, vertical) || 0;
        eventObj.posX = vertical ? 0 : p;
        eventObj.posY = vertical ? p : 0;
        trigger('onMove', eventObj); // Trigger done if close to the end

        if (Math.abs(p - pos) < 2) {
          done();
        } //});

      }, 100);
      clearTimeout(transTimer);
      transTimer = setTimeout(function () {
        done(); //style[pr + 'Transition'] = '';
      }, time); // target.off(transEnd).on(transEnd, function (e) {
      //     if (e.target === target[0]) {
      //         target.off(transEnd);
      //         style[pr + 'Transition'] = '';
      //         done();
      //     }
      // });
    }

    if (s.sync) {
      s.sync(pos, time, easing);
    }
  } // Call the parent constructor


  Base.call(this, el, settings, true);
  that.scrolled = false;
  /**
   * Scroll to the given position or element
   */

  that.scroll = function (pos, time, tap, callback) {
    // If position is not numeric, scroll to element
    if (!isNumeric(pos)) {
      pos = Math.ceil(($$1(pos, el).length ? Math.round(target.offset()[dir] - $$1(pos, el).offset()[dir]) : currPos) / snap) * snap;
    } else {
      pos = Math.round(pos / snap) * snap;
    }

    pos = constrain(pos, minScroll, maxScroll);
    currSnap = Math.round(pos / snap);
    startPos = currPos;
    scrollbarOffset = maxSnapScroll * snap + pos;
    scroll(pos, time, tap, callback);
  };

  that.refresh = function (noScroll) {
    var tempScroll;
    contSize = (s.contSize === undefined ? vertical ? $elm.height() : $elm.width() : s.contSize) || 0;
    maxScroll = (s.maxScroll === undefined ? 0 : s.maxScroll) || 0;
    minScroll = Math.min(maxScroll, s.minScroll === undefined ? Math.min(0, vertical ? contSize - target.height() : contSize - target.width()) : s.minScroll) || 0;
    snapPoints = null;

    if (!vertical && s.rtl) {
      tempScroll = maxScroll;
      maxScroll = -minScroll;
      minScroll = -tempScroll;
    }

    if (isString(s.snap)) {
      snapPoints = [];
      target.find(s.snap).each(function () {
        var offset = vertical ? this.offsetTop : this.offsetLeft,
            size = vertical ? this.offsetHeight : this.offsetWidth;
        snapPoints.push({
          breakpoint: offset + size / 2,
          snap1: -offset,
          snap2: contSize - offset - size
        });
      });
    }

    snap = isNumeric(s.snap) ? s.snap : 1;
    maxSnapScroll = s.snap ? s.maxSnapScroll : 0;
    easing = s.easing;
    elastic = s.elastic ? isNumeric(s.snap) ? snap : isNumeric(s.elastic) ? s.elastic : 0 : 0; // && s.snap ? snap : 0;

    scrollSnap = snap;

    while (scrollSnap > 44) {
      scrollSnap /= 2;
    }

    scrollSnap = Math.round(44 / scrollSnap) * scrollSnap;

    if (scrollbar) {
      isInfinite = minScroll == -Infinity || maxScroll == Infinity;
      scrollbarHeight = minScroll < maxScroll ? Math.max(20, contSize * contSize / (maxScroll - minScroll + contSize)) : 0;
      scrollbar.style.height = scrollbarHeight + 'px';
      scrollbarTrack.style.height = scrollbarHeight ? '' : 0;
    }

    if (currPos === undefined) {
      currPos = s.initialPos;
      currSnap = Math.round(currPos / snap);
    }

    if (!noScroll) {
      that.scroll(s.snap ? snapPoints && snapPoints[currSnap] ? snapPoints[currSnap]['snap' + currSnapDir] : currSnap * snap : currPos);
    }
  };

  that._processSettings = function () {
    vertical = s.axis == 'Y';
    dir = vertical ? 'top' : 'left';
    target = s.moveElement || $elm.children().eq(0);
    style = target[0].style;
    threshold = vertical ? s.thresholdY : s.thresholdX;

    if (s.scrollbar) {
      $scrollbarTrack = s.scrollbar;
      $scrollbar = $scrollbarTrack.find('.mbsc-sc-bar');
      scrollbar = $scrollbar[0];
      scrollbarTrack = $scrollbarTrack[0];
    }
  };

  that._init = function () {
    that.refresh();
    listen(el, 'mousedown', onStart);
    listen(el, 'touchstart', onStart, {
      passive: true
    });
    listen(el, 'touchend', onEnd);
    listen(el, 'touchcancel', onEnd);
    listen(el, 'click', onClick, true);
    listen(document, 'touchmove', onMove, {
      passive: false
    });

    if (s.mousewheel) {
      listen(document, 'wheel', onScroll, {
        passive: false,
        capture: true
      });
      listen(document, 'mousewheel', onScroll, {
        passive: false,
        capture: true
      });
    }

    if (scrollbar) {
      $scrollbarTrack.on('mousedown', onScrollBarStart).on('click', onScrollBarClick);
    } //el.addEventListener('touchend', function (ev) {
    //    if (scrolled) {
    //        ev.stopPropagation();
    //    }
    //}, true);

  };
  /**
   * Destroy
   */


  that._destroy = function () {
    clearInterval(scrollTimer);
    unlisten(el, 'mousedown', onStart);
    unlisten(el, 'touchstart', onStart, {
      passive: true
    });
    unlisten(el, 'touchend', onEnd);
    unlisten(el, 'touchcancel', onEnd);
    unlisten(el, 'click', onClick, true);
    unlisten(document, 'touchmove', onMove, {
      passive: false
    });
    unlisten(document, 'wheel', onScroll, {
      passive: false,
      capture: true
    });
    unlisten(document, 'mousewheel', onScroll, {
      passive: false,
      capture: true
    });

    if (scrollbar) {
      $scrollbarTrack.off('mousedown', onScrollBarStart).off('click', onScrollBarClick);
    }
  }; // Constructor


  s = that.settings;
  trigger = that.trigger;

  if (!inherit) {
    that.init();
  }
};
ScrollViewBase.prototype = {
  _defaults: {
    speedUnit: 0.0022,
    //timeUnit: 0.8,
    timeUnit: 3,
    initialPos: 0,
    axis: 'Y',
    thresholdX: 10,
    thresholdY: 5,
    //easing: 'ease-out',
    easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
    stopProp: true,
    momentum: true,
    mousewheel: true,
    elastic: true
  }
};

// eslint-disable-next-line no-unused-vars
var presets = {},
    css = isBrowser ? window.CSS : null,
    has3d = css && css.supports && css.supports("(transform-style: preserve-3d)");

function sanitize(str) {
  return (str + '').replace('"', '___');
}
var Scroller = function Scroller(el, settings, inherit) {
  var $markup,
      batchSize3d,
      batchSize = 40,
      animTime = 1000,
      scroll3dAngle,
      scroll3d,
      selectedClass,
      showScrollArrows,
      stepper,
      tempWheelArray,
      itemHeight,
      itemHeight3d,
      isPointer,
      isValidating,
      s,
      trigger,
      lines,
      wheels,
      wheelsMap,
      that = this,
      $elm = $$1(el); // Event handlers

  function onKeyDown(ev) {
    var i = +$$1(this).attr('data-index'),
        handle,
        direction;

    if (ev.keyCode == 38) {
      // Up
      handle = true;
      direction = -1;
    } else if (ev.keyCode == 40) {
      // Down
      handle = true;
      direction = 1;
    } else if (ev.keyCode == 32) {
      // Space
      handle = true;
      onItemTap(i, $$1(ev.target));
    }

    if (handle) {
      ev.stopPropagation();
      ev.preventDefault();

      if (direction) {
        stepper.start(i, direction, ev);
      }
    }
  }

  function onKeyUp() {
    stepper.stop();
  }

  function onItemTap(i, $item) {
    var wheel = wheels[i],
        idx = +$item.attr('data-index'),
        val = getValue(wheel, idx),
        selected = that._tempSelected[i],
        maxSelect = isNumeric(wheel.multiple) ? wheel.multiple : Infinity;

    if (trigger('onItemTap', {
      target: $item[0],
      index: i,
      value: val,
      selected: $item.hasClass('mbsc-sc-itm-sel')
    }) !== false && !that._prevItemTap) {
      // Select item on tap
      if (wheel.multiple && !wheel._disabled[val]) {
        if (selected[val] !== undefined) {
          $item.removeClass(selectedClass).removeAttr('aria-selected');
          delete selected[val];
        } else {
          if (maxSelect == 1) {
            that._tempSelected[i] = selected = {};

            wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
          }

          if (objectToArray(selected).length < maxSelect) {
            $item.addClass(selectedClass).attr('aria-selected', 'true');
            selected[val] = val;
          }
        }
      }

      setWheelValue(wheel, i, idx, animTime, wheel._index < idx ? 1 : 2, true, wheel.multiple);

      if (that.live && (!wheel.multiple || wheel.multiple === 1 && s.tapSelect) && (s.setOnTap === true || s.setOnTap[i])) {
        setTimeout(function () {
          that.select();
        }, s.tapSelect ? 0 : 200);
      }
    }

    that._prevItemTap = false;
  } // Private functions


  function shouldSet(i, noscroll) {
    var wheel = wheels[i];
    return wheel && (!wheel.multiple || wheel.multiple !== 1 && noscroll && (s.setOnTap === true || s.setOnTap[i]));
  }

  function getMin(wheel) {
    return -(wheel.max - wheel._offset - (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;
  }

  function getMax(wheel) {
    return -(wheel.min - wheel._offset + (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;
  }

  function getIndex(wheel, val) {
    return (wheel._array ? wheel._map[val] : +wheel.getIndex(val, that)) || 0;
  }

  function getItem(wheel, i) {
    var data = wheel.data;

    if (i >= wheel.min && i <= wheel.max) {
      return wheel._array ? wheel.circular ? $$1(data).get(i % wheel._length) : data[i] : $$1.isFunction(data) ? data(i, that) : '';
    }
  }

  function getItemValue(item) {
    return $$1.isPlainObject(item) ? item.value !== undefined ? item.value : item.display : item;
  }

  function getItemText(item) {
    var text = $$1.isPlainObject(item) ? item.display : item;
    return text === undefined ? '' : text;
  }

  function getValue(wheel, i) {
    return getItemValue(getItem(wheel, i));
  }

  function step(index, direction, ev) {
    var wheel = wheels[index];
    setWheelValue(wheel, index, wheel._index + direction, s.delay + 100, direction == 1 ? 1 : 2, false, false, ev.type == 'keydown');
  }

  function isReadOnly(i) {
    return $$1.isArray(s.readonly) ? s.readonly[i] : s.readonly;
  }

  function initWheel(ww, l, keep) {
    // Create a copy of the wheel, in case if same option object is used for multiple scroller instances
    var w = extend$1(wheels[l] || {}, ww);
    var index = w._index - w._batch;
    w.data = w.data || [];
    w.key = w.key !== undefined ? w.key : l;
    w.label = w.label !== undefined ? w.label : l;
    w._map = {};
    w._array = $$1.isArray(w.data); // Map keys to index

    if (w._array) {
      w._length = w.data.length;
      $$1.each(w.data, function (i, v) {
        w._map[getItemValue(v)] = i;
      });
    }

    w.circular = s.circular === undefined ? w.circular === undefined ? w._array && w._length > s.rows : w.circular : $$1.isArray(s.circular) ? s.circular[l] : s.circular;
    w.min = w._array ? w.circular ? -Infinity : 0 : w.min === undefined ? -Infinity : w.min;
    w.max = w._array ? w.circular ? Infinity : w._length - 1 : w.max === undefined ? Infinity : w.max;
    w._nr = l;
    w._index = getIndex(w, tempWheelArray[l]);
    w._disabled = {};
    w._batch = 0;
    w._current = w._index;
    w._first = w._index - batchSize; //Math.max(w.min, w._current - batchSize);

    w._last = w._index + batchSize; //Math.min(w.max, w._first + 2 * batchSize);

    w._offset = w._first;

    if (keep) {
      w._offset -= w._margin / itemHeight + (w._index - index);
      w._margin += (w._index - index) * itemHeight;
    } else {
      w._margin = 0; //w._first * itemHeight;
    }

    w._refresh = function (noScroll) {
      extend$1(w._scroller.settings, {
        minScroll: getMin(w),
        maxScroll: getMax(w)
      });

      w._scroller.refresh(noScroll);
    };

    wheelsMap[w.key] = w;
    return w;
  }

  function generateItems(wheel, index, start, end, is3d) {
    var i,
        css,
        item,
        value,
        text,
        lbl,
        invalid,
        selected,
        html = '',
        checked = that._tempSelected[index],
        disabled = wheel._disabled || {};

    for (i = start; i <= end; i++) {
      item = getItem(wheel, i);
      text = getItemText(item);
      value = getItemValue(item);
      css = item && item.cssClass !== undefined ? item.cssClass : '';
      lbl = item && item.label !== undefined ? item.label : '';
      invalid = item && item.invalid;
      selected = value !== undefined && value == tempWheelArray[index] && !wheel.multiple; // TODO: don't generate items with no value (use margin or placeholder instead)

      html += '<div role="option" tabindex="-1" aria-selected="' + (checked[value] ? true : false) + '" class="mbsc-sc-itm ' + (is3d ? 'mbsc-sc-itm-3d ' : '') + css + ' ' + (selected ? 'mbsc-sc-itm-sel ' : '') + (checked[value] ? selectedClass : '') + (value === undefined ? ' mbsc-sc-itm-ph' : ' mbsc-btn-e') + (invalid ? ' mbsc-sc-itm-inv-h mbsc-disabled' : '') + (disabled[value] ? ' mbsc-sc-itm-inv mbsc-disabled' : '') + '" data-index="' + i + '" data-val="' + sanitize(value) + '"' + (lbl ? ' aria-label="' + lbl + '"' : '') + (selected ? ' aria-selected="true"' : '') + ' style="height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;' + (is3d ? cssPrefix + 'transform:rotateX(' + (wheel._offset - i) * scroll3dAngle % 360 + 'deg) translateZ(' + itemHeight * s.rows / 2 + 'px);' : '') + '">' + (lines > 1 ? '<div class="mbsc-sc-itm-ml" style="line-height:' + Math.round(itemHeight / lines) + 'px;font-size:' + Math.round(itemHeight / lines * 0.8) + 'px;">' : '') + text + (lines > 1 ? '</div>' : '') + '</div>';
    }

    return html;
  }

  function infinite(wheel, i, pos) {
    var index = Math.round(-pos / itemHeight) + wheel._offset,
        diff = index - wheel._current,
        first = wheel._first,
        last = wheel._last,
        first3d = first + batchSize - batchSize3d + 1,
        last3d = last - batchSize + batchSize3d;

    if (diff) {
      wheel._first += diff;
      wheel._last += diff;
      wheel._current = index; // Generate items
      //setTimeout(function () {

      if (diff > 0) {
        wheel._$scroller.append(generateItems(wheel, i, Math.max(last + 1, first + diff), last + diff));

        $$1('.mbsc-sc-itm', wheel._$scroller).slice(0, Math.min(diff, last - first + 1)).remove(); // 3D

        if (scroll3d) {
          wheel._$3d.append(generateItems(wheel, i, Math.max(last3d + 1, first3d + diff), last3d + diff, true));

          $$1('.mbsc-sc-itm', wheel._$3d).slice(0, Math.min(diff, last3d - first3d + 1)).attr('class', 'mbsc-sc-itm-del');
        }
      } else if (diff < 0) {
        wheel._$scroller.prepend(generateItems(wheel, i, first + diff, Math.min(first - 1, last + diff)));

        $$1('.mbsc-sc-itm', wheel._$scroller).slice(Math.max(diff, first - last - 1)).remove(); // 3D

        if (scroll3d) {
          wheel._$3d.prepend(generateItems(wheel, i, first3d + diff, Math.min(first3d - 1, last3d + diff), true));

          $$1('.mbsc-sc-itm', wheel._$3d).slice(Math.max(diff, first3d - last3d - 1)).attr('class', 'mbsc-sc-itm-del');
        }
      }

      wheel._margin += diff * itemHeight;

      wheel._$scroller.css('margin-top', wheel._margin + 'px'); //}, 10);

    }
  }

  function getValid(index, v, dir, dis) {
    var counter,
        wheel = wheels[index],
        disabled = dis || wheel._disabled,
        idx = getIndex(wheel, v),
        val = getValue(wheel, idx),
        v1 = val,
        v2 = val,
        dist1 = 0,
        dist2 = 0; // TODO: what if all items are invalid

    if (disabled[val] === true) {
      counter = 0;

      while (idx - dist1 >= wheel.min && disabled[v1] && counter < 100) {
        counter++;
        dist1++;
        v1 = getValue(wheel, idx - dist1);
      }

      counter = 0;

      while (idx + dist2 < wheel.max && disabled[v2] && counter < 100) {
        counter++;
        dist2++;
        v2 = getValue(wheel, idx + dist2);
      } // If we have direction (+/- or mouse wheel), the distance does not count


      if ((dist2 < dist1 && dist2 && dir !== 2 || !dist1 || idx - dist1 < 0 || dir == 1) && !disabled[v2]) {
        val = v2;
      } else {
        val = v1;
      }
    }

    return val;
  }

  function scrollToPos(time, index, dir, manual, tap, noscroll, shouldFocus) {
    var diff,
        idx,
        offset,
        ret,
        isVisible = that._isVisible;
    isValidating = true;
    ret = s.validate.call(el, {
      values: tempWheelArray.slice(0),
      index: index,
      direction: dir
    }, that) || {};
    isValidating = false;

    if (ret.valid) {
      that._tempWheelArray = tempWheelArray = ret.valid.slice(0);
    }

    if (!noscroll) {
      $$1.each(wheels, function (i, wheel) {
        if (isVisible) {
          // Enable all items
          wheel._$markup.find('.mbsc-sc-itm-inv').removeClass('mbsc-sc-itm-inv mbsc-disabled');
        }

        wheel._disabled = {}; // Disable invalid items

        if (ret.disabled && ret.disabled[i]) {
          $$1.each(ret.disabled[i], function (j, v) {
            wheel._disabled[v] = true;

            if (isVisible) {
              wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(v) + '"]').addClass('mbsc-sc-itm-inv mbsc-disabled');
            }
          });
        } // Get closest valid value


        tempWheelArray[i] = wheel.multiple ? tempWheelArray[i] : getValid(i, tempWheelArray[i], dir);

        if (isVisible) {
          if (!wheel.multiple || index === undefined) {
            wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');
          } // Get index of valid value


          idx = getIndex(wheel, tempWheelArray[i]);
          diff = idx - wheel._index + wheel._batch;

          if (Math.abs(diff) > 2 * batchSize + 1) {
            offset = diff + (2 * batchSize + 1) * (diff > 0 ? -1 : 1);
            wheel._offset += offset;
            wheel._margin -= offset * itemHeight;

            wheel._refresh();
          }

          wheel._index = idx + wheel._batch;

          if (wheel.multiple) {
            // Add selected styling to selected elements in case of multiselect
            if (index === undefined) {
              for (var v in that._tempSelected[i]) {
                wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(v) + '"]').addClass(selectedClass).attr('aria-selected', 'true');
              }
            }
          } else {
            // Mark element as aria selected
            wheel._$markup.find('.mbsc-sc-itm[data-val="' + sanitize(tempWheelArray[i]) + '"]').addClass('mbsc-sc-itm-sel').attr('aria-selected', 'true');
          }

          if (wheel._$active) {
            wheel._$active.attr('tabindex', -1);
          }

          wheel._$active = wheel._$markup.find('.mbsc-sc-itm[data-index="' + wheel._index + '"]').eq(scroll3d && wheel.multiple ? 1 : 0).attr('tabindex', 0);

          if (shouldFocus && index === i && wheel._$active.length) {
            wheel._$active[0].focus();

            wheel._$scroller.parent().scrollTop(0);
          } // Scroll to valid value


          wheel._scroller.scroll(-(idx - wheel._offset + wheel._batch) * itemHeight, index === i || index === undefined ? time : animTime, tap);
        }
      });
    }

    trigger('onValidated', {
      index: index,
      time: time
    }); // Get formatted value

    that._tempValue = s.formatValue.call(el, tempWheelArray, that);

    if (isVisible) {
      that._updateHeader();
    } // If in live mode, set and fill value on every move


    if (that.live && shouldSet(index, noscroll)) {
      that._hasValue = manual || that._hasValue;
      setValue(manual, manual, 0, true);

      if (manual) {
        trigger('onSet', {
          valueText: that._value
        });
      }
    }

    if (manual) {
      trigger('onChange', {
        index: index,
        valueText: that._tempValue
      });
    }
  }

  function setWheelValue(wheel, i, idx, time, dir, tap, noscroll, shouldFocus) {
    // Get the value at the given index
    var value = getValue(wheel, idx);

    if (value !== undefined) {
      tempWheelArray[i] = value; // In case of circular wheels calculate the offset of the current batch

      wheel._batch = wheel._array ? Math.floor(idx / wheel._length) * wheel._length : 0;
      wheel._index = idx;
      setTimeout(function () {
        scrollToPos(time, i, dir, true, tap, noscroll, shouldFocus);
      }, 10);
    }
  }

  function setValue(fill, change, time, noscroll, temp) {
    if (!noscroll) {
      scrollToPos(time);
    } else {
      that._tempValue = s.formatValue.call(el, that._tempWheelArray, that);
    }

    if (!temp) {
      that._wheelArray = [];

      for (var i = 0; i < tempWheelArray.length; i++) {
        // In case of multiple select wheel take the first selected value,
        that._wheelArray[i] = wheels[i] && wheels[i].multiple ? Object.keys(that._tempSelected[i] || {})[0] : tempWheelArray[i];
      }

      that._value = that._hasValue ? that._tempValue : null;
      that._selected = extend$1(true, {}, that._tempSelected);
    }

    if (fill) {
      if (that._isInput) {
        $elm.val(that._hasValue ? that._tempValue : '');
      }

      trigger('onFill', {
        valueText: that._hasValue ? that._tempValue : '',
        change: change
      });

      if (change) {
        that._preventChange = true;
        $elm.trigger('change');
      }
    }
  } // Call the parent constructor


  Frame.call(this, el, settings, true); // Public functions

  /**
   * Sets the value of the scroller.
   * @param {Array} val - New value.
   * @param {Boolean} [fill=false] - Set the value of the associated input element.
   * @param {Boolean} [change=false] - Trigger change on the input element.
   * @param {Boolean} [temp=false] - If true, then only set the temporary value (only scroll there but not set the value).
   * @param {Number} [time=0] - Animation time in milliseconds.
   */

  that.setVal = that._setVal = function (val, fill, change, temp, time) {
    that._hasValue = val !== null && val !== undefined;
    that._tempWheelArray = tempWheelArray = $$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that) || [];
    setValue(fill, change === undefined ? fill : change, time, false, temp);
  };
  /**
   * Returns the selected value.
   */


  that.getVal = that._getVal = function (temp) {
    var val = that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;
    return isNumeric(val) ? +val : val;
  };
  /*
   * Sets the wheel values (passed as an array).
   */


  that.setArrayVal = that.setVal;
  /*
   * Returns the selected wheel values as an array.
   */

  that.getArrayVal = function (temp) {
    return temp ? that._tempWheelArray : that._wheelArray;
  };

  that.changeWheel = function (whls, time, manual) {
    var i, w, ww;
    $$1.each(whls, function (key, wheel) {
      ww = wheelsMap[key]; // Check if wheel exists

      if (ww) {
        i = ww._nr;
        w = initWheel(wheel, i, true);

        if (that._isVisible) {
          if (scroll3d) {
            w._$3d.html(generateItems(w, i, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true));
          }

          w._$scroller.html(generateItems(w, i, w._first, w._last)).css('margin-top', w._margin + 'px');

          w._refresh(isValidating);
        }
      }
    });

    if (that._isVisible && !that._isLiquid && !isValidating) {
      that.position();
    }

    if (!isValidating) {
      scrollToPos(time, undefined, undefined, manual);
    }
  };
  /**
   * Returns the closest valid value.
   */


  that.getValidValue = getValid; // Protected overrides

  that._generateContent = function () {
    var lbl,
        maxPopupWidth = 0,
        html = '',
        style = scroll3d ? cssPrefix + 'transform: translateZ(' + (itemHeight * s.rows / 2 + 3) + 'px);' : '',
        highlight = '<div class="mbsc-sc-whl-l" style="' + style + 'height:' + itemHeight + 'px;margin-top:-' + (itemHeight / 2 + (s.selectedLineBorder || 0)) + 'px;"></div>',
        l = 0;
    $$1.each(s.wheels, function (i, wg) {
      html += '<div class="mbsc-w-p mbsc-sc-whl-gr-c' + (scroll3d ? ' mbsc-sc-whl-gr-3d-c' : '') + (s.showLabel ? ' mbsc-sc-lbl-v' : '') + '">' + highlight + '<div class="mbsc-sc-whl-gr' + (scroll3d ? ' mbsc-sc-whl-gr-3d' : '') + (showScrollArrows ? ' mbsc-sc-cp' : '') + (s.width || s.maxWidth ? '"' : '" style="max-width:' + s.maxPopupWidth + 'px;"') + '>';
      $$1.each(wg, function (j, ww) {
        // Wheels
        that._tempSelected[l] = extend$1({}, that._selected[l]); // TODO: this should be done on initialization, not on show

        var w = initWheel(ww, l);
        wheels[l] = w;
        maxPopupWidth += s.maxWidth ? s.maxWidth[l] || s.maxWidth : s.width ? s.width[l] || s.width : 0;
        lbl = w.label !== undefined ? w.label : j;
        html += '<div class="mbsc-sc-whl-w ' + (w.cssClass || '') + (w.multiple ? ' mbsc-sc-whl-multi' : '') + '" style="' + (s.width ? 'width:' + (s.width[l] || s.width) + 'px;' : (s.minWidth ? 'min-width:' + (s.minWidth[l] || s.minWidth) + 'px;' : '') + (s.maxWidth ? 'max-width:' + (s.maxWidth[l] || s.maxWidth) + 'px;' : '')) + '">' + (isPointer ? '<div class="mbsc-sc-bar-c"><div class="mbsc-sc-bar"></div></div>' : '') + // Scrollbar
        '<div class="mbsc-sc-whl-o" style="' + style + '"></div>' + highlight + '<div aria-live="off" aria-label="' + lbl + '"' + (w.multiple ? ' aria-multiselectable="true"' : '') + ' role="listbox" data-index="' + l + '" class="mbsc-sc-whl"' + ' style="' + 'height:' + s.rows * itemHeight * (scroll3d ? 1.1 : 1) + 'px;">' + (showScrollArrows ? '<div data-index="' + l + '" data-step="1" class="mbsc-sc-btn mbsc-sc-btn-plus ' + (s.btnPlusClass || '') + '"></div>' + // + button
        '<div data-index="' + l + '" data-step="-1" class="mbsc-sc-btn mbsc-sc-btn-minus ' + (s.btnMinusClass || '') + '"></div>' : '') + // - button
        '<div class="mbsc-sc-lbl">' + lbl + '</div>' + // Wheel label
        '<div class="mbsc-sc-whl-c"' + ' style="height:' + itemHeight3d + 'px;margin-top:-' + (itemHeight3d / 2 + 1) + 'px;' + style + '">' + '<div class="mbsc-sc-whl-sc" style="top:' + (itemHeight3d - itemHeight) / 2 + 'px;">'; // Create wheel values

        html += generateItems(w, l, w._first, w._last) + '</div></div>';

        if (scroll3d) {
          html += '<div class="mbsc-sc-whl-3d" style="height:' + itemHeight + 'px;margin-top:-' + itemHeight / 2 + 'px;">';
          html += generateItems(w, l, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true);
          html += '</div>';
        }

        html += '</div></div>';
        l++;
      });
      html += '</div></div>';
    });

    if (maxPopupWidth) {
      s.maxPopupWidth = maxPopupWidth;
    }

    return html;
  };

  that._attachEvents = function ($markup) {
    stepper = createStepper($$1('.mbsc-sc-btn', $markup), step, s.delay, isReadOnly, true);
    $$1('.mbsc-sc-whl', $markup).on('keydown', onKeyDown).on('keyup', onKeyUp);
  };

  that._detachEvents = function () {
    stepper.stop();

    for (var i = 0; i < wheels.length; i++) {
      wheels[i]._scroller.destroy();
    }
  };

  that._markupReady = function ($m) {
    $markup = $m;
    $$1('.mbsc-sc-whl-w', $markup).each(function (i) {
      var idx,
          $wh = $$1(this),
          wheel = wheels[i];
      wheel._$markup = $wh;
      wheel._$scroller = $$1('.mbsc-sc-whl-sc', this);
      wheel._$3d = $$1('.mbsc-sc-whl-3d', this);
      wheel._scroller = new ScrollViewBase(this, {
        mousewheel: s.mousewheel,
        moveElement: wheel._$scroller,
        scrollbar: $$1('.mbsc-sc-bar-c', this),
        initialPos: (wheel._first - wheel._index) * itemHeight,
        contSize: s.rows * itemHeight,
        snap: itemHeight,
        minScroll: getMin(wheel),
        maxScroll: getMax(wheel),
        maxSnapScroll: batchSize,
        prevDef: true,
        stopProp: true,
        timeUnit: 3,
        easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
        sync: function sync(pos, time, easing) {
          var timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '';

          if (scroll3d) {
            wheel._$3d[0].style[jsPrefix + 'Transition'] = timing;
            wheel._$3d[0].style[jsPrefix + 'Transform'] = 'rotateX(' + -pos / itemHeight * scroll3dAngle + 'deg)';
          }
        },
        onStart: function onStart(ev, inst) {
          inst.settings.readonly = isReadOnly(i);
        },
        onGestureStart: function onGestureStart() {
          $wh.addClass('mbsc-sc-whl-a mbsc-sc-whl-anim');
          trigger('onWheelGestureStart', {
            index: i
          });
        },
        onGestureEnd: function onGestureEnd(ev) {
          var dir = ev.direction == 90 ? 1 : 2,
              time = ev.duration,
              pos = ev.destinationY;
          idx = Math.round(-pos / itemHeight) + wheel._offset;
          setWheelValue(wheel, i, idx, time, dir);
        },
        onAnimationStart: function onAnimationStart() {
          $wh.addClass('mbsc-sc-whl-anim');
        },
        onAnimationEnd: function onAnimationEnd() {
          $wh.removeClass('mbsc-sc-whl-a mbsc-sc-whl-anim');
          trigger('onWheelAnimationEnd', {
            index: i
          });

          wheel._$3d.find('.mbsc-sc-itm-del').remove();
        },
        onMove: function onMove(ev) {
          infinite(wheel, i, ev.posY);
        },
        onBtnTap: function onBtnTap(ev) {
          onItemTap(i, $$1(ev.target));
        }
      });
    });
    scrollToPos();
  };

  that._fillValue = function () {
    that._hasValue = true;
    setValue(true, true, 0, true);
  };

  that._clearValue = function () {
    $$1('.mbsc-sc-whl-multi .mbsc-sc-itm-sel', $markup).removeClass(selectedClass).removeAttr('aria-selected');
  };

  that._readValue = function () {
    var v = $elm.val() || '',
        l = 0;

    if (v !== '') {
      that._hasValue = true;
    }

    that._tempWheelArray = tempWheelArray = that._hasValue && that._wheelArray ? that._wheelArray.slice(0) : s.parseValue.call(el, v, that) || [];
    that._tempSelected = extend$1(true, {}, that._selected);
    $$1.each(s.wheels, function (i, wg) {
      $$1.each(wg, function (j, w) {
        // Wheels
        wheels[l] = initWheel(w, l);
        l++;
      });
    });
    setValue(false, false, 0, true);
    trigger('onRead');
  };

  that.__processSettings = function (resp) {
    s = that.settings;
    trigger = that.trigger;
    lines = s.multiline;
    selectedClass = 'mbsc-sc-itm-sel mbsc-ic mbsc-ic-' + s.checkIcon;
    isPointer = !s.touchUi;

    if (isPointer) {
      // Settings that might be needed by the scroller preset as well
      s.tapSelect = true;
      s.circular = false;
      s.rows = resp.rows || settings.rows || 7;
    }
  };

  that.__init = function (newSettings) {
    if (newSettings) {
      // Reset wheel array in case of setting change,
      // since it might affect the number of wheels
      that._wheelArray = null;
    }

    wheels = [];
    wheelsMap = {};
    showScrollArrows = s.showScrollArrows;
    scroll3d = s.scroll3d && has3d && !showScrollArrows && !isPointer && (s.theme == 'ios' || s.baseTheme == 'ios');
    itemHeight = s.height;
    itemHeight3d = scroll3d ? Math.round((itemHeight - (itemHeight * s.rows / 2 + 3) * 0.03) / 2) * 2 : itemHeight;
    batchSize3d = Math.round(s.rows * 1.8);
    scroll3dAngle = 360 / (batchSize3d * 2); // Ensure a minimum number of 3 items if clickpick buttons present

    if (showScrollArrows) {
      s.rows = Math.max(3, s.rows);
    }
  };

  that._getItemValue = getItemValue; // Properties

  that._tempSelected = {};
  that._selected = {}; // Constructor

  if (!inherit) {
    that.init();
  }
}; // Extend defaults

Scroller.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _responsive: true,
  _class: 'scroller',
  _presets: presets,
  _defaults: extend$1({}, Frame.prototype._defaults, {
    // Options
    minWidth: 80,
    height: 40,
    rows: 3,
    multiline: 1,
    delay: 200,
    readonly: false,
    showLabel: true,
    setOnTap: false,
    wheels: [],
    preset: '',
    speedUnit: 0.0012,
    timeUnit: 0.08,
    checkIcon: 'checkmark',
    compClass: 'mbsc-sc',
    validate: function validate() {},
    formatValue: function formatValue(d) {
      return d.join(' ');
    },
    parseValue: function parseValue(value, inst) {
      var val = [],
          ret = [],
          i = 0,
          found,
          data;

      if (value !== null && value !== undefined) {
        val = (value + '').split(' ');
      }

      $$1.each(inst.settings.wheels, function (j, wg) {
        $$1.each(wg, function (k, w) {
          data = w.data; // Default to first wheel value if not found

          found = inst._getItemValue(data[0]);
          $$1.each(data, function (l, item) {
            // Don't do strict comparison
            if (val[i] == inst._getItemValue(item)) {
              found = inst._getItemValue(item);
              return false;
            }
          });
          ret.push(found);
          i++;
        });
      });
      return ret;
    }
  })
};
classes.Scroller = Scroller;

var defaults$1 = {
  separator: ' ',
  // Localization
  dateFormat: 'mm/dd/yy',
  dateDisplay: 'MMddyy',
  timeFormat: 'h:ii A',
  dayText: 'Day',
  monthText: 'Month',
  yearText: 'Year',
  hourText: 'Hours',
  minuteText: 'Minutes',
  ampmText: '&nbsp;',
  secText: 'Seconds',
  nowText: 'Now',
  todayText: 'Today'
}; // --- TRIAL SERVER CODE END ---

var DateTime = function DateTime(inst) {
  function convertRanges(arr) {
    var i,
        v,
        start,
        end,
        ret = [];

    if (arr) {
      for (i = 0; i < arr.length; i++) {
        v = arr[i]; // Check if it's a range, but skip time-only ranges

        if (v.start && v.end && !ISO_8601_TIME.test(v.start)) {
          start = new Date(makeDate(v.start, format, s));
          end = new Date(makeDate(v.end, format, s));

          while (start <= end) {
            ret.push(adjustedDate(start.getFullYear(), start.getMonth(), start.getDate()));
            start.setDate(start.getDate() + 1);
          }
        } else {
          ret.push(v);
        }
      }

      return ret;
    }

    return arr;
  }

  function step(v, st, min, max) {
    return Math.min(max, Math.floor(v / st) * st + min);
  }

  function getMax(step, min, max) {
    return Math.floor((max - min) / step) * step + min;
  }

  function getYear(d) {
    return s.getYear(d);
  }

  function getMonth(d) {
    return s.getMonth(d);
  }

  function getDay(d) {
    return s.getDay(d);
  }

  function getHours(d) {
    var hour = d.getHours();
    hour = hasAmPm && hour >= 12 ? hour - 12 : hour;
    return step(hour, stepHour, minHour, maxHour);
  }

  function getMinutes(d) {
    return step(d.getMinutes(), stepMinute, minMinute, maxMinute);
  }

  function getSeconds(d) {
    return step(d.getSeconds(), stepSecond, minSecond, maxSecond);
  }

  function getMilliseconds(d) {
    return d.getMilliseconds();
  }

  function getAmPm(d) {
    return d.getHours() > 11 ? 1 : 0;
  } // --- TRIAL SERVER CODE START ---


  function getFullDate(d) {
    return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate());
  } // --- TRIAL SERVER CODE END ---


  function getFullTime(d) {
    return step(Math.round((d.getTime() - new Date(d).setHours(0, 0, 0, 0)) / 1000), timeStep || 1, 0, 86400);
  }

  function getArrayPart(data, part, d, def) {
    var ret;

    if (wheelOrder[part] !== undefined) {
      ret = +data[wheelOrder[part]];

      if (!isNaN(ret)) {
        return ret;
      }
    }

    if (d) {
      return getDatePart[part](d);
    }

    if (innerValues[part] !== undefined) {
      return innerValues[part];
    }

    return getDatePart[part](def);
  }

  function getDate(data) {
    var d,
        def = new Date(new Date().setHours(0, 0, 0, 0));

    if (data === null) {
      return data;
    }

    if (wheelOrder.dd !== undefined) {
      d = data[wheelOrder.dd].split('-');
      d = new Date(d[0], d[1] - 1, d[2]);
    }

    if (wheelOrder.tt !== undefined) {
      d = d || def;
      d = new Date(d.getTime() + data[wheelOrder.tt] % 86400 * 1000);
    }

    var year = getArrayPart(data, 'y', d, def),
        month = getArrayPart(data, 'm', d, def),
        day = Math.min(getArrayPart(data, 'd', d, def), s.getMaxDayOfMonth(year, month)),
        hour = getArrayPart(data, 'h', d, def);
    return s.getDate(year, month, day, hasAmPm && getArrayPart(data, 'a', d, def) ? hour + 12 : hour, getArrayPart(data, 'i', d, def), getArrayPart(data, 's', d, def), getArrayPart(data, 'u', d, def));
  }

  function getArray(d, fillInner) {
    var i,
        part,
        parts = ['y', 'm', 'd', 'a', 'h', 'i', 's', 'u', 'dd', 'tt'],
        ret = [];

    if (d === null || d === undefined) {
      return d;
    }

    for (i = 0; i < parts.length; i++) {
      part = parts[i];

      if (wheelOrder[part] !== undefined) {
        ret[wheelOrder[part]] = getDatePart[part](d);
      }

      if (fillInner) {
        innerValues[part] = getDatePart[part](d);
      }
    }

    return ret;
  } // --- TRIAL SERVER CODE START ---


  function getDateIndex(d, hasDay) {
    return hasDay ? // Number of days since 1970-01-01
    Math.floor(new Date(d) / 8.64e7) : // Number of month since 1970-01-01
    d.getMonth() + 12 * (d.getFullYear() - 1970);
  }

  function getYearValue(i) {
    return {
      value: i,
      display: (/yy/i.test(dateDisplay) ? i : (i + '').substr(2, 2)) + (s.yearSuffix || '')
    };
  }

  function getYearIndex(v) {
    return v;
  }

  function getDateWheel(template) {
    var hasDay = /d/i.test(template);
    return {
      label: '',
      cssClass: 'mbsc-dt-whl-date',
      min: minDate ? getDateIndex(getFullDate(minDate), hasDay) : undefined,
      max: maxDate ? getDateIndex(getFullDate(maxDate), hasDay) : undefined,
      data: function data(i) {
        var today = new Date(new Date().setHours(0, 0, 0, 0)),
            d = hasDay ? new Date(i * 8.64e7) : new Date(1970, i, 1);

        if (hasDay) {
          d = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
        }

        return {
          invalid: hasDay && !isValid(d, true),
          value: getFullDate(d),
          display: today.getTime() == d.getTime() ? s.todayText : formatDate(template, d, s)
        };
      },
      getIndex: function getIndex(v) {
        return getDateIndex(v, hasDay);
      }
    };
  }

  function getTimeWheel(template) {
    var i,
        step,
        time,
        values = [];

    if (/s/i.test(template)) {
      step = stepSecond;
    } else if (/i/i.test(template)) {
      step = stepMinute * 60;
    } else if (/h/i.test(template)) {
      step = stepHour * 3600;
    }

    timeStep = steps.tt = step;

    for (i = 0; i < 86400; i += step) {
      time = new Date(new Date().setHours(0, 0, 0, 0) + i * 1000);
      values.push({
        value: i,
        display: formatDate(template, time, s)
      });
    }

    return {
      label: '',
      cssClass: 'mbsc-dt-whl-time',
      data: values
    };
  }

  function getWheels() {
    var dateParts,
        timeParts,
        template,
        i,
        j,
        types,
        values,
        monthStr,
        nr = 0,
        wheels = [],
        dateGroup = [],
        timeGroup = [];

    if (/date/i.test(preset)) {
      dateParts = dateWheels.split(/\|/.test(dateWheels) ? '|' : '');

      for (i = 0; i < dateParts.length; i++) {
        template = dateParts[i];
        types = 0;

        if (template.length) {
          // If contains different characters
          if (/y/i.test(template)) {
            isoParts.y = 1;
            types++;
          }

          if (/m/i.test(template)) {
            isoParts.y = 1;
            isoParts.m = 1;
            types++;
          }

          if (/d/i.test(template)) {
            isoParts.y = 1;
            isoParts.m = 1;
            isoParts.d = 1;
            types++;
          }

          if (types > 1 && wheelOrder.dd === undefined) {
            wheelOrder.dd = nr;
            nr++;
            dateGroup.push(getDateWheel(template));
            timeGroup = dateGroup; // TODO ???

            oneDateWheel = true;
          } else if (/y/i.test(template) && wheelOrder.y === undefined) {
            wheelOrder.y = nr;
            nr++; // Year wheel

            dateGroup.push({
              cssClass: 'mbsc-dt-whl-y',
              label: s.yearText,
              min: minDate ? s.getYear(minDate) : undefined,
              max: maxDate ? s.getYear(maxDate) : undefined,
              data: getYearValue,
              getIndex: getYearIndex
            });
          } else if (/m/i.test(template) && wheelOrder.m === undefined) {
            // Month wheel
            wheelOrder.m = nr;
            values = [];
            nr++;

            for (j = 0; j < 12; j++) {
              monthStr = dateDisplay.replace(/[dy|]/gi, '').replace(/mm/, pad(j + 1) + (s.monthSuffix || '')).replace(/m/, j + 1 + (s.monthSuffix || ''));
              values.push({
                value: j,
                display: /MM/.test(monthStr) ? monthStr.replace(/MM/, '<span class="mbsc-dt-month">' + s.monthNames[j] + '</span>') : monthStr.replace(/M/, '<span class="mbsc-dt-month">' + s.monthNamesShort[j] + '</span>')
              });
            }

            dateGroup.push({
              cssClass: 'mbsc-dt-whl-m',
              label: s.monthText,
              data: values
            });
          } else if (/d/i.test(template) && wheelOrder.d === undefined) {
            // Day wheel
            wheelOrder.d = nr;
            values = [];
            nr++;

            for (j = 1; j < 32; j++) {
              values.push({
                value: j,
                display: (/dd/i.test(dateDisplay) ? pad(j) : j) + (s.daySuffix || '')
              });
            }

            dateGroup.push({
              cssClass: 'mbsc-dt-whl-d',
              label: s.dayText,
              data: values
            });
          }
        }
      }

      wheels.push(dateGroup);
    }

    if (/time/i.test(preset)) {
      timeParts = timeWheels.split(/\|/.test(timeWheels) ? '|' : '');

      for (i = 0; i < timeParts.length; i++) {
        template = timeParts[i];
        types = 0;

        if (template.length) {
          // If contains different characters
          if (/h/i.test(template)) {
            isoParts.h = 1;
            types++;
          }

          if (/i/i.test(template)) {
            isoParts.i = 1;
            types++;
          }

          if (/s/i.test(template)) {
            isoParts.s = 1;
            types++;
          }

          if (/a/i.test(template)) {
            types++;
          }
        }

        if (types > 1 && wheelOrder.tt === undefined) {
          wheelOrder.tt = nr;
          nr++;
          timeGroup.push(getTimeWheel(template));
        } else if (/h/i.test(template) && wheelOrder.h === undefined) {
          // Hours wheel
          values = [];
          wheelOrder.h = nr;
          isoParts.h = 1;
          nr++;

          for (j = minHour; j < (hasAmPm ? 12 : 24); j += stepHour) {
            values.push({
              value: j,
              display: hasAmPm && j === 0 ? 12 : /hh/i.test(timeDisplay) ? pad(j) : j
            });
          }

          timeGroup.push({
            cssClass: 'mbsc-dt-whl-h',
            label: s.hourText,
            data: values
          });
        } else if (/i/i.test(template) && wheelOrder.i === undefined) {
          // Minutes wheel
          values = [];
          wheelOrder.i = nr;
          isoParts.i = 1;
          nr++;

          for (j = minMinute; j < 60; j += stepMinute) {
            values.push({
              value: j,
              display: /ii/i.test(timeDisplay) ? pad(j) : j
            });
          }

          timeGroup.push({
            cssClass: 'mbsc-dt-whl-i',
            label: s.minuteText,
            data: values
          });
        } else if (/s/i.test(template) && wheelOrder.s === undefined) {
          // Seconds wheel
          values = [];
          wheelOrder.s = nr;
          isoParts.s = 1;
          nr++;

          for (j = minSecond; j < 60; j += stepSecond) {
            values.push({
              value: j,
              display: /ss/i.test(timeDisplay) ? pad(j) : j
            });
          }

          timeGroup.push({
            cssClass: 'mbsc-dt-whl-s',
            label: s.secText,
            data: values
          });
        } else if (/a/i.test(template) && wheelOrder.a === undefined) {
          wheelOrder.a = nr;
          nr++;
          timeGroup.push({
            cssClass: 'mbsc-dt-whl-a',
            label: s.ampmText,
            data: /A/.test(template) ? [{
              value: 0,
              display: s.amText.toUpperCase()
            }, {
              value: 1,
              display: s.pmText.toUpperCase()
            }] : [{
              value: 0,
              display: s.amText
            }, {
              value: 1,
              display: s.pmText
            }]
          });
        }
      }

      if (timeGroup != dateGroup) {
        wheels.push(timeGroup);
      }
    }

    return wheels;
  } // --- TRIAL SERVER CODE END ---


  function getHtml5Options($elm) {
    var format,
        min,
        max,
        ret = {}; // Force format for html5 date inputs (experimental)

    if ($elm.is('input')) {
      switch ($elm.attr('type')) {
        case 'date':
          format = 'yy-mm-dd';
          break;

        case 'datetime':
          format = 'yy-mm-ddTHH:ii:ssZ';
          break;

        case 'datetime-local':
          format = 'yy-mm-ddTHH:ii:ss';
          break;

        case 'month':
          format = 'yy-mm';
          ret.dateOrder = 'mmyy';
          break;

        case 'time':
          format = 'HH:ii:ss';
          break;
      }

      ret.format = format; // Check for min/max attributes

      min = $elm.attr('min');
      max = $elm.attr('max');

      if (min && min != 'undefined') {
        ret.min = parseDate(format, min);
      }

      if (max && max != 'undefined') {
        ret.max = parseDate(format, max);
      }
    }

    return ret;
  }

  function getClosestValidDate(d, dir) {
    var next,
        prev,
        nextValid = false,
        prevValid = false,
        up = 0,
        down = 0,
        // Normalize min and max dates for comparing later (set default values where there are no values from wheels)
    mind = minDate ? getDate(getArray(minDate)) : -Infinity,
        maxd = maxDate ? getDate(getArray(maxDate)) : Infinity;

    if (isValid(d)) {
      return d;
    }

    if (d < mind) {
      d = mind;
    }

    if (d > maxd) {
      d = maxd;
    }

    next = d;
    prev = d;

    if (dir !== 2) {
      nextValid = isValid(next, true);

      while (!nextValid && next < maxd && up < 100) {
        next = new Date(next.getTime() + 1000 * 60 * 60 * 24);
        nextValid = isValid(next, true);
        up++;
      }
    }

    if (dir !== 1) {
      prevValid = isValid(prev, true);

      while (!prevValid && prev > mind && down < 100) {
        prev = new Date(prev.getTime() - 1000 * 60 * 60 * 24);
        prevValid = isValid(prev, true);
        down++;
      }
    }

    if (dir === 1 && nextValid) {
      return next;
    }

    if (dir === 2 && prevValid) {
      return prev;
    }

    if (isSameMonth(d, next)) {
      return next;
    }

    if (isSameMonth(d, prev)) {
      return prev;
    }

    return down <= up && prevValid ? prev : next;
  }

  function isSameMonth(d1, d2) {
    return s.getYear(d1) === s.getYear(d2) && s.getMonth(d1) === s.getMonth(d2);
  }

  function isValid(d, skip) {
    if (!skip && d < minDate) {
      return false;
    }

    if (!skip && d > maxDate) {
      return false;
    }

    if (isInObj(d, valid)) {
      return true;
    }

    if (isInObj(d, invalid)) {
      return false;
    }

    return true;
  }

  function isInObj(d, obj) {
    var curr, j, v, val;

    if (obj) {
      for (j = 0; j < obj.length; j++) {
        curr = obj[j];
        val = curr.d || curr;
        v = val + '';

        if (!curr.start) {
          if (DAY_OF_WEEK.test(v)) {
            // Day of week
            v = +v.replace('w', '');

            if (v == d.getDay()) {
              return true;
            }
          } else if (DAY_OF_MONTH.test(v)) {
            // Day of month: '2' or '12/24'
            v = v.split('/');

            if (v[1]) {
              if (v[0] - 1 == d.getMonth() && v[1] == d.getDate()) {
                return true;
              }
            } else if (v[0] == d.getDate()) {
              return true;
            }
          } else {
            // Exact date
            curr = makeDate(val, format, s);

            if (d.getFullYear() == curr.getFullYear() && d.getMonth() == curr.getMonth() && d.getDate() == curr.getDate()) {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  function validateDates(obj, y, m, first, maxdays, invalids, val) {
    var d, dd, j, k, v;

    if (obj) {
      for (j = 0; j < obj.length; j++) {
        d = obj[j];
        dd = d.d || d;
        v = dd + '';

        if (!d.start) {
          if (DAY_OF_WEEK.test(v)) {
            // Day of week
            v = +v.replace('w', '');

            for (k = v - first; k < maxdays; k += 7) {
              if (k >= 0) {
                invalids[k + 1] = val;
              }
            }
          } else if (DAY_OF_MONTH.test(v)) {
            // Day of month: '2' or '12/24'
            v = v.split('/');

            if (v[1]) {
              if (v[0] - 1 == m) {
                invalids[v[1]] = val;
              }
            } else {
              invalids[v[0]] = val;
            }
          } else {
            // Exact date
            d = makeDate(dd, format, s);

            if (s.getYear(d) == y && s.getMonth(d) == m) {
              invalids[s.getDay(d)] = val;
            }
          }
        }
      }
    }
  }

  function validateTimes(vobj, index, v, y, m, d, invalids, valid) {
    var add,
        all,
        dd,
        hours1,
        hours2,
        hours3,
        i,
        i1,
        i2,
        j,
        obj,
        parts1,
        parts2,
        prop1,
        prop2,
        remove,
        ss,
        str,
        v1,
        v2,
        spec = {},
        day = s.getDate(y, m, d),
        w = ['a', 'h', 'i', 's'];

    if (vobj) {
      // Check if rules apply to the selected date
      for (i = 0; i < vobj.length; i++) {
        obj = vobj[i];

        if (obj.start) {
          obj.apply = false;
          dd = obj.d;
          ss = dd + '';
          str = ss.split('/');

          if (dd && (dd.getTime && y == s.getYear(dd) && m == s.getMonth(dd) && d == s.getDay(dd) || // Exact date
          !DAY_OF_WEEK.test(ss) && (str[1] && d == str[1] && m == str[0] - 1 || !str[1] && d == str[0]) || // Day of month
          DAY_OF_WEEK.test(ss) && day.getDay() == +ss.replace('w', '') // Day of week
          )) {
            obj.apply = true;
            spec[day] = true; // Prevent applying generic rule on day, if specific exists
          }
        }
      } // Apply rules


      for (i = 0; i < vobj.length; i++) {
        obj = vobj[i];
        add = 0;
        remove = 0;
        i1 = mins[v];
        i2 = maxs[v];
        prop1 = true;
        prop2 = true;
        all = false;

        if (obj.start && (obj.apply || !obj.d && !spec[day])) {
          // Define time parts
          parts1 = obj.start.split(':');
          parts2 = obj.end.split(':');

          for (j = 0; j < 3; j++) {
            if (parts1[j] === undefined) {
              parts1[j] = 0;
            }

            if (parts2[j] === undefined) {
              parts2[j] = 59;
            }

            parts1[j] = +parts1[j];
            parts2[j] = +parts2[j];
          }

          if (v == 'tt') {
            // Wheel containing full time
            i1 = step(Math.round((new Date(day).setHours(parts1[0], parts1[1], parts1[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);
            i2 = step(Math.round((new Date(day).setHours(parts2[0], parts2[1], parts2[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);
          } else {
            parts1.unshift(parts1[0] > 11 ? 1 : 0);
            parts2.unshift(parts2[0] > 11 ? 1 : 0);

            if (hasAmPm) {
              if (parts1[1] >= 12) {
                parts1[1] = parts1[1] - 12;
              }

              if (parts2[1] >= 12) {
                parts2[1] = parts2[1] - 12;
              }
            } // Look behind


            for (j = 0; j < index; j++) {
              if (validValues[j] !== undefined) {
                v1 = step(parts1[j], steps[w[j]], mins[w[j]], maxs[w[j]]);
                v2 = step(parts2[j], steps[w[j]], mins[w[j]], maxs[w[j]]);
                hours1 = 0;
                hours2 = 0;
                hours3 = 0;

                if (hasAmPm && j == 1) {
                  hours1 = parts1[0] ? 12 : 0;
                  hours2 = parts2[0] ? 12 : 0;
                  hours3 = validValues[0] ? 12 : 0;
                }

                if (!prop1) {
                  v1 = 0;
                }

                if (!prop2) {
                  v2 = maxs[w[j]];
                }

                if ((prop1 || prop2) && v1 + hours1 < validValues[j] + hours3 && validValues[j] + hours3 < v2 + hours2) {
                  all = true;
                }

                if (validValues[j] != v1) {
                  prop1 = false;
                }

                if (validValues[j] != v2) {
                  prop2 = false;
                }
              }
            } // Look ahead


            if (!valid) {
              for (j = index + 1; j < 4; j++) {
                if (parts1[j] > 0) {
                  add = steps[v];
                }

                if (parts2[j] < maxs[w[j]]) {
                  remove = steps[v];
                }
              }
            }

            if (!all) {
              // Calculate min and max values
              v1 = step(parts1[index], steps[v], mins[v], maxs[v]) + add;
              v2 = step(parts2[index], steps[v], mins[v], maxs[v]) - remove;

              if (prop1) {
                i1 = v1;
              }

              if (prop2) {
                i2 = v2;
              }
            }
          } // Disable values


          if (prop1 || prop2 || all) {
            for (j = i1; j <= i2; j += steps[v]) {
              invalids[j] = !valid;
            }
          }
        }
      }
    }
  } // --- TRIAL SERVER CODE START ---


  var timeStep,
      oneDateWheel,
      wheels,
      wheelOrder = {},
      innerValues = {},
      isoParts = {},
      validValues = [],
      html5def = getHtml5Options($$1(this)),
      orig = extend$1({}, inst.settings),
      calendarSystem = calendars[orig.calendarSystem],
      s = extend$1(inst.settings, dateTimeDefaults, calendarSystem, defaults$1, html5def, orig),
      preset = s.preset,
      displayFormat = preset == 'datetime' ? s.dateFormat + s.separator + s.timeFormat : preset == 'time' ? s.timeFormat : s.dateFormat,
      format = html5def.format || displayFormat,
      dateWheels = s.dateWheels || s.dateFormat,
      timeWheels = s.timeWheels || s.timeFormat,
      //dateWheels = '|D M d|', // TODO settings
  //timeWheels = '|h|ii|A|',
  dateDisplay = s.dateWheels || s.dateDisplay,
      timeDisplay = timeWheels,
      baseTheme = s.baseTheme || s.theme,
      invalid = convertRanges(s.invalid),
      valid = convertRanges(s.valid),
      minDate = makeDate(s.min, format, s),
      maxDate = makeDate(s.max, format, s),
      hasTime = /time/i.test(preset),
      hasAmPm = /h/.test(timeDisplay),
      genDayNames = /D/.test(dateDisplay),
      stepParts = s.steps || {},
      stepHour = stepParts.hour || s.stepHour || 1,
      stepMinute = stepParts.minute || s.stepMinute || 1,
      stepSecond = stepParts.second || s.stepSecond || 1,
      zeroBased = stepParts.zeroBased,
      minHour = zeroBased || !minDate ? 0 : minDate.getHours() % stepHour,
      minMinute = zeroBased || !minDate ? 0 : minDate.getMinutes() % stepMinute,
      minSecond = zeroBased || !minDate ? 0 : minDate.getSeconds() % stepSecond,
      maxHour = getMax(stepHour, minHour, hasAmPm ? 11 : 23),
      maxMinute = getMax(stepMinute, minMinute, 59),
      maxSecond = getMax(stepMinute, minMinute, 59),
      mins = {
    y: minDate ? minDate.getFullYear() : -Infinity,
    m: 0,
    d: 1,
    h: minHour,
    i: minMinute,
    s: minSecond,
    a: 0,
    tt: 0
  },
      maxs = {
    y: maxDate ? maxDate.getFullYear() : Infinity,
    m: 11,
    d: 31,
    h: maxHour,
    i: maxMinute,
    s: maxSecond,
    a: 1,
    tt: 86400
  },
      steps = {
    y: 1,
    m: 1,
    d: 1,
    h: stepHour,
    i: stepMinute,
    s: stepSecond,
    a: 1,
    tt: 1
  },
      widths = {
    bootstrap: 46,
    ios: 50,
    material: 46,
    mobiscroll: 46,
    windows: 50
  },
      getDatePart = {
    y: getYear,
    m: getMonth,
    d: getDay,
    h: getHours,
    i: getMinutes,
    s: getSeconds,
    u: getMilliseconds,
    a: getAmPm,
    dd: getFullDate,
    tt: getFullTime
  }; // --- TRIAL SERVER CODE END ---
  // Extended methods
  // ---

  inst.getVal = function (temp) {
    return inst._hasValue || temp ? returnDate(getDate(inst.getArrayVal(temp)), s, format) : null;
  };
  /**
   * Returns the selected date.
   *
   * @param {Boolean} [temp=false] If true, return the currently shown date on the picker, otherwise the last selected one.
   * @return {Date}
   */


  inst.getDate = function (temp) {
    return inst._hasValue || temp ? getDate(inst.getArrayVal(temp)) : null;
  };
  /**
   * Sets the selected date
   *
   * @param {Date} d Date to select.
   * @param {Boolean} [fill=false] Also set the value of the associated input element. Default is true.
   * @param {Number} [time=0] Animation time to scroll to the selected date.
   * @param {Boolean} [temp=false] Set temporary value only.
   * @param {Boolean} [change=fill] Trigger change on input element.
   */


  inst.setDate = function (d, fill, time, temp, change) {
    inst.setArrayVal(getArray(d, true), fill, change, temp, time);
  }; // ---
  // Initializations
  // ---


  wheels = getWheels();
  s.isoParts = isoParts;
  inst._format = displayFormat;
  inst._order = wheelOrder;

  inst.handlers.now = function () {
    inst.setDate(new Date(), inst.live, 1000, true, true);
  };

  inst.buttons.now = {
    text: s.nowText,
    icon: s.nowIcon,
    handler: 'now'
  }; // ---

  return {
    minWidth: oneDateWheel && hasTime ? widths[baseTheme] : undefined,
    compClass: 'mbsc-dt mbsc-sc',
    wheels: wheels,
    headerText: s.headerText ? function () {
      return formatDate(displayFormat, getDate(inst.getArrayVal(true)), s);
    } : false,
    formatValue: function formatValue(d) {
      return formatDate(format, getDate(d), s);
    },
    parseValue: function parseValue(val) {
      if (!val) {
        innerValues = {};
        inst._hasValue = false;
      }

      return getArray(makeDate(val || s.defaultValue || new Date(), format, s, isoParts), !!val);
    },
    validate: function validate(data) {
      var i,
          j,
          dayStr,
          weekDay,
          values = data.values,
          index = data.index,
          dir = data.direction,
          dayWheel = s.wheels[0][wheelOrder.d],
          validated = getClosestValidDate(getDate(values), dir),
          temp = getArray(validated),
          disabled = [],
          wheels = {},
          y = getDatePart.y(validated),
          //get(temp, 'y'),
      m = getDatePart.m(validated),
          //get(temp, 'm'),
      maxdays = s.getMaxDayOfMonth(y, m),
          minprop = true,
          maxprop = true;
      $$1.each(['dd', 'y', 'm', 'd', 'tt', 'a', 'h', 'i', 's'], function (x, i) {
        var min = mins[i],
            max = maxs[i],
            val = getDatePart[i](validated);
        disabled[wheelOrder[i]] = [];

        if (minprop && minDate) {
          min = getDatePart[i](minDate);
        }

        if (maxprop && maxDate) {
          max = getDatePart[i](maxDate);
        }

        if (val < min) {
          val = min;
        }

        if (val > max) {
          val = max;
        }

        if (i !== 'dd' && i !== 'tt') {
          if (minprop) {
            minprop = val == min;
          }

          if (maxprop) {
            maxprop = val == max;
          }
        }

        if (wheelOrder[i] !== undefined) {
          if (i != 'y' && i != 'dd') {
            for (j = mins[i]; j <= maxs[i]; j += steps[i]) {
              if (j < min || j > max) {
                disabled[wheelOrder[i]].push(j);
              }
            }
          } // Disable some days


          if (i == 'd') {
            var first = s.getDate(y, m, 1).getDay(),
                invalids = {}; // Set invalid indexes

            validateDates(invalid, y, m, first, maxdays, invalids, 1); // Delete indexes which are valid

            validateDates(valid, y, m, first, maxdays, invalids, 0);
            $$1.each(invalids, function (j, v) {
              if (v) {
                disabled[wheelOrder[i]].push(j);
              }
            });
          }
        }
      }); // Invalid times

      if (hasTime) {
        $$1.each(['a', 'h', 'i', 's', 'tt'], function (i, v) {
          var val = getDatePart[v](validated),
              d = getDatePart.d(validated),
              invalids = {};

          if (wheelOrder[v] !== undefined) {
            validateTimes(invalid, i, v, y, m, d, invalids, 0);
            validateTimes(valid, i, v, y, m, d, invalids, 1);
            $$1.each(invalids, function (j, x) {
              if (x) {
                disabled[wheelOrder[v]].push(j);
              }
            }); // Get valid value

            validValues[i] = inst.getValidValue(wheelOrder[v], val, dir, invalids);
          }
        });
      } // Regenerate day wheel if number of days in month changes
      // or if day names needs to be regenerated


      if (dayWheel && (dayWheel.data.length !== maxdays || genDayNames && (index === undefined || index === wheelOrder.y || index === wheelOrder.m))) {
        wheels[wheelOrder.d] = dayWheel;
        dayWheel.data = [];

        for (i = 1; i <= maxdays; i++) {
          weekDay = s.getDate(y, m, i).getDay();
          dayStr = dateDisplay.replace(/[my|]/gi, '').replace(/dd/, (i < 10 ? '0' + i : i) + (s.daySuffix || '')).replace(/d/, i + (s.daySuffix || ''));
          dayWheel.data.push({
            value: i,
            display: /DD/.test(dayStr) ? dayStr.replace(/DD/, '<span class="mbsc-dt-day">' + s.dayNames[weekDay] + '</span>') : dayStr.replace(/D/, '<span class="mbsc-dt-day">' + s.dayNamesShort[weekDay] + '</span>')
          });
        } // Need to update day value, if out of month


        inst._tempWheelArray[wheelOrder.d] = temp[wheelOrder.d];
        inst.changeWheel(wheels);
      }

      return {
        disabled: disabled,
        valid: temp
      };
    }
  };
};

var id$1 = 0;

function jsonp(url, callback) {
  var script = document.createElement('script'),
      unique = 'mbscjsonp' + ++id$1;

  window[unique] = function (data) {
    script.parentNode.removeChild(script);
    delete window[unique];

    if (!data) {
      return;
    }

    callback(data);
  };

  script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + unique;
  document.body.appendChild(script);
}

function ajaxGet(url, callback) {
  var request = new XMLHttpRequest();
  request.open('GET', url, true);

  request.onload = function () {
    if (this.status >= 200 && this.status < 400) {
      // Success!
      callback(JSON.parse(this.response));
    } //else {
    // We reached our target server, but it returned an error
    //}

  };

  request.onerror = function () {// There was a connection error of some sort
  };

  request.send();
}

function getJson(url, callback, type) {
  if (type == 'jsonp') {
    jsonp(url, callback);
  } else {
    ajaxGet(url, callback);
  }
}

util.getJson = getJson;

// eslint-disable-next-line no-unused-vars

var defaults$2 = {
  controls: ['calendar'],
  firstDay: 0,
  weekDays: 'short',
  maxMonthWidth: 170,
  breakPointMd: 768,
  months: 1,
  pageBuffer: 1,
  weeks: 6,
  highlight: true,
  outerMonthChange: true,
  quickNav: true,
  yearChange: true,
  tabs: 'auto',
  // CSS classes
  todayClass: 'mbsc-cal-today',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left6',
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right6',
  // Localization
  dateText: 'Date',
  timeText: 'Time',
  todayText: 'Today',
  fromText: 'Start',
  toText: 'End',
  moreEventsText: '{count} more',
  prevMonthText: 'Previous Month',
  nextMonthText: 'Next Month',
  prevYearText: 'Previous Year',
  nextYearText: 'Next Year'
}; // --- TRIAL SERVER CODE END ---

var CalendarBase = function CalendarBase(inst) {
  var $calendar,
      $markup,
      $monthHdr,
      $monthPicker,
      $tabPaneCont,
      $tabPanes,
      $yearHdr,
      $yearPicker,
      activeDate,
      base,
      calRows,
      calSize,
      calWidth,
      context,
      controls,
      controlsArray,
      cssDisabled,
      cssSelected,
      cssSelectedTab,
      currFirstDay,
      dayLabels,
      dayProps,
      dayScroll,
      displayFormat,
      firstWeekDay,
      hasCal,
      hasLabels,
      hasMarks,
      hasTabs,
      // hasText,
  hasQuickNav,
      hoverTimer,
      invalidObj,
      isCellHover,
      isDayClick,
      isLiquid,
      isMonthView,
      isPageMove,
      isRTL,
      isVertical,
      labelsObj,
      markedObj,
      colorsObj,
      maxDate,
      maxFirstYear,
      maxLabels,
      maxMonth,
      maxYear,
      minDate,
      minFirstYear,
      minMonth,
      minYear,
      monthIndex,
      monthNames,
      monthScroll,
      needsSlide,
      needsRefresh,
      pageBuffer,
      pageNr,
      pageOffset,
      pageTotal,
      rtl,
      s,
      selectedDate,
      showOuterDays,
      trigger,
      validObj,
      visibleTab,
      wasTouched,
      weekCounter,
      weekDays,
      yearChange,
      yearIndex,
      yearScroll,
      yearSuffix,
      labelIdx = 1,
      elm = this;

  function showCont($cont) {
    if ($cont.hasClass('mbsc-cal-h')) {
      $cont.removeClass('mbsc-cal-h');
    }
  }

  function hideCont($cont) {
    if (!$cont.hasClass('mbsc-cal-h')) {
      $cont.addClass('mbsc-cal-h');
    }
  }

  function toggleCont($cont) {
    if ($cont.hasClass('mbsc-cal-h')) {
      showCont($cont);
    } else {
      hideCont($cont);
    }
  }

  function preProcessSettings() {
    var ctrls, layout, orig;
    controls = {};
    controlsArray = [];
    dayLabels = {};
    trigger = inst.trigger;
    orig = extend$1({}, inst.settings);
    s = extend$1(inst.settings, defaults$2, orig);
    ctrls = s.controls.join(',');
    firstWeekDay = s.firstDay;
    isRTL = s.rtl;
    pageBuffer = s.pageBuffer;
    weekCounter = s.weekCounter;
    calRows = s.weeks;
    isMonthView = calRows == 6;
    isVertical = s.calendarScroll == 'vertical';
    context = inst._getRespCont();
    weekDays = s.weekDays == 'full' ? '' : s.weekDays == 'min' ? 'Min' : 'Short';
    layout = s.layout || (s.display == 'inline' || /top|bottom/.test(s.display) && s.touchUi ? 'liquid' : '');
    isLiquid = layout == 'liquid'; // && s.display !== 'bubble';

    calWidth = isLiquid ? null : s.calendarWidth;
    rtl = isRTL && !isVertical ? -1 : 1;
    cssDisabled = 'mbsc-disabled ' + (s.disabledClass || '');
    cssSelectedTab = 'mbsc-selected ' + (s.selectedTabClass || '');
    cssSelected = 'mbsc-selected ' + (s.selectedClass || '');
    maxLabels = Math.max(1, Math.floor(((s.calendarHeight || 0) / calRows - 45) / 18));

    if (ctrls.match(/calendar/)) {
      controls.calendar = 1;
      hasCal = true;
    } // Allow date scroller only if calendar not present


    if (ctrls.match(/date/) && !hasCal) {
      controls.date = 1;
    }

    if (ctrls.match(/time/)) {
      controls.time = 1;
    }

    s.controls.forEach(function (v) {
      if (controls[v]) {
        controlsArray.push(v);
      }
    }); // Disable quick nav for week view

    hasQuickNav = s.quickNav && hasCal && isMonthView; // Disable year change for week view

    yearChange = s.yearChange && isMonthView; // Fullscreen mode

    if (isLiquid && hasCal && s.display == 'center') {
      inst._isFullScreen = true;
    }

    s.layout = layout; // Pass back to core if set to liquid

    s.preset = (controls.date || hasCal ? 'date' : '') + (controls.time ? 'time' : '');
  }

  function postProcessSettings() {
    monthNames = yearChange ? s.monthNamesShort : s.monthNames;
    yearSuffix = s.yearSuffix || '';
    monthIndex = (s.dateWheels || s.dateFormat).search(/m/i);
    yearIndex = (s.dateWheels || s.dateFormat).search(/y/i);
    displayFormat = inst._format;

    if (s.min) {
      minDate = getDateOnly(makeDate(s.min, displayFormat, s));
      minYear = s.getYear(minDate);
      minMonth = s.getMonth(minDate);
      minFirstYear = s.getDate(Math.floor(minYear / 12) * 12, 0, 1);
    }

    if (s.max) {
      maxDate = getDateOnly(makeDate(s.max, displayFormat, s));
      maxYear = s.getYear(maxDate);
      maxMonth = s.getMonth(maxDate);
      maxFirstYear = s.getDate(Math.floor(maxYear / 12) * 12, 0, 1);
    }

    inst._minDate = minDate;
    inst._maxDate = maxDate;
  }

  function addToList(obj, d, ev) {
    obj[d] = obj[d] || [];
    obj[d].push(ev);
  }

  function prepareObj(list, start, end) {
    var d,
        v,
        year,
        month,
        day,
        maxDays,
        endTime,
        startTime,
        getDate = s.getDate,
        getYear = s.getYear,
        getMonth = s.getMonth,
        getDay = s.getDay,
        getMaxDayOfMonth = s.getMaxDayOfMonth,
        startYear = getYear(start),
        startMonth = getMonth(start),
        obj = {};

    if (list) {
      $$1.each(list, function (i, ev) {
        d = ev.d || ev.start || ev;
        v = d + '';

        if (ev.start && ev.end) {
          startTime = getDateOnly(makeDate(ev.start, displayFormat, s));
          endTime = getDateOnly(makeDate(ev.end, displayFormat, s));

          while (startTime <= endTime) {
            addToList(obj, startTime, ev);
            startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 1);
          }
        } else if (DAY_OF_WEEK.test(v)) {
          // Day of week
          startTime = getFirstDay(start, false, +v.replace('w', ''));

          while (startTime <= end) {
            addToList(obj, startTime, ev);
            startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 7);
          }
        } else if (DAY_OF_MONTH.test(v)) {
          // Day of month: '2' or '12/24'
          v = v.split('/');
          var hasMonth = !!v[1],
              yearInc = hasMonth ? 1 : 0,
              monthInc = hasMonth ? 0 : 1,
              vMonth = hasMonth ? v[0] - 1 : startMonth,
              vDay = hasMonth ? +v[1] : +v[0];
          maxDays = getMaxDayOfMonth(startYear, vMonth);
          startTime = getDate(startYear, vMonth, Math.min(vDay, maxDays));

          while (startTime <= end) {
            year = getYear(startTime);
            month = getMonth(startTime);
            day = getDay(startTime);

            if (day === vDay) {
              addToList(obj, startTime, ev);
            }

            maxDays = getMaxDayOfMonth(year + yearInc, month + monthInc);
            startTime = getDate(year + yearInc, month + monthInc, Math.min(vDay, maxDays));
          }
        } else {
          // Exact date
          addToList(obj, getDateOnly(makeDate(d, displayFormat, s)), ev);
        }
      });
    }

    return obj;
  }

  function isValidDate(d) {
    if (d < minDate) {
      return false;
    }

    if (d > maxDate) {
      return false;
    }

    return invalidObj[d] === undefined || validObj[d] !== undefined;
  }

  function getDayProps(d) {
    var i,
        mark,
        markedMarkup,
        props,
        marked = markedObj[d] ? markedObj[d] : false,
        colors = colorsObj[d] ? colorsObj[d] : false,
        background = colors && colors[0].background ? colors[0].background : marked && marked[0].background,
        cssClass = '';

    if (colors) {
      for (i = 0; i < colors.length; i++) {
        cssClass += (colors[i].cssClass || '') + ' ';
      }
    }

    if (marked) {
      // Marks
      markedMarkup = '<div class="mbsc-cal-marks">';

      for (i = 0; i < marked.length; i++) {
        mark = marked[i];
        cssClass += (mark.cssClass || '') + ' ';
        markedMarkup += '<div class="mbsc-cal-mark"' + (mark.color ? ' style="background:' + mark.color + ';"' : '') + '></div>';
      }

      markedMarkup += '</div>';
    }

    props = {
      marked: marked,
      background: background,
      cssClass: cssClass,
      // ariaLabel: hasText ? txt : '',
      markup: dayLabels[d] ? dayLabels[d].join('') : hasMarks ? markedMarkup : ''
    };
    return extend$1(props, inst._getDayProps(d, props));
  }

  function getOffsetStyle(offset) {
    return ' style="' + (isVertical ? 'transform: translateY(' + offset * 100 + '%)' : 'left:' + offset * 100 * rtl + '%') + '"';
  }

  function calcMonthNr() {
    // Calculate pageNr
    pageNr = s.months == 'auto' ? // Exact month number from setting
    Math.max(1, // Min 1 month
    Math.min(3, // Max 3 months
    Math.floor((calWidth || getWidth(context)) / 280))) : +s.months;
    pageTotal = pageNr + 2 * pageBuffer;
    pageOffset = 0; //Math.round(pageNr / 2) - 1;
    // Don't allow vertical scroll with multiple months

    isVertical = isVertical && pageNr < 2; // Don't show outer days by default for multiple months or vertical scroll

    showOuterDays = s.showOuterDays === undefined ? pageNr < 2 && !isVertical || !isMonthView : s.showOuterDays;
  }

  function constrain(d) {
    if (getPageDay(d, pageNr - 1) > maxDate) {
      d = getPageDay(maxDate, 1 - pageNr);
    }

    if (d < minDate) {
      d = minDate;
    }

    return d;
  }

  function getLabelMarkup(event, i, showText) {
    var noBg = event.background === 'none';
    var color = noBg ? 'none' : event.color;
    var txtColor = noBg ? event.color : getTextColor(color);
    var txt = event.text;
    return '<div data-id="' + event._id + '" data-index="' + i + '" class="mbsc-cal-txt' + (noBg ? ' mbsc-cal-txt-only' : '') + '" title="' + $$1('<div>' + txt + '</div>').text() + '"' + (color ? ' style="background:' + color + (showText && txtColor ? ';color:' + txtColor : '') + ';"' : '') + '>' + (showText ? txt : '') + '</div>';
  }

  function onGenMonth(d) {
    var start = getFirstDay(getPageDay(d, -pageOffset - pageBuffer), false);
    var end = getFirstDay(getPageDay(d, -pageOffset + pageNr + pageBuffer - 1), false);
    end = s.getDate(s.getYear(end), s.getMonth(end), s.getDay(end) + calRows * 7);

    inst._onGenMonth(start, end);

    invalidObj = prepareObj(s.invalid, start, end);
    validObj = prepareObj(s.valid, start, end);
    markedObj = prepareObj(s.labels || s.events || s.marked, start, end);
    colorsObj = prepareObj(s.colors, start, end);
    labelsObj = inst._labels || markedObj || colorsObj;
    hasLabels = s.labels || inst._labels; // Multiple labels

    if (hasLabels) {
      (function () {
        dayLabels = {};
        var eventRows = {};
        var day = start;

        var _loop = function _loop() {
          if (day.getDay() == firstWeekDay) {
            eventRows = {};
          }

          var maxRows = maxLabels;
          var events = labelsObj[day] || [];
          var eventsNr = events.length;
          var labels = [];
          var prevEvent = void 0;
          var prevIndex = void 0;
          var row = 0;
          var displayed = 0;
          var i = 0;
          var width = void 0;

          while (row < maxRows) {
            prevEvent = null; // Check  if there are any events already in this row

            events.forEach(function (ev, j) {
              if (eventRows[row] == ev) {
                prevEvent = ev;
                prevIndex = j;
              }
            });

            if (row == maxRows - 1 && (displayed < eventsNr - 1 || eventsNr && i == eventsNr && !prevEvent)) {
              var nr = eventsNr - displayed;
              var txt = (nr > 1 ? s.moreEventsPluralText || s.moreEventsText : s.moreEventsText).replace(/{count}/, nr);

              if (nr) {
                labels.push('<div class="mbsc-cal-txt-more">' + txt + '</div>');
              } // Remove event from previous days and replace it with more label


              if (prevEvent) {
                eventRows[row] = null;

                prevEvent._days.forEach(function (d) {
                  dayLabels[d][row] = '<div class="mbsc-cal-txt-more">' + s.moreEventsText.replace(/{count}/, 1) + '</div>';
                });
              }

              displayed++;
              row++;
            } else if (prevEvent) {
              if (prevIndex == i) {
                i++;
              }

              if (isSameDay(day, makeDate(prevEvent.end))) {
                eventRows[row] = null;
              }

              labels.push(getLabelMarkup(prevEvent, prevIndex));
              row++;
              displayed++;

              prevEvent._days.push(day);
            } else if (i < eventsNr) {
              var event = events[i];
              var startTime = event.start && makeDate(event.start);
              var endTime = event.end && makeDate(event.end);
              var weekDay = day.getDay();
              var offset = firstWeekDay - weekDay > 0 ? 7 : 0;
              var multiDay = endTime && !isSameDay(startTime, endTime);

              if (!startTime || // all day event
              isSameDay(day, startTime) || // event start day
              weekDay == firstWeekDay // first day of week (if event continues from prev week))
              ) {
                  if (event._id === undefined) {
                    event._id = labelIdx++;
                  }

                  if (multiDay) {
                    eventRows[row] = event;
                  }

                  event._days = [day];
                  width = multiDay ? Math.min(getDayDiff(day, getDateOnly(endTime)) + 1, 7 + firstWeekDay - weekDay - offset) * 100 : 100;
                  labels.push(multiDay ? '<div class="mbsc-cal-txt-w" style="width:' + width + '%">' + getLabelMarkup(event, i, true) + '</div>' + getLabelMarkup(event, i) : getLabelMarkup(event, i, true));
                  row++;
                  displayed++;
                }

              i++;
            } else {
              labels.push('<div class="mbsc-cal-txt-ph"></div>');
              row++;
            }
          }

          dayLabels[day] = labels;
          day = s.getDate(s.getYear(day), s.getMonth(day), s.getDay(day) + 1);
        };

        while (day < end) {
          _loop();
        }
      })();
    }
  }

  function onBeforeMonthChange(d) {
    var y = s.getYear(d),
        m = s.getMonth(d);
    currFirstDay = d;
    activeDate = d;
    setTitle(d);
    trigger('onMonthChange', {
      year: y,
      month: m
    });
    trigger('onMonthLoading', {
      year: y,
      month: m
    });
    trigger('onPageChange', {
      firstDay: d
    });
    trigger('onPageLoading', {
      firstDay: d
    });
    onGenMonth(d);
  }

  function onAfterMonthChange(d) {
    var y = s.getYear(d),
        m = s.getMonth(d);

    if (needsRefresh === undefined) {
      onPageLoaded(d, y, m);
    } else {
      genAllMonths(d, needsRefresh, true);
    }

    focusDate(activeDate, dayScroll.focus);
    dayScroll.focus = false;
  }

  function onPageLoaded(d, y, m) {
    var $scroller = dayScroll.$scroller;
    $$1('.mbsc-cal-slide', $scroller).removeClass('mbsc-cal-slide-a');
    $$1('.mbsc-cal-slide', $scroller).slice(pageBuffer, pageBuffer + pageNr).addClass('mbsc-cal-slide-a');
    $$1('.mbsc-cal-slide-a .mbsc-cal-day', $scroller).on('mouseenter', function () {
      var $cell = $$1(this);

      if (!wasTouched && !isPageMove) {
        hoverTimer = setTimeout(function () {
          isCellHover = true;
          trigger('onCellHoverIn', getDayInfo($cell));
        }, 150);
      }
    }).on('mouseleave', function () {
      clearTimeout(hoverTimer);

      if (!wasTouched && isCellHover) {
        isCellHover = false;
        trigger('onCellHoverOut', getDayInfo($$1(this)));
      }
    });

    if (hasLabels) {
      $$1('.mbsc-cal-slide-a .mbsc-cal-txt', $scroller).on('mouseenter', function () {
        var id = $$1(this).attr('data-id');
        $$1('.mbsc-cal-txt[data-id="' + id + '"]', $scroller).addClass('mbsc-hover');
      }).on('mouseleave', function () {
        $$1('.mbsc-cal-txt.mbsc-hover', $scroller).removeClass('mbsc-hover');
      });
    }

    trigger('onMonthLoaded', {
      year: y,
      month: m
    });
    trigger('onPageLoaded', {
      firstDay: d
    });
  }

  function genTabMarkup() {
    var html, tabText;
    html = '<div class="mbsc-cal-tabs-c"><div class="mbsc-cal-tabs" role="tablist">';
    controlsArray.forEach(function (v, i) {
      tabText = s[(v == 'calendar' ? 'date' : v) + 'Text'];
      html += '<div role="tab" aria-controls="' + (elm.id + '-mbsc-pnl-' + i) + '" class="mbsc-cal-tab mbsc-fr-btn-e ' + (i ? '' : cssSelectedTab) + '" data-control="' + v + '"' + (s.tabLink ? '><a href="#">' + tabText + '</a>' : ' tabindex="0">' + tabText) + '</div>';
    });
    html += '</div></div>';
    return html;
  }

  function genCalMarkup() {
    var html,
        i,
        j,
        k,
        monthBtns,
        monthsMarkup,
        yearBtns = '',
        btnPrevClass = isRTL ? s.btnCalNextClass : s.btnCalPrevClass,
        btnNextClass = isRTL ? s.btnCalPrevClass : s.btnCalNextClass; // Generate month buttons

    monthBtns = '<div class="mbsc-cal-btn-w"><div data-step="-1" role="button" tabindex="0" aria-label="' + s.prevMonthText + '" class="' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div>';

    for (i = 0; i < (calRows ? pageNr : 1); i++) {
      monthBtns += '<div role="button" class="mbsc-cal-month"></div>';
    }

    monthBtns += '<div data-step="1" role="button" tabindex="0" aria-label="' + s.nextMonthText + '" class="' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div></div>'; // Generate year buttons

    if (yearChange) {
      yearBtns = '<div class="mbsc-cal-btn-w"><div data-step="-12" role="button" tabindex="0" aria-label="' + s.prevYearText + '" class="' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div>' + '<div role="button" class="mbsc-cal-year"></div>' + '<div data-step="12" role="button" tabindex="0" aria-label="' + s.nextYearText + '" class="' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e"></div></div>';
    }

    if (calRows) {
      monthsMarkup = genAllMonths(currFirstDay);
    }

    html = '<div class="mbsc-w-p mbsc-cal-c"><div class="mbsc-cal ' + (isMonthView ? '' : ' mbsc-cal-week-view') + (pageNr > 1 ? ' mbsc-cal-multi ' : '') + (weekCounter ? ' mbsc-cal-weeks ' : '') + (isVertical ? ' mbsc-cal-vertical' : '') + (hasMarks ? ' mbsc-cal-has-marks' : '') + (hasLabels ? ' mbsc-cal-has-labels' : '') + ( // (hasText ? ' mbsc-cal-has-txt' : '') +
    showOuterDays ? '' : ' mbsc-cal-hide-diff ') + (s.calendarClass || '') + '"' + (!isLiquid ? ' style="width:' + (calWidth || 280 * pageNr) + 'px;"' : '') + '>' + '<div class="mbsc-cal-hdr">' + (yearIndex < monthIndex || pageNr > 1 ? yearBtns + monthBtns : monthBtns + yearBtns) + '</div>';

    if (calRows) {
      html += '<div class="mbsc-cal-body"><div class="mbsc-cal-day-picker"><div class="mbsc-cal-days-c">';

      for (j = 0; j < pageNr; j++) {
        // Generate week days
        html += '<div class="mbsc-cal-days">';

        for (i = 0; i < 7; i++) {
          k = (i + firstWeekDay) % 7;
          html += '<div class="mbsc-cal-week-day' + k + '" aria-label="' + s.dayNames[k] + '">' + s['dayNames' + weekDays][k] + '</div>';
        }

        html += '</div>';
      }

      html += '</div>' + '<div class="mbsc-cal-scroll-c mbsc-cal-day-scroll-c ' + (s.calendarClass || '') + '"' + (s.calendarHeight ? ' style="height:' + s.calendarHeight + 'px"' : '') + '>' + '<div class="mbsc-cal-scroll" style="width:' + 100 / pageNr + '%' + '">' + monthsMarkup + '</div></div>';
    }

    html += '</div>';

    if (hasQuickNav) {
      // Generate month picker
      html += '<div class="mbsc-cal-month-picker mbsc-cal-picker mbsc-cal-h"><div class="mbsc-cal-scroll-c ' + (s.calendarClass || '') + '">' + '<div class="mbsc-cal-scroll">';

      for (i = 0; i < 3; i++) {
        html += '<div class="mbsc-cal-slide"' + getOffsetStyle(i - 1) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

        for (j = 0; j < 12; j++) {
          if (j && j % 3 === 0) {
            html += '</div><div role="row" class="mbsc-cal-row">';
          }

          html += '<div role="gridcell"' + (i == 1 ? ' tabindex="-1" aria-label="' + s.monthNames[j] + '" data-val="' + j + '"' : '') + ' class="mbsc-cal-cell' + (i == 1 ? ' mbsc-btn-e' : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-cell-txt">' + (i == 1 ? s.monthNamesShort[j] : '&nbsp;') + '</div></div>';
        }

        html += '</div></div></div>';
      }

      html += '</div></div></div>'; // Generate year picker

      html += '<div class="mbsc-cal-year-picker mbsc-cal-picker mbsc-cal-h"><div class="mbsc-cal-scroll-c ' + (s.calendarClass || '') + '">' + '<div class="mbsc-cal-scroll">';

      for (i = -1; i < 2; i++) {
        html += genYears(getPageYear(currFirstDay, i), i);
      }

      html += '</div></div></div>';
    } // Closing


    html += '</div></div></div>';
    return html;
  }

  function genYears(d, off) {
    var i,
        year = s.getYear(d),
        html = '<div class="mbsc-cal-slide"' + getOffsetStyle(off) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

    for (i = 0; i < 12; i++) {
      if (i && i % 3 === 0) {
        html += '</div><div role="row" class="mbsc-cal-row">';
      }

      html += '<div role="gridcell" tabindex="-1" aria-label="' + year + '" data-val="' + year + '"' + ' class="mbsc-cal-cell mbsc-btn-e ' + (year < minYear || year > maxYear ? ' mbsc-disabled ' : '') + (year == s.getYear(currFirstDay) ? cssSelected : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-cell-txt">' + year + yearSuffix + '</div></div>';
      year++;
    }

    html += '</div></div></div>';
    return html;
  }

  function genMonth(firstDay, off) {
    var bg,
        curr,
        cssClass,
        y,
        m,
        d,
        displayMonth,
        displayDate,
        fullDate,
        props,
        isValid,
        isSelected,
        isToday,
        isOuterDay,
        maxDays,
        i,
        j,
        k = 1,
        year = s.getYear(firstDay),
        month = s.getMonth(firstDay),
        day = s.getDay(firstDay),
        selected = s.defaultValue === null && !inst._hasValue ? null : inst.getDate(true),
        weekDay = s.getDate(year, month, day).getDay(),
        // Get the weekday of the month
    offset = firstWeekDay - weekDay > 0 ? 7 : 0,
        html = '<div class="mbsc-cal-slide"' + getOffsetStyle(off) + '><div role="grid" class="mbsc-cal-table"><div role="row" class="mbsc-cal-row">';

    for (j = 0; j < 7 * calRows; j++) {
      i = j + firstWeekDay - offset;
      curr = s.getDate(year, month, i - weekDay + day);
      y = curr.getFullYear();
      m = curr.getMonth();
      d = curr.getDate();
      displayMonth = s.getMonth(curr);
      displayDate = s.getDay(curr);
      maxDays = s.getMaxDayOfMonth(y, m);
      fullDate = y + '-' + (m + 1) + '-' + d;
      props = extend$1({
        valid: isValidDate(curr),
        selected: selected && isSameDay(selected, curr)
      }, getDayProps(curr));
      bg = props.background === 'none' ? false : props.background;
      isValid = props.valid;
      isSelected = props.selected;
      cssClass = props.cssClass; // Compare dates at noon, in some timezones 0:00 doesn't exists on daylight saving day

      isToday = new Date(curr).setHours(12, 0, 0, 0) === new Date().setHours(12, 0, 0, 0);
      isOuterDay = displayMonth !== month; // Day is from another month

      dayProps[fullDate] = props;

      if (j && j % 7 === 0) {
        html += '</div><div role="row" class="mbsc-cal-row">';
      }

      if (weekCounter && j % 7 === 0) {
        // If displaying days from next month, reset month counter
        if (weekCounter == 'month' && isOuterDay && k > 1) {
          k = d == 1 ? 1 : 2;
        } else if (weekCounter == 'year') {
          k = s.getWeekNumber(s.getDate(y, m, d + (7 - firstWeekDay + 1) % 7));
        }

        html += '<div role="gridcell" class="mbsc-cal-cell mbsc-cal-week-nr">' + k + '</div>';
        k++;
      }

      html += '<div role="gridcell"' + // Aria attributes
      ' aria-label="' + (isToday ? s.todayText + ', ' : '') + s.dayNames[curr.getDay()] + ', ' + s.monthNames[displayMonth] + ' ' + displayDate + ' ' + (props.ariaLabel ? ', ' + props.ariaLabel : '') + '"' + (isOuterDay && !showOuterDays ? ' aria-hidden="true"' : ' data-full="' + fullDate + '"') + (isOuterDay || !isValid ? ' aria-disabled="true"' : '') + (isSelected ? ' aria-selected="true"' : '') + (isValid ? ' tabindex="-1"' : '') + // Classes
      ' class="mbsc-cal-cell mbsc-cal-day mbsc-cal-day' + i % 7 + ' ' + (s.dayClass || '') + ' ' + (isSelected ? cssSelected : '') + (isToday ? ' ' + s.todayClass : '') + (cssClass ? ' ' + cssClass : '') + (displayDate == 1 ? ' mbsc-cal-day-first' : '') + (displayDate == maxDays ? ' mbsc-cal-day-last' : '') + (isOuterDay ? ' mbsc-cal-day-diff' : '') + (isValid ? ' mbsc-btn-e' : ' mbsc-disabled') + (props.marked ? ' mbsc-cal-day-marked' : '') + (bg ? ' mbsc-cal-day-colored' : '') + '"><div class="mbsc-cal-cell-i mbsc-cal-day-i"><div class="mbsc-cal-day-date mbsc-cal-cell-txt"' + (bg ? ' style="background:' + bg + ';color:' + getTextColor(bg) + '"' : '') + '>' + displayDate + '</div>'
      /* TRIAL */
      + ( // Extra markup (extra div is needed in RTL mode for Chrome, otherwise labels and marks appear at the top of the cell)
      props.markup ? '<div class="mbsc-cal-day-markup">' + props.markup + '</div>' : '') + '</div></div>';
    }

    html += '</div></div></div>';
    return html;
  }

  function genAllMonths(firstDay, render, insert) {
    var i,
        y = s.getYear(firstDay),
        m = s.getMonth(firstDay),
        pos = dayScroll ? dayScroll.pos : 0,
        html = '';
    dayProps = {};

    if (calRows) {
      if (!render) {
        trigger('onMonthLoading', {
          year: y,
          month: m
        });
        trigger('onPageLoading', {
          firstDay: firstDay
        });
      }

      onGenMonth(firstDay);

      for (i = 0; i < pageTotal; i++) {
        html += genMonth(getPageDay(firstDay, i - pageOffset - pageBuffer), pos * rtl + i - pageBuffer);
      }
    } //activateMonth(); // TODO: ???


    needsRefresh = undefined;

    if (insert && dayScroll) {
      dayScroll.$active = null;
      dayScroll.$scroller.html(html);
      onPageLoaded(firstDay, y, m);
    }

    return html;
  }

  function focusDate(d, focus) {
    if (dayScroll) {
      var $active = dayScroll.$active;

      if ($active && $active.length) {
        $active[0].blur();

        if ($active.hasClass('mbsc-disabled')) {
          $active.removeAttr('tabindex');
        } else {
          $active.attr('tabindex', '-1');
        }
      }

      dayScroll.$active = $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full="' + getDateStr(d) + '"]', dayScroll.$scroller).attr('tabindex', '0');

      if (focus && dayScroll.$active.length) {
        dayScroll.$active[0].focus();
      }
    }
  }

  function highlightDate(d) {
    var $ctx = dayScroll && dayScroll.$scroller;

    if (s.highlight && dayScroll) {
      $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');

      if (s.defaultValue !== null || inst._hasValue) {
        $$1('.mbsc-cal-day[data-full="' + getDateStr(d) + '"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');
      }
    }
  }

  function highlightSelected(v, $ctx) {
    $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');
    $$1('.mbsc-cal-cell[data-val="' + v + '"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');
  }

  function setDate(d, nav, anim, focus) {
    var diff, newFirstDay;

    if (!visibleTab) {
      return;
    }

    if (d < minDate) {
      d = minDate;
    }

    if (d > maxDate) {
      d = maxDate;
    }

    if (visibleTab === 'calendar' || !hasTabs || nav) {
      inst._isSetDate = !nav;

      if (hasCal && calRows) {
        newFirstDay = getFirstDay(constrain(d), isMonthView);

        if (needsSlide && (d < getPageDay(currFirstDay, -pageOffset) || d >= getPageDay(currFirstDay, pageNr - pageOffset))) {
          diff = isMonthView ? s.getMonth(newFirstDay) - s.getMonth(currFirstDay) + (s.getYear(newFirstDay) - s.getYear(currFirstDay)) * 12 : Math.floor(getDayDiff(currFirstDay, newFirstDay) / (7 * calRows));

          if (diff) {
            // Clear queue to navigate immediately
            dayScroll.queue = [];
            dayScroll.focus = focus && anim;
            changePageQueue(dayScroll, diff, anim);
          }
        }

        if (!diff || !anim) {
          focusDate(d, focus);
        }

        if (!nav) {
          highlightDate(d);
        }

        if (!isMonthView && !diff) {
          setTitle(currFirstDay, true);
        }

        activeDate = d;
        needsSlide = true;
      }

      inst._onSetDate(d, diff);

      inst._isSetDate = false;
    }
  }

  function setTitle(d, skipButtons) {
    var i,
        year,
        month,
        dd,
        y = s.getYear(d),
        m = s.getMonth(d),
        yy = y + yearSuffix;

    if (hasQuickNav) {
      // Highlight month
      highlightSelected(m, monthScroll.$scroller); // Highlight year

      highlightSelected(y, yearScroll.$scroller); // Scroll to selected year

      changePageQueue(yearScroll, Math.floor(y / 12) - Math.floor(s.getYear(yearScroll.first) / 12), true); // Disable out of range months

      $$1('.mbsc-cal-cell', monthScroll.$scroller).removeClass('mbsc-disabled');

      if (y === minYear) {
        for (i = 0; i < minMonth; i++) {
          $$1('.mbsc-cal-cell[data-val="' + i + '"]', monthScroll.$scroller).addClass('mbsc-disabled');
        }
      }

      if (y === maxYear) {
        for (i = maxMonth + 1; i <= 12; i++) {
          $$1('.mbsc-cal-cell[data-val="' + i + '"]', monthScroll.$scroller).addClass('mbsc-disabled');
        }
      }
    }

    if (!skipButtons) {
      // Disable/enable prev/next buttons
      checkBtn($$1('.mbsc-cal-prev-m', $markup), getPageDay(d, -pageOffset) <= minDate);
      checkBtn($$1('.mbsc-cal-next-m', $markup), getPageDay(d, pageNr - pageOffset) > maxDate);
      checkBtn($$1('.mbsc-cal-prev-y', $markup), s.getDate(y - 1, m + 1, 1) <= minDate);
      checkBtn($$1('.mbsc-cal-next-y', $markup), s.getDate(y + 1, m, 1) > maxDate);
    } // Update year in header


    $yearHdr.attr('aria-label', y).html(yy); // Update month in header

    for (i = 0; i < pageNr; i++) {
      dd = getPageDay(d, i - pageOffset);

      if (selectedDate >= dd && selectedDate < getPageDay(dd, 1)) {
        dd = selectedDate;
      }

      year = s.getYear(dd);
      month = s.getMonth(dd);
      yy = year + yearSuffix;
      $monthHdr.eq(i).attr('aria-label', s.monthNames[month] + (yearChange ? '' : ' ' + y)).html((!yearChange && yearIndex < monthIndex ? yy + ' ' : '') + monthNames[month] + (!yearChange && yearIndex > monthIndex ? ' ' + yy : ''));
    }
  }

  function checkBtn($btn, disable) {
    if (disable) {
      $btn.addClass(cssDisabled).attr('aria-disabled', 'true');
    } else {
      $btn.removeClass(cssDisabled).removeAttr('aria-disabled');
    }
  }

  function getDayInfo($day) {
    var day = $day[0],
        full = $day.attr('data-full'),
        parts = full ? full.split('-') : [],
        d = adjustedDate(parts[0], parts[1] - 1, parts[2]),
        selected = $day.hasClass('mbsc-selected');
    return extend$1(dayProps[full], {
      date: d,
      target: day,
      selected: selected
    });
  }

  function selectDay($day, ev) {
    var curr = inst.getDate(true),
        props = getDayInfo($day),
        day = $day[0],
        d = props.date,
        dtime = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate(), curr.getHours(), curr.getMinutes(), curr.getSeconds()),
        $target = $$1(ev.target),
        target = $target[0];

    if (!showOuterDays && $day.hasClass('mbsc-cal-day-diff')) {
      return;
    }

    props.date = dtime; // Check if a label was tapped

    if (hasLabels && day.contains(target)) {
      while (target != day) {
        if ($target.hasClass('mbsc-cal-txt') || $target.hasClass('mbsc-cal-txt-more')) {
          var index = $target.attr('data-index');
          var labels = labelsObj[d];

          if (trigger('onLabelTap', {
            date: dtime,
            domEvent: ev,
            target: $target[0],
            labels: labels,
            label: labels[index]
          }) === false) {
            return;
          }

          break;
        }

        $target = $target.parent();
        target = $target[0];
      }
    }

    if (trigger('onDayChange', props) !== false && !s.readonly && !$day.hasClass('mbsc-disabled')) {
      inst._selectDay($day, d, dtime, props.selected);
    }
  }

  function selectMonth($month) {
    hideCont($monthPicker);
    setDate(s.getDate(s.getYear(dayScroll.first), $month.attr('data-val'), 1), true, true);
  }

  function selectYear($year) {
    hideCont($yearPicker);
    setDate(s.getDate($year.attr('data-val'), s.getMonth(dayScroll.first), 1), true, true);
  }

  function getFirstDay(d, isMonth, w) {
    var y = s.getYear(d),
        m = s.getMonth(d),
        weekDay = d.getDay(),
        offset = firstWeekDay - weekDay > 0 ? 7 : 0;
    return isMonth ? s.getDate(y, m, 1) : s.getDate(y, m, (w === undefined ? firstWeekDay : w) - offset - weekDay + s.getDay(d));
  }

  function getPageDay(d, diff) {
    var year = s.getYear(d),
        month = s.getMonth(d),
        day = s.getDay(d);
    return isMonthView ? s.getDate(year, month + diff, 1) : s.getDate(year, month, day + diff * calRows * 7);
  }

  function getPageYear(d, diff) {
    var year = Math.floor(s.getYear(d) / 12) * 12;
    return s.getDate(year + diff * 12, 0, 1);
  }

  function changePageQueue(props, diff, anim, callback) {
    if (!diff || !inst._isVisible) {
      return;
    }

    props.queue.push(arguments);

    if (props.queue.length == 1) {
      changePage(props, diff, anim, callback);
    }
  }

  function changePage(props, diff, anim, callback) {
    var i,
        inc,
        html = '',
        $scroller = props.$scroller,
        pageBuffer = props.buffer,
        pageOffset = props.offset,
        pageNr = props.pages,
        pageTotal = props.total,
        firstDay = props.first,
        genPage = props.genPage,
        getFirst = props.getFirst,
        move = diff > 0 ? Math.min(diff, pageBuffer) : Math.max(diff, -pageBuffer),
        pos = props.pos * rtl + move - diff + pageOffset,
        load = Math.abs(diff) > pageBuffer; // Call any pending callback

    if (props.callback) {
      props.load();
      props.callback(true);
    }

    props.first = getFirst(firstDay, diff);
    props.pos += move * rtl;
    props.changing = true;

    props.load = function () {
      if (load) {
        for (i = 0; i < pageNr; i++) {
          inc = diff + i - pageOffset; // ???

          html += genPage(getFirst(firstDay, inc), pos + inc);
        }

        if (diff > 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(-pageNr).remove();
          $scroller.append(html);
        } else if (diff < 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(0, pageNr).remove();
          $scroller.prepend(html);
        }
      }
    };

    props.callback = function (forceStop) {
      var nr = Math.abs(move),
          html = '';

      if (!inst._isVisible) {
        return;
      }

      for (i = 0; i < nr; i++) {
        inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? pageTotal - nr : 0); // ???

        html += genPage(getFirst(firstDay, inc), pos + inc);
      }

      if (diff > 0) {
        $scroller.append(html);
        $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();
      } else if (diff < 0) {
        $scroller.prepend(html);
        $$1('.mbsc-cal-slide', $scroller).slice(move).remove();
      }

      if (load) {
        html = '';

        for (i = 0; i < nr; i++) {
          inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? 0 : pageTotal - nr); // ???

          html += genPage(getFirst(firstDay, inc), pos + inc);
        }

        if (diff > 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();
          $scroller.prepend(html);
        } else if (diff < 0) {
          $$1('.mbsc-cal-slide', $scroller).slice(move).remove();
          $scroller.append(html);
        }
      }

      refreshScroller(props);

      if (callback && !forceStop) {
        callback();
      }

      props.callback = null;
      props.load = null;
      props.queue.shift();
      load = false;

      if (props.queue.length) {
        changePage.apply(this, props.queue[0]);
      } else {
        props.changing = false;
        props.onAfterChange(props.first);
      }
    };

    props.onBeforeChange(props.first);

    if (props.load) {
      props.load();
      props.scroller.scroll(-props.pos * props.size, anim ? 200 : 0, false, props.callback);
    }
  }

  function createScroller(cont, min, max, buffer, offset, pages, total, first, onTap, onBeforeChange, onAfterChange, genPage, getFirst) {
    var axis = isVertical ? 'Y' : 'X',
        props = {
      $scroller: $$1('.mbsc-cal-scroll', cont),
      queue: [],
      buffer: buffer,
      offset: offset,
      pages: pages,
      first: first,
      total: total,
      pos: 0,
      min: min,
      max: max,
      genPage: genPage,
      getFirst: getFirst,
      onBeforeChange: onBeforeChange,
      onAfterChange: onAfterChange
    };
    props.scroller = new ScrollViewBase(cont, {
      axis: axis,
      easing: '',
      contSize: 0,
      maxSnapScroll: buffer,
      mousewheel: s.mousewheel === undefined ? isVertical : s.mousewheel,
      time: 200,
      lock: true,
      rtl: isRTL,
      stopProp: false,
      minScroll: 0,
      maxScroll: 0,
      onBtnTap: function onBtnTap(ev) {
        if (ev.domEvent.type == 'touchend') {
          preventClick();
        }

        onTap($$1(ev.target), ev.domEvent);
      },
      onStart: function onStart() {
        clearTimeout(hoverTimer);
      },
      onGestureStart: function onGestureStart() {
        isPageMove = true;
      },
      onAnimationStart: function onAnimationStart() {
        props.changing = true;
      },
      onAnimationEnd: function onAnimationEnd(ev) {
        isPageMove = false;

        if (genPage) {
          changePageQueue(props, Math.round((-props.pos * props.size - ev['pos' + axis]) / props.size) * rtl);
        }
      }
    });

    inst._scrollers.push(props.scroller);

    return props;
  }

  function refreshScroller(props, check) {
    var size,
        plus = 0,
        minus = 0,
        firstDay = props.first;

    if (props.changing && check) {
      return;
    }

    if (props.getFirst) {
      plus = props.buffer;
      minus = props.buffer; //while (minus && s.getDate(y, m + minus + monthNr - moveMonth - 1, 1) > maxDate) { ???

      while (minus && props.getFirst(firstDay, minus + props.pages - props.offset - 1) > props.max) {
        minus--;
      } //while (plus && s.getDate(y, m - plus - moveMonth, 1) < minDate) { ???


      while (plus && props.getFirst(firstDay, 1 - plus - props.offset) <= props.min) {
        plus--;
      }
    }

    size = Math.round(calSize / props.pages); // Page size might be a fractional value in case of multiple months
    // so we need to explicitly set the rounded value

    if (isLiquid && size && props.size != size) {
      props.$scroller[isVertical ? 'height' : 'width'](size);
    }

    extend$1(props.scroller.settings, {
      snap: size,
      minScroll: (-props.pos * rtl - minus) * size,
      maxScroll: (-props.pos * rtl + plus) * size
    });
    props.size = size;
    props.scroller.refresh();
  }

  function refresh(render) {
    inst._onRefresh(render);

    if (inst._isVisible && hasCal && calRows) {
      if (dayScroll && dayScroll.changing) {
        needsRefresh = render;
      } else {
        genAllMonths(currFirstDay, render, true);
        focusDate(activeDate);
      }
    }
  }

  function onTouchStart(ev) {
    wasTouched = ev.type === 'touchstart';
  }

  function attachEvents() {
    if (hasCal && calRows) {
      var $scrollers = $$1('.mbsc-cal-scroll-c', $markup); // Day selector

      dayScroll = createScroller($scrollers[0], minDate, maxDate, pageBuffer, pageOffset, pageNr, pageTotal, currFirstDay, selectDay, onBeforeMonthChange, onAfterMonthChange, genMonth, getPageDay);

      if (hasQuickNav) {
        // Month selector
        monthScroll = createScroller($scrollers[1], null, null, 1, 0, 1, 3, currFirstDay, selectMonth); // Year selector

        yearScroll = createScroller($scrollers[2], minFirstYear, maxFirstYear, 1, 0, 1, 3, currFirstDay, selectYear, noop, noop, genYears, getPageYear); // Show / hide month picker

        inst.tap($monthHdr, function () {
          toggleCont($monthPicker);
          hideCont($yearPicker);
        }); // Show / hide year picker

        inst.tap($yearHdr, function () {
          toggleCont($yearPicker);
          hideCont($monthPicker);
        });
      } // Init navigation arrows


      createStepper($$1('.mbsc-cal-btn', $markup), function (i, diff, ev, next) {
        changePageQueue(dayScroll, diff, true, next);
      }); // Triggers onMonthLoaded on initial render

      onAfterMonthChange(currFirstDay); // Focus on the selected date on show

      if ((s.defaultValue !== null || inst._hasValue) && !inst._multiple) {
        inst._activeElm = dayScroll.$active[0];
      }

      listen($calendar[0], 'touchstart', onTouchStart, {
        passive: true
      });
      listen($calendar[0], 'mousedown', onTouchStart);
      $calendar // Keyboard navigation
      .on('keydown', function (ev) {
        var year = s.getYear(activeDate),
            month = s.getMonth(activeDate),
            day = s.getDay(activeDate),
            newDate;

        switch (ev.keyCode) {
          case 32:
            //SPACE
            selectDay(dayScroll.$active, ev);
            break;

          case 37:
            //LEFT_ARROW:
            newDate = s.getDate(year, month, day - 1 * rtl);
            break;

          case 39:
            //RIGHT_ARROW:
            newDate = s.getDate(year, month, day + 1 * rtl);
            break;

          case 38:
            //UP_ARROW:
            newDate = s.getDate(year, month, day - 7);
            break;

          case 40:
            //DOWN_ARROW:
            newDate = s.getDate(year, month, day + 7);
            break;

          case 36:
            //HOME:
            newDate = s.getDate(year, month, 1);
            break;

          case 35:
            //END:
            newDate = s.getDate(year, month + 1, 0);
            break;

          case 33:
            //PAGE_UP:
            newDate = ev.altKey ? s.getDate(year - 1, month, day) : isMonthView ? s.getDate(year, month - 1, day) : s.getDate(year, month, day - calRows * 7);
            break;

          case 34:
            //PAGE_DOWN:
            newDate = ev.altKey ? s.getDate(year + 1, month, day) : isMonthView ? s.getDate(year, month + 1, day) : s.getDate(year, month, day + calRows * 7);
            break;
        }

        if (newDate) {
          ev.preventDefault();
          setDate(newDate, true, false, true);
        }
      });
    } // Tabs


    inst.tap($$1('.mbsc-cal-tab', $markup), function () {
      inst.changeTab($$1(this).attr('data-control'));
    });
  }

  preProcessSettings();
  base = DateTime.call(this, inst);
  postProcessSettings(); // Public functions
  // ---

  inst.refresh = function () {
    refresh(false);
  };

  inst.redraw = function () {
    refresh(true);
  };

  inst.navigate = function (d, anim) {
    setDate(makeDate(d, displayFormat, s), true, anim);
  };

  inst.changeTab = function (tab) {
    if (!inst._isVisible || !controls[tab] || visibleTab == tab) {
      return;
    }

    visibleTab = tab;
    $$1('.mbsc-cal-tab', $markup).removeClass(cssSelectedTab).removeAttr('aria-selected');
    $$1('.mbsc-cal-tab[data-control="' + tab + '"]', $markup).addClass(cssSelectedTab).attr('aria-selected', 'true');

    if (hasTabs) {
      $tabPanes.addClass('mbsc-cal-h');
      controls[visibleTab].removeClass('mbsc-cal-h');
    }

    if (visibleTab == 'calendar') {
      // Set the date of the calendar if date changed from the scroller
      setDate(inst.getDate(true), false, true);
    } // Hide


    inst._showDayPicker();

    inst.trigger('onTabChange', {
      tab: visibleTab
    });
  }; // ---
  // Protected functions
  // ---


  inst._checkSize = true;
  inst._onGenMonth = noop;
  inst._onSetDate = noop;
  inst._onRefresh = noop;
  inst._getDayProps = noop;
  inst._prepareObj = prepareObj;

  inst._showDayPicker = function () {
    if (hasQuickNav) {
      hideCont($yearPicker);
      hideCont($monthPicker);
    }
  };

  inst._selectDay = inst.__selectDay = function ($day, d, dtime) {
    var fill = inst.live; // Prevents month slide in setDate

    needsSlide = s.outerMonthChange;
    isDayClick = true; // Set date on scroller

    inst.setDate(dtime, fill, 1000, !fill, true);

    if (fill) {
      trigger('onSet', {
        valueText: inst._value
      });
    }
  };

  inst._checkBtn = checkBtn; // ---

  return extend$1(base, {
    labels: null,
    // Overrides labels coming from language files
    compClass: 'mbsc-calendar mbsc-dt mbsc-sc',
    onMarkupReady: function onMarkupReady(ev) {
      var j = 0;
      $markup = $$1(ev.target);
      $tabPaneCont = $$1('.mbsc-fr-c', $markup);
      activeDate = inst.getDate(true);
      calSize = 0;

      if (hasCal) {
        hasMarks = !!(s.marked || s.data) && !s.labels && !s.multiLabel && !s.showEventCount; // hasText = s.showEventCount || !!(s.events || s.labels);

        needsSlide = true;
        visibleTab = 'calendar';
        calcMonthNr();
        currFirstDay = getFirstDay(constrain(activeDate), isMonthView);
        $tabPaneCont.append(genCalMarkup());
        $monthHdr = $$1('.mbsc-cal-month', $markup);
        $yearHdr = $$1('.mbsc-cal-year', $markup);
        $calendar = $$1('.mbsc-cal-day-scroll-c', $markup);
      }

      if (hasQuickNav) {
        $yearPicker = $$1('.mbsc-cal-year-picker', $markup);
        $monthPicker = $$1('.mbsc-cal-month-picker', $markup);
      }

      $tabPanes = $$1('.mbsc-w-p', $markup); // Insert tab markup

      if (controlsArray.length > 1) {
        $tabPaneCont.before(genTabMarkup());
      } // Find markup for controls


      ['date', 'time', 'calendar'].forEach(function (v) {
        if (controls[v]) {
          controls[v] = $tabPanes.eq(j);
          j++;
        } else if (v == 'date' && !controls.date && hasCal) {
          $tabPanes.eq(j).remove();
          j++;
        }
      }); // Insert controls in correct order

      controlsArray.forEach(function (v) {
        $tabPaneCont.append(controls[v]);
      }); // TODO: this is an ugly solution

      if (!hasCal && controls.date) {
        controls.date.css('position', 'relative');
      }

      inst._scrollers = [];
      attachEvents();
    },
    onShow: function onShow() {
      if (hasCal && calRows) {
        setTitle(currFirstDay);
      }
    },
    onHide: function onHide() {
      inst._scrollers.forEach(function (v) {
        v.destroy();
      });

      dayProps = null;
      dayScroll = null;
      monthScroll = null;
      yearScroll = null;
      visibleTab = null;
    },
    onValidated: function onValidated(ev) {
      var ctrl,
          d,
          i = ev.index,
          order = inst._order;
      d = inst.getDate(true);
      selectedDate = d; // Find out on which control was the selection made

      if (isDayClick) {
        ctrl = 'calendar';
      } else if (i !== undefined) {
        ctrl = order.dd == i || order.d == i || order.m == i || order.y == i ? 'date' : 'time';
      }

      trigger('onSetDate', {
        date: d,
        control: ctrl
      }); // Set date on calendar

      if (ctrl !== 'time') {
        setDate(d, false, !!ev.time, isDayClick && !inst._multiple);
      }

      isDayClick = false;
    },
    onPosition: function onPosition(ev) {
      var i,
          y,
          m,
          doRefresh,
          modalHeight,
          newCalSize,
          availableHeight,
          oldHeight = ev.oldHeight,
          windowHeight = ev.windowHeight;
      hasTabs = (ev.hasTabs || s.tabs === true || s.tabs !== false && isLiquid) && controlsArray.length > 1;

      if (isLiquid) {
        if (ev.windowWidth >= s.breakPointMd) {
          $$1(ev.target).addClass('mbsc-fr-md');
        } else {
          $$1(ev.target).removeClass('mbsc-fr-md');
        }
      } // Show/hide tabs


      if (hasTabs) {
        $markup.addClass('mbsc-cal-tabbed');
        visibleTab = $$1('.mbsc-cal-tab.mbsc-selected', $markup).attr('data-control');
        $tabPanes.addClass('mbsc-cal-h');
        controls[visibleTab].removeClass('mbsc-cal-h');
      } else {
        // visibleTab = 'calendar';
        $markup.removeClass('mbsc-cal-tabbed');
        $tabPanes.removeClass('mbsc-cal-h');
      } // Full screen mode


      if (inst._isFullScreen) {
        // Reset height
        $calendar.height('');
        modalHeight = ev.popup.offsetHeight; // Get available height

        availableHeight = windowHeight - modalHeight + $calendar[0].offsetHeight; // Only set fixed height if calendar height is bigger than viewport height

        if (windowHeight >= modalHeight) {
          $calendar.height(availableHeight);
        }
      }

      if (hasLabels && calRows && windowHeight != oldHeight) {
        // Check how many labels can we display on a day
        var calHeight = availableHeight || $calendar[0].offsetHeight;
        var ph = $calendar.find('.mbsc-cal-txt,.mbsc-cal-txt-ph')[0];
        var numberHeight = ph.offsetTop;
        var txtHeight = ph.offsetHeight;
        var newMaxLabels = Math.max(1, Math.floor((calHeight / calRows - numberHeight) / (txtHeight + 2))); // Redraw the calendar, if max labels changed

        if (maxLabels != newMaxLabels) {
          maxLabels = newMaxLabels;
          inst.redraw();
        }
      } // Refresh scrollviews


      if (hasCal && calRows) {
        // Need to calculate size
        if (isLiquid || isVertical || hasTabs) {
          newCalSize = $calendar[0][isVertical ? 'offsetHeight' : 'offsetWidth'];
        } else {
          newCalSize = calWidth || pageNr * 280;
        }

        doRefresh = newCalSize != calSize;
        calSize = newCalSize; // Use long or short month names

        if (isLiquid && doRefresh) {
          if (yearChange) {
            monthNames = s.maxMonthWidth > $monthHdr[0].offsetWidth ? s.monthNamesShort : s.monthNames;
            y = s.getYear(currFirstDay);
            m = s.getMonth(currFirstDay);

            for (i = 0; i < pageNr; i++) {
              $monthHdr.eq(i).text(monthNames[s.getMonth(s.getDate(y, m - pageOffset + i, 1))]);
            }
          }
        }

        if (doRefresh) {
          refreshScroller(dayScroll, true);
        }
      }

      if (hasQuickNav && doRefresh) {
        refreshScroller(monthScroll, true);
        refreshScroller(yearScroll, true);
      }
    }
  });
};

var Calendar = Scroller;
var defaults$3 = {};

presets.calendar = function (inst) {
  function getDateOnly(d) {
    return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
  }

  function setValues(values) {
    var d,
        i,
        first = null;
    selectedValues = {};

    if (values && values.length) {
      for (i = 0; i < values.length; i++) {
        d = makeDate(values[i], displayFormat, s, s.isoParts);
        first = first || d;
        selectedValues[getDateOnly(d)] = d;
      }
    }

    return first;
  }

  function redraw() {
    inst.redraw();
  } // ---


  var base,
      ctx,
      displayFormat,
      firstSelectDay,
      origValues,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$3, orig),
      cssSelected = 'mbsc-selected ' + (s.selectedClass || ''),
      defaultValue = s.defaultValue,
      multi = s.select == 'multiple' || s.select > 1 || s.selectType == 'week',
      maxSelect = isNumeric(s.select) ? s.select : Infinity,
      selectedValues = {};
  base = CalendarBase.call(this, inst);
  firstSelectDay = s.firstSelectDay === undefined ? s.firstDay : s.firstSelectDay;
  displayFormat = inst._format;

  if (multi) {
    setValues(defaultValue);
  } // Extended methods
  // ---


  inst._multiple = multi;

  inst._getDayProps = function (d) {
    return {
      selected: multi ? selectedValues[d] !== undefined : undefined
    };
  };

  inst._selectDay = function ($day, d, dtime, selected) {
    var isSingleSelect = s.select == 'single' || s.select == 1 || s.select === undefined; // Single select with instant close

    if (s.setOnDayTap && isSingleSelect && s.display != 'inline') {
      inst.setDate(dtime);
      inst.select();
      return;
    }

    if (multi) {
      // Multiple day selection
      if (s.selectType == 'week') {
        // Select whole week
        var i,
            sel,
            diff = d.getDay() - firstSelectDay;
        diff = diff < 0 ? 7 + diff : diff;

        if (isSingleSelect) {
          // Only one week can be selected
          selectedValues = {};
        }

        for (i = 0; i < 7; i++) {
          sel = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate() - diff + i);

          if (selected) {
            delete selectedValues[sel];
          } else if (objectToArray(selectedValues).length / 7 < maxSelect) {
            selectedValues[sel] = sel;
          }
        }

        redraw();
      } else {
        // Select day only
        var days = $$1('.mbsc-cal-day[data-full="' + $day.attr('data-full') + '"]', ctx);

        if (selected) {
          days.removeClass(cssSelected).removeAttr('aria-selected');
          delete selectedValues[d];
        } else if (objectToArray(selectedValues).length < maxSelect) {
          days.addClass(cssSelected).attr('aria-selected', 'true');
          selectedValues[d] = d;
        }
      }
    } // Standard selection


    inst.__selectDay($day, d, dtime);
  };

  inst.setVal = function (val, fill, change, temp, time) {
    if (multi) {
      val = setValues(val);
    }

    inst._setVal(val, fill, change, temp, time);

    if (multi) {
      redraw();
    }
  };

  inst.getVal = function (temp) {
    var i,
        ret = [];

    if (multi) {
      for (i in selectedValues) {
        ret.push(returnDate(selectedValues[i], s, displayFormat));
      }

      return ret;
    }

    return returnDate(inst.getDate(temp), s, displayFormat);
  }; // ---


  return extend$1({}, base, {
    highlight: !multi,
    outerMonthChange: !multi,
    parseValue: function parseValue(v) {
      if (multi && v && typeof v === 'string') {
        v = setValues(v.split(','));
      }

      if (multi && defaultValue && defaultValue.length) {
        s.defaultValue = defaultValue[0];
      }

      return base.parseValue.call(this, v);
    },
    formatValue: function formatValue(d) {
      var i,
          ret = [];

      if (multi) {
        for (i in selectedValues) {
          ret.push(formatDate(displayFormat, selectedValues[i], s));
        }

        return ret.join(', ');
      }

      return base.formatValue.call(this, d, inst);
    },
    onClear: function onClear() {
      if (multi) {
        selectedValues = {};
        redraw();
      }
    },
    onBeforeShow: function onBeforeShow() {
      if (s.setOnDayTap === undefined && (!s.buttons || !s.buttons.length) && s.controls.length == 1) {
        s.setOnDayTap = true;
      }

      if (s.setOnDayTap && s.display != 'inline') {
        s.outerMonthChange = false;
      }

      if (s.counter && multi) {
        s.headerText = function () {
          var length = 0,
              w = s.selectType == 'week' ? 7 : 1;
          $$1.each(selectedValues, function () {
            length++;
          });
          length = Math.round(length / w);
          return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);
        };
      }
    },
    onMarkupReady: function onMarkupReady(ev) {
      base.onMarkupReady.call(this, ev);
      ctx = $$1(ev.target);

      if (multi) {
        $$1('.mbsc-fr-hdr', ctx).attr('aria-live', 'off');
        origValues = extend$1({}, selectedValues);
      }
    },
    onCancel: function onCancel() {
      if (!inst.live && multi) {
        selectedValues = extend$1({}, origValues);
      }
    }
  });
};

var MbscDatetimeBase = (function (_super) {
    __extends(MbscDatetimeBase, _super);
    function MbscDatetimeBase(initialElem, zone, control, inputService, view) {
        return _super.call(this, initialElem, zone, control, inputService, view) || this;
    }
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscDatetimeBase.prototype, "defaultValue", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscDatetimeBase.prototype, "invalid", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Date)
    ], MbscDatetimeBase.prototype, "max", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Date)
    ], MbscDatetimeBase.prototype, "min", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "returnFormat", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscDatetimeBase.prototype, "steps", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscDatetimeBase.prototype, "valid", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "calendarSystem", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "ampmText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "amText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "dateFormat", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "dateWheels", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscDatetimeBase.prototype, "dayNames", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscDatetimeBase.prototype, "dayNamesShort", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "dayText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "hourText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "minuteText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscDatetimeBase.prototype, "monthNames", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscDatetimeBase.prototype, "monthNamesShort", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "monthSuffix", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "monthText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "nowText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "pmText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "secText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "timeFormat", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "timeWheels", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "yearSuffix", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeBase.prototype, "yearText", void 0);
    MbscDatetimeBase = __decorate([
        Directive({ selector: '[mbsc-dt-b' }),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])
    ], MbscDatetimeBase);
    return MbscDatetimeBase;
}(MbscScrollerBase));
var MbscDatetimeBaseModule = (function () {
    function MbscDatetimeBaseModule() {
    }
    MbscDatetimeBaseModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscScrollerBaseModule],
            declarations: [MbscDatetimeBase],
        })
    ], MbscDatetimeBaseModule);
    return MbscDatetimeBaseModule;
}());

var MbscCalBase = (function (_super) {
    __extends(MbscCalBase, _super);
    function MbscCalBase(initialElem, zone, control, inputService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.onTabChange = new EventEmitter();
        _this.onLabelTap = new EventEmitter();
        _this.onMonthChange = new EventEmitter();
        _this.onMonthLoading = new EventEmitter();
        _this.onMonthLoaded = new EventEmitter();
        _this.onPageChange = new EventEmitter();
        _this.onPageLoaded = new EventEmitter();
        _this.onPageLoading = new EventEmitter();
        return _this;
    }
    MbscCalBase.prototype.ngOnInit = function () {
        this.cloneDictionary.colors = [];
        this.cloneDictionary.labels = [];
        this.cloneDictionary.marked = [];
        _super.prototype.ngOnInit.call(this);
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscCalBase.prototype, "calendarHeight", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscCalBase.prototype, "calendarWidth", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "calendarScroll", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscCalBase.prototype, "colors", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalBase.prototype, "counter", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscCalBase.prototype, "defaultValue", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscCalBase.prototype, "events", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscCalBase.prototype, "labels", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscCalBase.prototype, "marked", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscCalBase.prototype, "months", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalBase.prototype, "mousewheel", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalBase.prototype, "outerMonthChange", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalBase.prototype, "showOuterDays", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalBase.prototype, "tabs", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "weekCounter", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "weekDays", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscCalBase.prototype, "weeks", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalBase.prototype, "yearChange", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "dateText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscCalBase.prototype, "dayNamesMin", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscCalBase.prototype, "firstDay", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "timeText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "moreEventsPluralText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalBase.prototype, "moreEventsText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onTabChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onLabelTap", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onMonthChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onMonthLoading", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onMonthLoaded", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onPageChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onPageLoaded", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalBase.prototype, "onPageLoading", void 0);
    MbscCalBase = __decorate([
        Directive({ selector: '[mbsc-cal-b' }),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])
    ], MbscCalBase);
    return MbscCalBase;
}(MbscDatetimeBase));
var MbscCalBaseModule = (function () {
    function MbscCalBaseModule() {
    }
    MbscCalBaseModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscDatetimeBaseModule],
            declarations: [MbscCalBase],
        })
    ], MbscCalBaseModule);
    return MbscCalBaseModule;
}());

var MbscCalendar = (function (_super) {
    __extends(MbscCalendar, _super);
    function MbscCalendar(initialElement, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.onSetDate = new EventEmitter();
        _this.onCellHoverIn = new EventEmitter();
        _this.onCellHoverOut = new EventEmitter();
        _this.onDayChange = new EventEmitter();
        _this.options = {};
        _this.isMulti = undefined;
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscCalendar.prototype, "value", {
        set: function (v) {
            if (!this.control) {
                this.setNewValueProxy(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscCalendar.prototype.setNewValue = function (v) {
        if (this.instance) {
            var changed = void 0;
            if (this.isMulti) {
                changed = !deepEqualsArray(v, this.instance.getVal());
            }
            else {
                var innerValue = this.instance.getVal();
                changed = ((!innerValue && v) ||
                    (innerValue && !v) ||
                    (innerValue && v && innerValue.toString() !== v.toString()));
            }
            if (changed) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscCalendar.prototype.initControl = function () {
        var options = extend$1({ preset: 'calendar' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Calendar(this.element, options);
        if (this.initialValue !== undefined && this.initialValue !== "") {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscCalendar.prototype.ngOnInit = function () {
        this.isMulti = this.options && ((this.options.select && this.options.select !== 'single') || (this.options.selectType == 'week'));
        this.cloneDictionary.marked = [];
        this.cloneDictionary.invalid = [];
        _super.prototype.ngOnInit.call(this);
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscCalendar.prototype, "controls", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscCalendar.prototype, "firstSelectDay", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalendar.prototype, "selectType", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscCalendar.prototype, "select", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalendar.prototype, "setOnDayTap", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalendar.prototype, "onSetDate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalendar.prototype, "onCellHoverIn", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalendar.prototype, "onCellHoverOut", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscCalendar.prototype, "onDayChange", void 0);
    __decorate([
        Input$1('mbsc-options'),
        __metadata("design:type", Object)
    ], MbscCalendar.prototype, "options", void 0);
    __decorate([
        Input$1('mbsc-calendar'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MbscCalendar.prototype, "value", null);
    __decorate([
        Output('mbsc-calendarChange'),
        __metadata("design:type", EventEmitter)
    ], MbscCalendar.prototype, "onChangeEmitter", void 0);
    MbscCalendar = __decorate([
        Directive({
            selector: '[mbsc-calendar]',
            exportAs: 'mobiscroll'
        }),
        __param(2, Optional()),
        __param(3, Optional()),
        __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone,
            NgControl,
            MbscInputService,
            MbscOptionsService,
            ViewContainerRef])
    ], MbscCalendar);
    return MbscCalendar;
}(MbscCalBase));
var MbscCalendarComponent = (function (_super) {
    __extends(MbscCalendarComponent, _super);
    function MbscCalendarComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.placeholder = '';
        _this.errorMessage = '';
        return _this;
    }
    MbscCalendarComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    __decorate([
        Input$1('icon'),
        __metadata("design:type", String)
    ], MbscCalendarComponent.prototype, "inputIcon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscCalendarComponent.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalendarComponent.prototype, "name", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalendarComponent.prototype, "placeholder", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscCalendarComponent.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscCalendarComponent.prototype, "errorMessage", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscCalendarComponent.prototype, "options", void 0);
    MbscCalendarComponent = __decorate([
        Component({
            selector: 'mbsc-calendar',
            exportAs: 'mobiscroll',
            template: INPUT_TEMPLATE
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])
    ], MbscCalendarComponent);
    return MbscCalendarComponent;
}(MbscCalendar));
var MbscCalendarModule = (function () {
    function MbscCalendarModule() {
    }
    MbscCalendarModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscCalBaseModule, MbscInputModule],
            declarations: [MbscCalendar, MbscCalendarComponent],
            exports: [MbscCalendar, MbscCalendarComponent]
        })
    ], MbscCalendarModule);
    return MbscCalendarModule;
}());

var DateTime$1 = Scroller;
presets.date = DateTime;
presets.time = DateTime;
presets.datetime = DateTime;

var MbscDateBase = (function (_super) {
    __extends(MbscDateBase, _super);
    function MbscDateBase(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.options = {};
        _this.preset = 'date';
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscDateBase.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscDateBase.prototype.setNewValue = function (v) {
        if (this.instance) {
            var innerValue = this.instance.getVal();
            if ((!innerValue && v) ||
                (innerValue && !v) ||
                (innerValue && v && innerValue.toString() !== v.toString())) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    MbscDateBase.prototype.initControl = function () {
        var options = extend$1({ preset: this.preset }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new DateTime$1(this.element, options);
        if (this.initialValue !== undefined && this.initialValue !== "") {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    __decorate([
        Input$1('mbsc-options'),
        __metadata("design:type", Object)
    ], MbscDateBase.prototype, "options", void 0);
    __decorate([
        Input$1('mbsc-date'),
        __metadata("design:type", Date),
        __metadata("design:paramtypes", [Date])
    ], MbscDateBase.prototype, "value", null);
    __decorate([
        Output('mbsc-dateChange'),
        __metadata("design:type", EventEmitter)
    ], MbscDateBase.prototype, "onChangeEmitter", void 0);
    MbscDateBase = __decorate([
        Directive({ selector: '[mbsc-dt-b]' }),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])
    ], MbscDateBase);
    return MbscDateBase;
}(MbscDatetimeBase));
var MbscDate = (function (_super) {
    __extends(MbscDate, _super);
    function MbscDate(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.preset = 'date';
        return _this;
    }
    MbscDate = __decorate([
        Directive({
            selector: '[mbsc-date]',
            exportAs: 'mobiscroll'
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])
    ], MbscDate);
    return MbscDate;
}(MbscDateBase));
var MbscDateComponent = (function (_super) {
    __extends(MbscDateComponent, _super);
    function MbscDateComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscDateComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    __decorate([
        Input$1('icon'),
        __metadata("design:type", String)
    ], MbscDateComponent.prototype, "inputIcon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscDateComponent.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDateComponent.prototype, "name", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscDateComponent.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDateComponent.prototype, "errorMessage", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscDateComponent.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDateComponent.prototype, "placeholder", void 0);
    MbscDateComponent = __decorate([
        Component({
            selector: 'mbsc-date',
            exportAs: 'mobiscroll',
            template: INPUT_TEMPLATE
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])
    ], MbscDateComponent);
    return MbscDateComponent;
}(MbscDate));
var MbscTime = (function (_super) {
    __extends(MbscTime, _super);
    function MbscTime(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'time';
        return _this;
    }
    Object.defineProperty(MbscTime.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input$1('mbsc-time'),
        __metadata("design:type", Date),
        __metadata("design:paramtypes", [Date])
    ], MbscTime.prototype, "value", null);
    __decorate([
        Output('mbsc-timeChange'),
        __metadata("design:type", EventEmitter)
    ], MbscTime.prototype, "onChangeEmitter", void 0);
    MbscTime = __decorate([
        Directive({
            selector: '[mbsc-time]',
            exportAs: 'mobiscroll'
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])
    ], MbscTime);
    return MbscTime;
}(MbscDateBase));
var MbscTimeComponent = (function (_super) {
    __extends(MbscTimeComponent, _super);
    function MbscTimeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscTimeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    __decorate([
        Input$1('icon'),
        __metadata("design:type", String)
    ], MbscTimeComponent.prototype, "inputIcon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscTimeComponent.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscTimeComponent.prototype, "name", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscTimeComponent.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscTimeComponent.prototype, "errorMessage", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscTimeComponent.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscTimeComponent.prototype, "placeholder", void 0);
    MbscTimeComponent = __decorate([
        Component({
            selector: 'mbsc-time',
            exportAs: 'mobiscroll',
            template: INPUT_TEMPLATE
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])
    ], MbscTimeComponent);
    return MbscTimeComponent;
}(MbscTime));
var MbscDatetime = (function (_super) {
    __extends(MbscDatetime, _super);
    function MbscDatetime(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;
        _this.onChangeEmitter = new EventEmitter();
        _this.preset = 'datetime';
        return _this;
    }
    Object.defineProperty(MbscDatetime.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input$1('mbsc-datetime'),
        __metadata("design:type", Date),
        __metadata("design:paramtypes", [Date])
    ], MbscDatetime.prototype, "value", null);
    __decorate([
        Output('mbsc-datetimeChange'),
        __metadata("design:type", EventEmitter)
    ], MbscDatetime.prototype, "onChangeEmitter", void 0);
    MbscDatetime = __decorate([
        Directive({
            selector: '[mbsc-datetime]',
            exportAs: 'mobiscroll'
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])
    ], MbscDatetime);
    return MbscDatetime;
}(MbscDateBase));
var MbscDatetimeComponent = (function (_super) {
    __extends(MbscDatetimeComponent, _super);
    function MbscDatetimeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscDatetimeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    __decorate([
        Input$1('icon'),
        __metadata("design:type", String)
    ], MbscDatetimeComponent.prototype, "inputIcon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscDatetimeComponent.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeComponent.prototype, "name", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscDatetimeComponent.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeComponent.prototype, "errorMessage", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscDatetimeComponent.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscDatetimeComponent.prototype, "placeholder", void 0);
    MbscDatetimeComponent = __decorate([
        Component({
            selector: 'mbsc-datetime',
            exportAs: 'mobiscroll',
            template: INPUT_TEMPLATE
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])
    ], MbscDatetimeComponent);
    return MbscDatetimeComponent;
}(MbscDatetime));
var comp = [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent];
var MbscDatetimeModule = (function () {
    function MbscDatetimeModule() {
    }
    MbscDatetimeModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscDatetimeBaseModule, MbscInputModule],
            declarations: comp,
            exports: comp
        })
    ], MbscDatetimeModule);
    return MbscDatetimeModule;
}());

var Popup = function Popup(el, settings, inherit) {
  function addContent($m) {
    /* TRIAL */
    if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c')
    /* TRIALCOND */
    ) {
        $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());

        if (!$$1('.mbsc-w-p', $m).length) {
          $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');
        }
      }
  }

  var s,
      $prev,
      $elm = $$1(el),
      that = this; // Call the parent constructor

  Frame.call(this, el, settings, true);
  /* TRIALFUNC */

  that._generateContent = function () {
    return '';
  };

  that._markupReady = function ($m) {
    if (s.display != 'inline') {
      addContent($m);
    }
  };

  that._markupInserted = function ($m) {
    if (s.display == 'inline') {
      addContent($m);
    }

    $m.trigger('mbsc-enhance', [{
      theme: s.theme,
      lang: s.lang
    }]);
  };

  that._markupRemove = function () {
    $elm.hide();

    if ($prev && $prev.parent().length) {
      $prev.after($elm);
    }
  };

  that.__processSettings = function () {
    s = that.settings;
    that.buttons.ok = {
      text: s.okText,
      icon: s.okIcon,
      handler: 'set'
    };
    s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);

    if (!$prev && $elm.parent().length) {
      $prev = $$1(document.createComment('popup'));
      $elm.before($prev);
    }

    $elm.hide();
  }; // Constructor


  if (!inherit) {
    that.init();
  }
};
Popup.prototype = {
  _hasDef: true,
  _hasTheme: true,
  _hasContent: true,
  _hasLang: true,
  _responsive: true,
  _class: 'popup',
  _defaults: extend$1({}, Frame.prototype._defaults, {
    compClass: 'mbsc-wdg',
    okText: 'OK',
    headerText: false
  })
};
classes.Popup = Popup;
classes.Widget = Popup;
mobiscroll.themes.popup = mobiscroll.themes.frame;

// eslint-disable-next-line no-unused-vars
var Eventcalendar = Scroller;

function getHeight(el) {
  var style = getComputedStyle(el);
  return el.innerHeight || el.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
}

var defaults$4 = {
  view: {
    calendar: {
      type: 'month',
      popover: true
    }
  },
  // Localization
  allDayText: 'All-day',
  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'],
  eventText: 'event',
  eventsText: 'events',
  noEventsText: 'No events'
},
    overrides = {
  yearChange: false,
  weekDays: 'short'
};

presets.eventcalendar = function (inst, settings) {
  // Private functions
  // ---
  function processSettings() {
    var view = s.view,
        calendar = view.calendar,
        list = view.eventList,
        months = s.months,
        weeks = s.weeks;

    if (calendar) {
      if (calendar.type == 'week') {
        weeks = calendar.size || 1;
      } else if (calendar.size) {
        months = calendar.size;
      }

      isListOnly = false;
    } else {
      weeks = 0;
      isListOnly = true;
    }

    if (list) {
      listType = list.type;
      listSize = list.size || 1;
    }

    multiLabel = calendar && calendar.labels;
    scrollEventList = list && list.scrollable;
    showEventList = view.eventList;
    showEventBubble = s.eventBubble === undefined ? calendar && calendar.popover : s.eventBubble;
    s.weeks = weeks;
    s.months = months;
  }

  function updateTitle(firstDay, lastDay) {
    var title,
        monthIndex = (s.dateWheels || s.dateFormat).search(/m/i),
        yearIndex = (s.dateWheels || s.dateFormat).search(/y/i),
        firstYear = s.getYear(firstDay),
        firstMonth = s.getMonth(firstDay),
        lastYear = s.getYear(lastDay),
        lastMonth = s.getMonth(lastDay);

    inst._checkBtn($$1('.mbsc-cal-prev-m', $ctx), getDateOnly(firstDay) <= inst._minDate);

    inst._checkBtn($$1('.mbsc-cal-next-m', $ctx), getDateOnly(lastDay) >= inst._maxDate);

    if (listType == 'day') {
      title = formatDate(s.dateFormat, firstDay, s) + (listSize > 1 ? ' - ' + formatDate(s.dateFormat, lastDay, s) : '');
    } else if (listType == 'week') {
      title = formatDate(s.dateFormat, firstDay, s) + ' - ' + formatDate(s.dateFormat, lastDay, s);
    } else if (listType == 'month') {
      if (listSize == 1) {
        title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNames[firstMonth] : s.monthNames[firstMonth] + ' ' + firstYear;
      } else {
        title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNamesShort[firstMonth] + ' - ' + lastYear + ' ' + s.monthNamesShort[lastMonth] : s.monthNamesShort[firstMonth] + ' ' + firstYear + ' - ' + s.monthNamesShort[lastMonth] + ' ' + lastYear;
      }
    } else if (listType == 'year') {
      title = firstYear + (listSize > 1 ? " - " + lastYear : '');
    }

    $viewTitle.html(title);
  }

  function createEventList(firstDay, lastDay, eventObj) {
    var d,
        i,
        j,
        ev,
        $items,
        count = 0,
        allEvents = [],
        eventHtml = '',
        events = [];

    if (!eventObj) {
      eventObj = inst._prepareObj(eventList, firstDay, lastDay);
    }

    for (d = getDateOnly(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
      ev = eventObj[getDateOnly(d)];

      if (ev && ev.length) {
        events.push({
          d: new Date(d),
          list: sortEvents(ev)
        });
      }
    }

    if (events.length > 0) {
      for (i = 0; i < events.length; i++) {
        ev = events[i];
        eventHtml += '<div><div class="mbsc-lv-gr-title mbsc-event-day" data-full="' + getDateStr(ev.d) + '">' + formatDate(s.dateFormat, ev.d, s) + '</div>';

        for (j = 0; j < ev.list.length; j++) {
          var event = ev.list[j],
              start = event.start ? makeDate(event.start) : null,
              end = event.end ? makeDate(event.end) : null,
              color = event.color,
              isRepeating = DAY_OF_WEEK.test(event.d) || DAY_OF_MONTH.test(event.d),
              isMultiDay = start && end && !isSameDay(start, end),
              isFirstDay = isMultiDay ? isSameDay(start, ev.d) : true,
              isLastDay = isMultiDay ? isSameDay(end, ev.d) : true,
              dt = event.d ? isRepeating ? event.d : makeDate(event.d) : start,
              allDay = event.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay;
          allEvents.push({
            d: ev.d,
            e: event
          });
          eventHtml += '<div tabindex="0" role="button" class="mbsc-lv-item mbsc-lv-item-actionable" data-index="' + count + '"><div class="mbsc-event-time">' + (allDay ? s.allDayText : isFirstDay && dt && dt.getTime ? formatDate(s.timeFormat, dt) : isMultiDay && isLastDay ? s.toText : '') + (!allDay && isLastDay && end && end.getTime ? '<br/>' + formatDate(s.timeFormat, end) : '') + '</div>' + '<div class="mbsc-event-color"' + (color ? ' style="background:' + color + ';"' : '') + '></div>' + '<div class="mbsc-event-txt">' + event.text + '</div>'
          /* TRIAL */
          + '</div>';
          count++;
        }

        eventHtml += '</div>';
      }
    } else {
      eventHtml += '<div class="mbsc-lv-gr-title mbsc-event-empty"><div class="mbsc-empty"><h3>' + s.noEventsText + '</h3></div></div>';
    }

    preventScrollWatch++;
    $eventListCont.html('<div class="mbsc-lv mbsc-lv-v">' + eventHtml + '</div>').scrollTop(0);
    setTimeout(function () {
      // Need setTimeout since scroll listener is throtteled
      preventScrollWatch--;
    }, 150);
    $items = $$1('.mbsc-lv-item', $eventListCont); // Assign event click

    inst.tap($items, function (e) {
      var data = allEvents[$$1(this).attr('data-index')];
      trigger('onEventSelect', {
        domEvent: e,
        event: data.e,
        date: data.d
      });
    });
    handleFocus($items);
  }

  function handleFocus($items) {
    $items.on('keydown', function (ev) {
      if (ev.keyCode === 13 || ev.keyCode === 32) {
        this.click();
      }
    }).on('focus', function () {
      if (window.__mbscFocusVisible) {
        $$1(this).addClass('mbsc-focus');
      }
    }).on('blur', function () {
      $$1(this).removeClass('mbsc-focus');
    });
  }

  function createEventPopover() {
    if (popoverData) {
      var d = getDateOnly(popoverData.d),
          events = popoverData.events || eventObj[d],
          cell = popoverData.cell || $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full="' + getDateStr(d) + '"]', inst._markup)[0];
      showEvents(events, d, cell);
      popoverData = null;
    }
  }

  function formatDuration(start, end) {
    var lbl = s.labelsShort,
        time = end - start,
        seconds = Math.abs(time) / 1000,
        minutes = seconds / 60,
        hours = minutes / 60,
        days = hours / 24,
        years = days / 365;
    return seconds < 45 && Math.round(seconds) + ' ' + lbl[5].toLowerCase() || //seconds < 90 && '1 minute' ||
    minutes < 45 && Math.round(minutes) + ' ' + lbl[4].toLowerCase() || //minutes < 90 && '1 hour' ||
    hours < 24 && Math.round(hours) + ' ' + lbl[3].toLowerCase() || //hours < 42 && '1 day' ||
    days < 30 && Math.round(days) + ' ' + lbl[2].toLowerCase() || //days < 45 && '1 month' ||
    days < 365 && Math.round(days / 30) + ' ' + lbl[1].toLowerCase() || //years < 1.5 && '1 year' ||
    Math.round(years) + ' ' + lbl[0].toLowerCase();
  }

  function sortEvents(events) {
    return events.slice(0).sort(function (a, b) {
      var start1 = a.start ? makeDate(a.start) : null,
          start2 = b.start ? makeDate(b.start) : null,
          end1 = a.end ? makeDate(a.end) : null,
          end2 = b.end ? makeDate(b.end) : null,
          isRepeating1 = DAY_OF_WEEK.test(a.d) || DAY_OF_MONTH.test(a.d),
          isRepeating2 = DAY_OF_WEEK.test(b.d) || DAY_OF_MONTH.test(b.d),
          dt1 = a.d ? isRepeating1 ? a.d : makeDate(a.d) : start1,
          dt2 = b.d ? isRepeating2 ? b.d : makeDate(b.d) : start2,
          weight1 = !dt1.getTime ? 0 : start1 && end1 && start1.toDateString() !== end1.toDateString() ? 1 : a.allDay ? 2 : dt1.getTime(),
          weight2 = !dt2.getTime ? 0 : start2 && end2 && start2.toDateString() !== end2.toDateString() ? 1 : b.allDay ? 2 : dt2.getTime();

      if (weight1 == weight2) {
        return a.text > b.text ? 1 : -1;
      }

      return weight1 - weight2;
    });
  }

  function showEvents(events, d, cell) {
    if (events) {
      var $eventCont,
          $eventContInner,
          $eventScroller,
          eventScroller,
          $items,
          html = '<div class="mbsc-cal-event-list">';
      $eventCont = $$1('<div class="mbsc-cal-events ' + (s.eventBubbleClass || '') + '">' + '<div class="mbsc-cal-events-i"><div class="mbsc-cal-events-sc">' + '</div><div class="mbsc-sc-bar-c"><div class="mbsc-sc-bar"></div></div></div></div>');
      $eventContInner = $$1('.mbsc-cal-events-i', $eventCont);
      $eventScroller = $$1('.mbsc-cal-events-sc', $eventCont);
      inst.tap($eventContInner, function () {
        if (!eventScroller.scrolled) {
          hideEvents();
        }
      });
      popup = new Popup($eventCont[0], {
        display: 'bubble',
        theme: s.theme,
        lang: s.lang,
        context: s.context,
        buttons: [],
        anchor: cell,
        showOverlay: false,
        cssClass: 'mbsc-no-padding mbsc-cal-events-popup',
        onShow: function onShow() {
          eventScroller = new ScrollViewBase($eventContInner[0], {
            scrollbar: $$1('.mbsc-sc-bar-c', $eventCont),
            stopProp: false
          });
          $$1(document).on('click', hideEventsOnClick);
        },
        onClose: function onClose(event, inst) {
          inst.destroy();

          if (eventScroller) {
            eventScroller.destroy();
          }

          $$1(document).off('click', hideEventsOnClick);
        }
      }); // Store the popup on the instance, we need to destroy it in case of an option call or re-init

      inst._popup = popup;
      eventDay = cell;
      events = sortEvents(events);
      $$1.each(events, function (i, e) {
        var start = e.start ? makeDate(e.start) : null,
            end = e.end ? makeDate(e.end) : null,
            isRepeating = DAY_OF_WEEK.test(e.d) || DAY_OF_MONTH.test(e.d),
            dt = e.d ? isRepeating ? e.d : makeDate(e.d) : start,
            isMultiDay = start && end && !isSameDay(start, end),
            isFirstDay = isMultiDay ? isSameDay(start, d) : true,
            isLastDay = isMultiDay ? isSameDay(end, d) : true,
            allDay = e.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay,
            bg = e.color,
            ariaFrom = '',
            ariaTo = '',
            ariaLabel = $$1('<div>' + e.text + '</div>').text();

        if (dt.getTime) {
          ariaFrom = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, dt);
        }

        if (end) {
          ariaTo = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, end);
        }

        html += '<div tabindex="0" role="button" title="' + ariaLabel + '" aria-label="' + ariaLabel + (ariaFrom ? ', ' + s.fromText + ': ' + ariaFrom : '') + (ariaTo ? ', ' + s.toText + ': ' + ariaTo : '') + '" class="mbsc-cal-event mbsc-lv-item mbsc-lv-item-actionable">' + '<div class="mbsc-cal-event-color" style="' + (bg ? 'background:' + bg + ';' : '') + '"></div>' + '<div class="mbsc-cal-event-text">' + '<div class="mbsc-cal-event-time">' + (allDay ? s.allDayText : isFirstDay && dt.getTime ? formatDate(s.timeFormat, dt) : '') + '</div>' + e.text + '</div>' + (start && end && !e.allDay ? '<div class="mbsc-cal-event-dur">' + s.formatDuration(start, end, e) + '</div>' : '') + '</div>';
      });
      html += '</div>';
      $eventScroller.html(html);
      popup.show();
      trigger('onEventBubbleShow', {
        target: eventDay,
        eventList: $eventCont[0]
      });
      $items = $$1('.mbsc-cal-event', $eventScroller); // Assign event click

      inst.tap($items, function (e) {
        if (!eventScroller.scrolled) {
          trigger('onEventSelect', {
            domEvent: e,
            event: events[$$1(this).index()],
            date: d
          });
        }
      });
      handleFocus($items);
      hasEventBubble = true;
    }
  }

  function onScroll() {
    var d, top, parts;

    if (!preventScrollWatch) {
      $$1('.mbsc-event-day', this).each(function () {
        top = this.offsetTop - eventListCont.scrollTop;

        if (top >= 0 && top < 35) {
          parts = $$1(this).attr('data-full').split('-');
          d = adjustedDate(parts[0], parts[1] - 1, parts[2]);

          if (!isSameDay(d, currDay)) {
            preventEventScroll = true;
            inst.setVal(d);
          }

          return false;
        }
      });
    }
  }

  function hideEvents() {
    if (popup && hasEventBubble) {
      popup.hide();
    }

    eventDay = null;
    hasEventBubble = false;
  }

  function hideEventsOnClick(e) {
    if ($$1(e.target).closest('.mbsc-cal-day').length == 0) {
      hideEvents();
    }
  }

  function refresh() {
    hideEvents();
    inst.redraw();
  }

  function getFirstLast(day) {
    var y = s.getYear(day),
        m = s.getMonth(day),
        d = s.getDay(day);
    currFirstDay = day;

    if (listType == 'day') {
      currLastDay = s.getDate(y, m, d + listSize - 1);
    } else if (listType == 'week') {
      // get first day of week
      var diff,
          weekDay = currFirstDay.getDay();
      diff = d + s.firstDay - (s.firstDay - weekDay > 0 ? 7 : 0) - weekDay;
      currFirstDay = s.getDate(y, m, diff);
      currLastDay = s.getDate(y, m, diff + listSize * 7 - 1);
    } else if (listType == 'month') {
      currFirstDay = s.getDate(y, m, 1);
      currLastDay = s.getDate(y, m + listSize, 0);
    } else if (listType == 'year') {
      currFirstDay = s.getDate(y, 0, 1);
      currLastDay = s.getDate(y + listSize, 0, 0);
    }
  }

  function scrollToDay(d, prevAnim) {
    // Scroll to the day in the list, if any
    if (showEventList && !preventEventScroll) {
      var $day = $$1('.mbsc-event-day[data-full="' + getDateStr(d) + '"]', $eventListCont);

      if ($day.length) {
        preventScrollWatch++;
        smoothScroll(eventListCont, $day.parent()[0].offsetTop, prevAnim, function () {
          // Need setTimeout since scroll listener is throtteled
          setTimeout(function () {
            preventScrollWatch--;
          }, 150);
        });
      }
    }
  }

  function triggerLoading(change, render) {
    if (change) {
      trigger('onPageChange', {
        firstDay: currFirstDay,
        lastDay: currLastDay
      });
    }

    if (!render) {
      trigger('onPageLoading', {
        firstDay: currFirstDay,
        lastDay: currLastDay
      });
    }

    trigger('onPageLoaded', {
      firstDay: currFirstDay,
      lastDay: currLastDay
    });
  } // ---


  var base,
      $ctx,
      $eventListCont,
      $viewTitle,
      currDay,
      currFirstDay,
      currLastDay,
      eventDay,
      eventListCont,
      eventObj,
      hasEventBubble,
      isChanging,
      isLabelTap,
      isListOnly,
      listType,
      listSize,
      multiLabel,
      popoverData,
      popup,
      preventEventScroll,
      preventScrollAnim,
      prevFirstDay,
      prevLastDay,
      scrollEventList,
      showEventList,
      showEventBubble,
      showMore,
      elm = this,
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$4, orig, overrides, settings),
      preventScrollWatch = 0,
      eventID = 0,
      eventList = extend$1(true, [], s.data),
      firstLoad = true,
      trigger = inst.trigger; // Keep tracking events in settings,
  // otherwise changes will be lost on an eventual option call

  s.data = eventList;
  $$1.each(eventList, function (i, e) {
    if (e._id === undefined) {
      e._id = eventID++;
    }
  });
  processSettings();
  base = CalendarBase.call(this, inst); // Extended methods
  // ---

  inst._onGenMonth = function (start, end) {
    eventObj = inst._prepareObj(eventList, start, end);
    inst._labels = multiLabel ? eventObj : null;
  };

  inst._onRefresh = function (render) {
    preventScrollAnim = true; // Will re-create the list

    prevFirstDay = null;
    prevLastDay = null;

    if (isListOnly) {
      triggerLoading(false, render);
    }
  };

  inst._onSetDate = function (d, diff) {
    currDay = d;

    if (isListOnly) {
      if (!preventEventScroll && !isChanging) {
        getFirstLast(d);

        if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, currFirstDay) || !isSameDay(prevLastDay, currLastDay)) {
          triggerLoading(true);
        }
      }
    } else if (!diff && !isChanging) {
      hideEvents();

      if (showEventList && listType == 'day') {
        // List events for the day
        createEventList(d, d, eventObj);
      }

      if ((showEventBubble || showMore) && !isLabelTap) {
        // Show event popover
        createEventPopover();
      }

      scrollToDay(d);
    }

    preventEventScroll = false;
    showMore = false;
    isLabelTap = false;
  };

  inst._getDayProps = function (d) {
    var events = eventObj[d],
        ret = {
      events: events
    };

    if (!s.marked && !s.labels && !multiLabel) {
      if (events) {
        ret.background = events[0] && events[0].background;
        ret.marked = events; // For backward compatibility

        ret.markup = s.showEventCount ? '<div class="mbsc-cal-txt">' + events.length + ' ' + (events.length > 1 ? s.eventsText : s.eventText) + '</div>' : '<div class="mbsc-cal-marks"><div class="mbsc-cal-mark"></div></div>';
      } else {
        ret.markup = s.showEventCount ? '<div class="mbsc-cal-txt-ph"></div>' : '';
      }
    }

    return ret;
  };

  inst.addEvent = function (events) {
    var ret = [];
    events = extend$1(true, [], $$1.isArray(events) ? events : [events]);
    $$1.each(events, function (i, e) {
      if (e._id === undefined) {
        e._id = eventID++;
      }

      eventList.push(e);
      ret.push(e._id);
    });
    refresh();
    return ret;
  };

  inst.updateEvent = function (event) {
    $$1.each(eventList, function (j, e) {
      if (e._id === event._id) {
        eventList.splice(j, 1, event);
        return false;
      }
    });
    refresh();
  };

  inst.removeEvent = function (eids) {
    eids = $$1.isArray(eids) ? eids : [eids];
    $$1.each(eids, function (i, eid) {
      $$1.each(eventList, function (j, e) {
        if (e._id === eid) {
          eventList.splice(j, 1);
          return false;
        }
      });
    });
    refresh();
  };

  inst.getEvents = function (d) {
    var obj;

    if (d) {
      d.setHours(0, 0, 0, 0);
      obj = inst._prepareObj(eventList, d, d);
      return obj[d] ? sortEvents(obj[d]) : [];
    }

    return extend$1(true, [], eventList);
  };

  inst.setEvents = function (events) {
    var ret = [];
    s.data = eventList = extend$1(true, [], events);
    $$1.each(eventList, function (i, e) {
      if (e._id === undefined) {
        e._id = eventID++;
      }

      ret.push(e._id);
    });
    refresh();
    return ret;
  };

  inst.navigate = function (d, anim, pop) {
    d = makeDate(d, inst._format, s);
    popoverData = pop ? {
      d: d
    } : null;
    inst.setVal(d, true, true, false, anim ? 200 : 0);
  }; // ---


  return extend$1({}, base, {
    multiLabel: multiLabel,
    headerText: false,
    buttons: s.display !== 'inline' ? ['close'] : s.buttons,
    compClass: 'mbsc-ev-cal mbsc-calendar mbsc-dt mbsc-sc',
    formatDuration: formatDuration,
    onMarkupReady: function onMarkupReady(ev, inst) {
      $ctx = $$1(ev.target);
      currDay = inst.getDate(true);

      if (showEventList) {
        $eventListCont = $$1('<div class="mbsc-lv-cont mbsc-lv-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme : '') + (scrollEventList ? ' mbsc-event-list-h' : '') + ' mbsc-event-list"></div>').appendTo($$1('.mbsc-fr-w', $ctx));
        $eventListCont.on('scroll', throttle(onScroll));
        eventListCont = $eventListCont[0];
      }

      base.onMarkupReady.call(this, ev);
      $viewTitle = $$1('.mbsc-cal-month', $ctx);
      hasEventBubble = false;
      getFirstLast(currDay);

      if (showEventList && isListOnly) {
        triggerLoading(); // Init navigation arrows

        createStepper($$1('.mbsc-cal-btn', $ctx), function (i, diff) {
          var y = s.getYear(currFirstDay),
              m = s.getMonth(currFirstDay),
              d = s.getDay(currFirstDay);

          if (listType == 'day') {
            currFirstDay = s.getDate(y, m, d + diff * listSize);
            currLastDay = s.getDate(y, m, d + (diff + 1) * listSize - 1);
          } else if (listType == 'week') {
            currFirstDay = s.getDate(y, m, d + diff * listSize * 7);
            currLastDay = s.getDate(y, m, d + (diff + 1) * listSize * 7 - 1);
          } else if (listType == 'month') {
            currFirstDay = s.getDate(y, m + diff * listSize, 1);
            currLastDay = s.getDate(y, m + (diff + 1) * listSize, 0);
          } else if (listType == 'year') {
            currFirstDay = s.getDate(y + diff * listSize, 0, 1);
            currLastDay = s.getDate(y + (diff + 1) * listSize, 0, 0);
          }

          triggerLoading(true);
        }, 200);
      }

      addWindowFocus();
    },
    onDayChange: function onDayChange(day) {
      var cell = day.target,
          show = cell !== eventDay;

      if (show) {
        showMore = showEventBubble !== false && $$1('.mbsc-cal-txt-more', cell).length;
        popoverData = {
          d: day.date,
          cell: s.outerMonthChange && $$1(cell).hasClass('mbsc-cal-day-diff') ? null : cell,
          events: day.events
        };
      }
    },
    onLabelTap: function onLabelTap(ev) {
      if (ev.label) {
        trigger('onEventSelect', {
          domEvent: ev.domEvent,
          event: ev.label,
          date: ev.date
        });
        isLabelTap = true;
      }
    },
    onPageChange: function onPageChange(ev) {
      hideEvents();
      isChanging = true;

      if (!inst._isSetDate) {
        inst.setVal(ev.firstDay);
      }
    },
    onPageLoaded: function onPageLoaded(ev) {
      var firstDay = ev.firstDay,
          lastDay = ev.lastDay;

      if (showEventList) {
        if (isListOnly) {
          if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, firstDay) || !isSameDay(prevLastDay, lastDay)) {
            prevFirstDay = firstDay;
            prevLastDay = lastDay;
            createEventList(firstDay, lastDay);
            updateTitle(firstDay, lastDay);
          }
        } else {
          if (listType == 'month') {
            // month view
            lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay) + listSize, 0);
          } else if (listType == 'week') {
            // week view
            lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay), s.getDay(firstDay) + listSize * 7 - 1);
          } else {
            firstDay = inst.getVal(true);
            lastDay = firstDay;
          }

          createEventList(firstDay, lastDay, eventObj);
        }

        if (!firstLoad && !isSameDay(currDay, firstDay)) {
          scrollToDay(currDay, preventScrollAnim);
          preventScrollAnim = false;
        }
      }

      if (showEventBubble) {
        createEventPopover();
      }

      isChanging = false;
    },
    onPosition: function onPosition(ev) {
      base.onPosition.call(this, ev);

      if (popup) {
        popup.position();
      }

      if (showEventList && scrollEventList) {
        $eventListCont.addClass('mbsc-event-list-h');
        var context = s.display == 'inline' ? elm.parentNode : window,
            availableHeight = getHeight(context),
            listHeight = availableHeight - ev.popup.offsetHeight;
        eventListCont.style.height = listHeight > 200 ? listHeight + 'px' : '';
        $eventListCont.removeClass('mbsc-event-list-h');

        if (firstLoad && listHeight) {
          scrollToDay(currDay, true);
          firstLoad = false;
        }
      }
    },
    onHide: function onHide() {
      base.onHide.call(this); // Destroy the popup stored on the instance,
      // the local variable is lost in case of option call or re-init

      if (inst._popup) {
        inst._popup.destroy();
      }

      removeWindowFocus();
    }
  });
};

var MbscEventcalendar = (function (_super) {
    __extends(MbscEventcalendar, _super);
    function MbscEventcalendar(initialElem, zone, optionService) {
        var _this = _super.call(this, initialElem, zone, null, null, null) || this;
        _this.optionService = optionService;
        _this.onEventSelect = new EventEmitter();
        _this.onCellHoverIn = new EventEmitter();
        _this.onCellHoverOut = new EventEmitter();
        _this.onDayChange = new EventEmitter();
        _this.onSetDate = new EventEmitter();
        _this.options = {};
        return _this;
    }
    MbscEventcalendar.prototype.refreshData = function (newData) {
        this.instance.setEvents(newData);
    };
    MbscEventcalendar.prototype.initControl = function () {
        var options = extend$1({ preset: 'eventcalendar' }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);
        this.instance = new Eventcalendar(this.element, options);
    };
    MbscEventcalendar.prototype.ngOnInit = function () {
        this.cloneDictionary.data = [];
        _super.prototype.ngOnInit.call(this);
    };
    MbscEventcalendar.prototype.setNewValue = function () { };
    __decorate([
        Input$1('mbsc-data'),
        __metadata("design:type", Array)
    ], MbscEventcalendar.prototype, "data", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscEventcalendar.prototype, "layout", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscEventcalendar.prototype, "showEventCount", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscEventcalendar.prototype, "eventBubble", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Function)
    ], MbscEventcalendar.prototype, "formatDuration", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscEventcalendar.prototype, "view", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscEventcalendar.prototype, "allDayText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscEventcalendar.prototype, "eventText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscEventcalendar.prototype, "eventsText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscEventcalendar.prototype, "labelsShort", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscEventcalendar.prototype, "noEventsText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscEventcalendar.prototype, "onEventSelect", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscEventcalendar.prototype, "onCellHoverIn", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscEventcalendar.prototype, "onCellHoverOut", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscEventcalendar.prototype, "onDayChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscEventcalendar.prototype, "onSetDate", void 0);
    __decorate([
        Input$1('mbsc-options'),
        __metadata("design:type", Object)
    ], MbscEventcalendar.prototype, "options", void 0);
    MbscEventcalendar = __decorate([
        Directive({
            selector: '[mbsc-eventcalendar]',
            exportAs: 'mobiscroll'
        }),
        __param(2, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, MbscOptionsService])
    ], MbscEventcalendar);
    return MbscEventcalendar;
}(MbscCalBase));
var MbscEventcalendarComponent = (function (_super) {
    __extends(MbscEventcalendarComponent, _super);
    function MbscEventcalendarComponent(initialElem, zone, optionService) {
        var _this = _super.call(this, initialElem, zone, optionService) || this;
        _this.options = {};
        return _this;
    }
    MbscEventcalendarComponent.prototype.ngOnInit = function () {
        var display = this.options && this.options.display || this.display;
        if (!display) {
            this.display = 'inline';
            this.inlineOptionsObj.display = 'inline';
        }
        _super.prototype.ngOnInit.call(this);
    };
    MbscEventcalendarComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscEventcalendarComponent.prototype, "data", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscEventcalendarComponent.prototype, "options", void 0);
    MbscEventcalendarComponent = __decorate([
        Component({
            selector: 'mbsc-eventcalendar',
            exportAs: 'mobiscroll',
            template: '<div></div>'
        }),
        __param(2, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, MbscOptionsService])
    ], MbscEventcalendarComponent);
    return MbscEventcalendarComponent;
}(MbscEventcalendar));
var MbscEventcalendarModule = (function () {
    function MbscEventcalendarModule() {
    }
    MbscEventcalendarModule = __decorate([
        NgModule({
            imports: [MbscCalBaseModule],
            declarations: [MbscEventcalendar, MbscEventcalendarComponent],
            exports: [MbscEventcalendar, MbscEventcalendarComponent]
        })
    ], MbscEventcalendarModule);
    return MbscEventcalendarModule;
}());

var SELECTED_CLASS = 'mbsc-selected';
var ACTIVE_CLASS = 'mbsc-lv-item-active';
var confirms,
    halfBorder$1 = os == 'ios' && majorVersion > 7,
    guid = 1,
    transp = 'transparent';
var ListView = function ListView(elem, settings) {
  var action,
      actionWidth,
      activeTimer,
      animPos,
      cancel,
      confirmItem,
      confirmIndex,
      cont,
      cont0,
      currIndex,
      currList,
      currPh,
      currParent,
      currSiblings,
      currStage,
      currStageIdx,
      debounce,
      demoMode,
      disabled,
      diffX,
      diffY,
      dropDown,
      dropUp,
      dragged,
      dummyCont,
      endTimer,
      endX,
      endY,
      event,
      fill,
      found,
      groupHeader,
      hadEnhance,
      handlePos,
      hasContext,
      handleDiv,
      hoverDir,
      hoverItem,
      hoverItemOpened,
      hoverTime,
      hoverTimeout,
      hoverTimer,
      htmlLeft,
      htmlRight,
      icon,
      iconc,
      stagec,
      isClick,
      isLoading,
      isTouch,
      itemw,
      item,
      itemHeight,
      itemIndex,
      itemNode,
      itemSelector,
      itemTop,
      listNode,
      listSelector,
      loading,
      maxDrag,
      minDrag,
      multic,
      multiple,
      nextItem,
      nextOffset,
      nextStage,
      nextItems,
      onScrollThrottle,
      onScrollDebounce,
      prevClick,
      preventHover,
      preventTimer,
      prevItems,
      placeholder,
      prevItem,
      prevOffset,
      prevStage,
      quickSwipe,
      rafID,
      rafRunning,
      s,
      scroll,
      selectable,
      simulating,
      slideCont,
      stageNr,
      stages,
      startPos,
      startTime,
      startX,
      startY,
      style,
      swipe,
      swipeInterval,
      swipeTimeout,
      tapHighlight,
      text,
      timer,
      type,
      types,
      undoRef,
      undoAnim,
      wnd,
      wnd0,
      wndHeight,
      wndScroll,
      wndTop,
      that = this,
      e = elem,
      elm = $$1(e),
      transition = 0,
      slideLevel = 0,
      startTop = 0,
      stageObj = {},
      actionQueue = {},
      treeMap = {};

  function onActionStart() {
    quickSwipe = false;
    prevClick = false;
    animPos = 0;
    startPos = 0;
    startTime = new Date();
    itemw = currList.width();
    currSiblings = getChildren(currList);
    itemIndex = currSiblings.index(item);
    itemHeight = item[0].offsetHeight;
    startTop = item[0].offsetTop;
    type = types[item.attr('data-type') || 'defaults'];
    stages = type.stages;
  }

  function onStart(ev) {
    var itm;
    var target = closest(cont0, ev.target, '.mbsc-lv-item');

    if (!target || !cont0.contains(target)) {
      return;
    }

    if (ev.type === 'touchstart') {
      cont.removeClass('mbsc-no-touch');
      preventHover = true;
      clearTimeout(preventTimer);
    }

    if (testTouch(ev, target) && !action && !transition && !confirms && !undoing
    /* TRIALCOND */
    ) {
        action = true;
        cancel = true;
        isClick = false;
        isTouch = ev.type === 'touchstart';
        startX = getCoord(ev, 'X');
        startY = getCoord(ev, 'Y');
        diffX = 0;
        diffY = 0;
        item = $$1(target);
        itm = item; // Local reference

        onActionStart();
        tapHighlight = type.actionable || item.hasClass('mbsc-lv-parent') || item.hasClass('mbsc-lv-back');
        itemTop = item.offset().top;

        if (tapHighlight) {
          activeTimer = setTimeout(function () {
            itm.addClass(isTouch ? ACTIVE_CLASS : '');
            event('onItemActivate', {
              target: itm[0],
              domEvent: ev
            });
          }, 120);
        }

        if (that.sortable && !item.hasClass('mbsc-lv-back')) {
          if (!that.sortable.group) {
            nextItems = item.nextUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');
            prevItems = item.prevUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');
          }

          minDrag = (!that.sortable.group ? prevItems.length ? prevItems.eq(-1) : item : currList.children(itemSelector).eq(0))[0].offsetTop - startTop;
          maxDrag = (!that.sortable.group ? nextItems.length ? nextItems.eq(-1) : item : currList.children(itemSelector).eq(-1))[0].offsetTop - startTop;

          if (that.sortable.handle) {
            if ($$1(ev.target).hasClass('mbsc-lv-handle')) {
              clearTimeout(activeTimer);

              if (jsPrefix === 'Moz') {
                // On FF we need to prevent touchstart to disable scroll
                ev.preventDefault();
                onSortStart();
              } else {
                timer = setTimeout(function () {
                  onSortStart();
                }, 100);
              }
            }
          } else {
            timer = setTimeout(function () {
              fill.appendTo(item);
              fill[0].style[jsPrefix + 'Animation'] = 'mbsc-lv-fill ' + (s.sortDelay - 100) + 'ms linear';
              clearTimeout(endTimer);
              clearTimeout(activeTimer);
              cancel = false;
              timer = setTimeout(function () {
                fill[0].style[jsPrefix + 'Animation'] = '';
                onSortStart();
              }, s.sortDelay - 80);
            }, 80);
          }
        }

        if (ev.type == 'mousedown') {
          $$1(document).on('mousemove', onMove).on('mouseup', onEnd);
        }
      }
  }

  function onMove(ev) {
    var sortChange = false,
        dropChange = true,
        prevPos = animPos;

    if (action) {
      endX = getCoord(ev, 'X');
      endY = getCoord(ev, 'Y');
      diffX = endX - startX;
      diffY = endY - startY;
      clearTimeout(endTimer);

      if (!dragged && !swipe && !scroll && !item.hasClass('mbsc-lv-back')) {
        if (Math.abs(diffY) > 10) {
          // It's a scroll
          scroll = true;
          onEnd(extend$1({}, ev, {
            type: ev.type == 'mousemove' ? 'mouseup' : 'touchend'
          }));
          clearTimeout(activeTimer);
        } else if (Math.abs(diffX) > 7) {
          // It's a swipe
          onSwipeStart();
        }
      }

      if (swipe) {
        ev.preventDefault();
        animPos = diffX / itemw * 100;
        onSwipeMove(prevPos);
      } else if (dragged) {
        ev.preventDefault();
        var scrolled,
            st = wnd.scrollTop(),
            diff = Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag)),
            top = hasContext ? itemTop - wndTop + st - wndScroll : itemTop; // Check if scroll is needed

        if (wndHeight + st < top + diff + itemHeight) {
          wnd.scrollTop(top + diff - wndHeight + itemHeight);
          scrolled = true;
        } else if (top + diff < st) {
          wnd.scrollTop(top + diff);
          scrolled = true;
        } // Update scroll values if window was scrolled


        if (scrolled) {
          wndScroll += wnd.scrollTop() - st;
        } // Check overlap with next item


        if (nextOffset) {
          // If subtree exists, drop element on subtree at 1/4, change sort order at 3/4 overlap
          if (that.sortable.multiLevel && nextItem.hasClass('mbsc-lv-parent')) {
            if (startTop + itemHeight / 4 + diff > nextOffset) {
              sortChange = true;
            } else if (startTop + itemHeight - itemHeight / 4 + diff > nextOffset) {
              dropDown = nextItem.addClass('mbsc-lv-item-hl');
              dropChange = false;
            } // Check 1/2 overlap

          } else if (startTop + itemHeight / 2 + diff > nextOffset) {
            // If over back button, highlight to drop to parent level
            if (nextItem.hasClass('mbsc-lv-back')) {
              if (that.sortable.multiLevel) {
                dropUp = nextItem.addClass('mbsc-lv-item-hl');
                dropChange = false;
              }
            } else {
              sortChange = true;
            }
          }

          if (sortChange) {
            placeholder.insertAfter(nextItem);
            prevItem = nextItem;
            nextItem = getNextPrev(nextItem, 'next');
            prevOffset = nextOffset;
            nextOffset = nextItem.length && nextItem[0].offsetTop;
            currIndex++;
          }
        } // Check overlap with prev item


        if (!sortChange && prevOffset) {
          // If subtree exists, drop element on subtree at 1/3, change sort order at 2/3 overlap
          if (that.sortable.multiLevel && prevItem.hasClass('mbsc-lv-parent')) {
            if (startTop + itemHeight - itemHeight / 4 + diff < prevOffset) {
              sortChange = true;
            } else if (startTop + itemHeight / 4 + diff < prevOffset) {
              dropDown = prevItem.addClass('mbsc-lv-item-hl');
              dropChange = false;
            } // Check 1/2 overlap

          } else if (startTop + itemHeight / 2 + diff < prevOffset) {
            // If over back button, highlight to drop to parent level
            if (prevItem.hasClass('mbsc-lv-back')) {
              if (that.sortable.multiLevel) {
                dropUp = prevItem.addClass('mbsc-lv-item-hl');
                dropChange = false;
              }
            } else {
              sortChange = true;
            }
          }

          if (sortChange) {
            placeholder.insertBefore(prevItem);
            nextItem = prevItem;
            prevItem = getNextPrev(prevItem, 'prev');
            nextOffset = prevOffset;
            prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;
            currIndex--;
          }
        }

        if (dropChange) {
          if (dropDown) {
            dropDown.removeClass('mbsc-lv-item-hl');
            dropDown = false;
          }

          if (dropUp) {
            dropUp.removeClass('mbsc-lv-item-hl');
            dropUp = false;
          }
        }

        if (sortChange) {
          event('onSortChange', {
            target: item[0],
            index: currIndex
          });
        }

        drag(item, diff);
        event('onSort', {
          target: item[0],
          index: currIndex
        });
      } else if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
        // Cancel dragstart if movement is > 5px
        stopTimer();
      }
    }
  }

  function onEnd(ev) {
    var dist,
        map,
        parent,
        itm = item;

    if (action) {
      action = false;
      stopTimer();

      if (ev.type == 'mouseup') {
        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);
      }

      if (!scroll) {
        preventTimer = setTimeout(function () {
          preventHover = false;
        }, 300);
      }

      if (swipe || scroll || dragged) {
        prevClick = true;
      }

      if (swipe) {
        onSwipeEnd();
      } else if (dragged) {
        // Sort end
        parent = currList;

        if (dropDown) {
          resetItem(item.detach());
          map = treeMap[dropDown.attr('data-ref')];
          currIndex = getChildren(map.child).length;
          dropDown.removeClass('mbsc-lv-item-hl');

          if (s.navigateOnDrop) {
            navigate(dropDown, function () {
              that.add(null, item, null, null, dropDown, true);
              scrollToItem(item);
              onSortEnd(item, itemIndex, parent, true);
            });
          } else {
            that.add(null, item, null, null, dropDown, true);
            onSortEnd(item, itemIndex, parent, true);
          }
        } else if (dropUp) {
          resetItem(item.detach());
          map = treeMap[dropUp.attr('data-back')];
          currIndex = getChildren(map.parent).index(map.item) + 1;
          dropUp.removeClass('mbsc-lv-item-hl');

          if (s.navigateOnDrop) {
            navigate(dropUp, function () {
              that.add(null, item, currIndex, null, currList, true);
              scrollToItem(item);
              onSortEnd(item, itemIndex, parent, true);
            });
          } else {
            that.add(null, item, currIndex, null, map.parent, true);
            onSortEnd(item, itemIndex, parent, true);
          }
        } else {
          dist = placeholder[0].offsetTop - startTop; // Animate item to its place

          drag(item, dist, Math.abs(dist - Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag))) * 6, function () {
            resetItem(item);
            item.insertBefore(placeholder);
            onSortEnd(item, itemIndex, parent, currIndex !== itemIndex);
          });
        }

        dragged = false;
      } else if (!scroll && Math.abs(diffX) < 5 && Math.abs(diffY) < 5) {
        // Tap
        isClick = true; // Trigger click and activate target, if it's a form control

        if (ev.type === 'touchend' && s.tap) {
          activateControl(ev.target, getControlType($$1(ev.target)), ev);
        }
      }

      clearTimeout(activeTimer);
      setTimeout(function () {
        itm.removeClass(ACTIVE_CLASS);
        event('onItemDeactivate', {
          target: itm[0]
        });
      }, 100);
      scroll = false;
      currStage = null;
    }
  }

  function onClick(ev) {
    var isSelected, ret;

    if (isClick) {
      isSelected = item.attr('data-selected') == 'true';

      if (type.tap) {
        ret = type.tap.call(e, {
          target: item,
          index: itemIndex,
          domEvent: ev
        }, that);
      }

      if (tapHighlight && !item.hasClass(ACTIVE_CLASS)) {
        item.addClass(isTouch ? ACTIVE_CLASS : '');
        event('onItemActivate', {
          target: item[0],
          domEvent: ev
        });
      } // select or deselect item on tap


      if (selectable) {
        if (multiple) {
          if (isSelected) {
            deselectItem(item);
          } else {
            selectItem(item);
          }
        } else {
          deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));
          selectItem(item);
        }
      }

      ret = event('onItemTap', {
        target: item[0],
        index: itemIndex,
        domEvent: ev,
        selected: isSelected
      });

      if (ret !== false) {
        navigate(item);
      }
    }
  }

  function onIconStart(ev) {
    var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');

    if (!target) {
      return;
    }

    if (!demoMode) {
      ev.stopPropagation();
      ev.preventDefault();
    }

    startX = getCoord(ev, 'X');
    startY = getCoord(ev, 'Y');
  }

  function onSwipeStart() {
    swipe = valueOrFunc(type.swipe, {
      target: item[0],
      index: itemIndex,
      direction: diffX > 0 ? 'right' : 'left'
    });

    if (swipe) {
      stopTimer();
      clearTimeout(activeTimer);

      if (type.actions) {
        // Get the width of the action menu from settings
        // Numeric values are converted to string, because 0 is also accepted, we convert back to number at the end
        actionWidth = getActionWidth(type, diffX); // Show action icons and set width

        multic.html(type.icons).show().children().css('width', actionWidth + '%'); // Hide stage icons

        iconc.hide(); // Set disabled actions

        $$1('.mbsc-lv-ic-m', stagec).removeClass('mbsc-lv-ic-disabled');
        $$1(type.leftMenu).each(disableActions);
        $$1(type.rightMenu).each(disableActions);
      } else {
        iconc.show();
        multic.hide();
        currStageIdx = type.start;
        currStage = stages[currStageIdx];
        prevStage = stages[currStageIdx - 1];
        nextStage = stages[currStageIdx + 1];
      }

      item.addClass('mbsc-lv-item-swiping').removeClass(ACTIVE_CLASS);
      text.css('line-height', itemHeight + 'px');
      stagec.css({
        top: startTop,
        height: itemHeight,
        backgroundColor: getFirstColor(diffX)
      }).addClass('mbsc-lv-stage-c-v').appendTo(currList.parent());

      if (s.iconSlide) {
        item.append(iconc);
      }

      event('onSlideStart', {
        target: item[0],
        index: itemIndex
      });
    }
  }

  function onSwipeMove(prevPos) {
    var stageChanged = false;

    if (!rafRunning) {
      if (type.actions) {
        stagec.attr('class', 'mbsc-lv-stage-c-v mbsc-lv-stage-c mbsc-lv-' + (animPos < 0 ? 'right' : 'left'));
      } else {
        if (prevStage && (animPos < 0 ? animPos <= prevStage.percent : animPos < currStage.percent)) {
          currStageIdx--;
          nextStage = currStage;
          currStage = prevStage;
          prevStage = stages[currStageIdx - 1];
          stageChanged = true;
        } else if (nextStage && (animPos < 0 ? animPos > currStage.percent : animPos >= nextStage.percent)) {
          currStageIdx++;
          prevStage = currStage;
          currStage = nextStage;
          nextStage = stages[currStageIdx + 1];
          stageChanged = true;
        }

        if (currStage) {
          if (stageChanged || animPos > 0 == prevPos <= 0) {
            // Also need to update stage background if swipe direction changed
            setStageProps(currStage, s.iconSlide);
          }

          if (stageChanged) {
            event('onStageChange', {
              target: item[0],
              index: itemIndex,
              stage: currStage
            });
          }
        }
      }

      if (!simulating) {
        rafRunning = true;
        rafID = raf(slideMove);
      }
    }
  }

  function onSwipeEnd(callback) {
    function onCloseActions(ev) {
      var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');

      if (!target) {
        ev.preventDefault();
        slideEnd(item, true, callback);
      }
    }

    var quickSwipeLeft,
        quickSwipeRight,
        timeDiff,
        itm = item[0],
        pending = false,
        revert = true;
    rafc(rafID);
    rafRunning = false; // We need an additional call to set the position in case when
    // requestAnimationFrame did not call it at least once
    // E.g. in a case of a quick swipe animation frame is
    // cancelled before the first call

    if (!simulating) {
      slideMove();
    }

    if (type.actions) {
      if (Math.abs(animPos) > 10 && actionWidth) {
        slide(item, animPos < 0 ? -actionWidth : actionWidth, 200);
        pending = true;
        confirms = true;
        confirmItem = item;
        confirmIndex = itemIndex;

        if (itm.__mbscOff) {
          itm.__mbscOff();
        }

        listen(document, 'touchstart', onCloseActions, {
          passive: false
        });
        listen(document, 'mousedown', onCloseActions);

        itm.__mbscOff = function () {
          unlisten(document, 'touchstart', onCloseActions, {
            passive: false
          });
          unlisten(document, 'mousedown', onCloseActions);
          delete itm.__mbscOff;
        };
      }
    } else if (animPos) {
      if (s.quickSwipe && !simulating) {
        timeDiff = new Date() - startTime;
        quickSwipeLeft = timeDiff < 300 && diffX < -50;
        quickSwipeRight = timeDiff < 300 && diffX > 50;

        if (quickSwipeLeft) {
          quickSwipe = true;
          currStage = type.left;
          setStageProps(currStage, s.iconSlide);
        } else if (quickSwipeRight) {
          quickSwipe = true;
          currStage = type.right;
          setStageProps(currStage, s.iconSlide);
        }
      }

      if (currStage && currStage.action) {
        disabled = valueOrFunc(currStage.disabled, {
          target: item[0],
          index: itemIndex
        });

        if (!disabled) {
          pending = true;
          confirms = simulating || valueOrFunc(currStage.confirm, {
            target: item[0],
            index: itemIndex
          });

          if (confirms) {
            // Slide to text + icon width
            slide(item, (animPos < 0 ? -1 : 1) * iconc[0].offsetWidth * 100 / itemw, 200, true); // Tap to confirm

            setConfirm(currStage, item, itemIndex, false, callback);
          } else {
            runAction(currStage, item, itemIndex, callback);
          }
        }
      }
    }

    if (!pending) {
      slideEnd(item, revert, callback);
    }

    swipe = false;
  }

  function onSortStart() {
    dragged = true;
    dropDown = false;
    dropUp = false;
    wndScroll = 0;
    currIndex = itemIndex;

    if (s.vibrate) {
      vibrate();
    }

    nextItem = getNextPrev(item, 'next');
    nextOffset = nextItem.length && nextItem[0].offsetTop;
    prevItem = getNextPrev(item, 'prev');
    prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;
    placeholder.height(itemHeight).insertAfter(item); // Item is removed from original list, otherwise messes up striped layout

    item.css({
      top: startTop
    }).addClass('mbsc-lv-item-dragging').removeClass(ACTIVE_CLASS).appendTo(dummyCont);
    event('onSortStart', {
      target: item[0],
      index: currIndex
    });
  }

  function onSortEnd(item, itemIndex, parent, update) {
    item.removeClass('mbsc-lv-item-dragging');
    placeholder.remove();
    event('onSortEnd', {
      target: item[0],
      index: currIndex
    });

    if (s.vibrate) {
      vibrate();
    }

    if (update) {
      that.addUndoAction(function (next) {
        that.move(item, itemIndex, null, next, parent, true);
      }, true);
      event('onSortUpdate', {
        target: item[0],
        index: currIndex
      });
    }
  }

  function onMouseLeave() {
    if (!preventHover) {
      clearTimeout(hoverTimer);

      if (confirms) {
        trigger(document, 'touchstart');
      }

      if (hoverItemOpened) {
        that.close(hoverItem, hoverTime);
        hoverItemOpened = false;
        hoverItem = null;
      }
    }
  }

  function onResize() {
    clearTimeout(debounce);
    debounce = setTimeout(function () {
      wndHeight = wnd0.innerHeight || wnd.innerHeight();
      wndTop = hasContext ? wnd.offset().top : 0;

      if (action) {
        // Reposition stage background, icon and text
        startTop = item[0].offsetTop;
        itemHeight = item[0].offsetHeight;
        stagec.css({
          top: startTop,
          height: itemHeight
        });
      }
    }, 200);
  }

  function onListClick(ev) {
    if (prevClick) {
      ev.stopPropagation();
      ev.preventDefault();
      prevClick = false;
    }
  }

  function onScrollBottom() {
    if (!isLoading) {
      clearTimeout(onScrollDebounce);
      onScrollDebounce = setTimeout(function () {
        var height = hasContext ? wnd0.getBoundingClientRect().top + wnd.innerHeight() : window.innerHeight,
            reachedBottom = loading[0].getBoundingClientRect().top - 3 < height;

        if (!isLoading && reachedBottom) {
          event('onListEnd');
        }
      }, 250);
    }
  }

  function onScroll() {
    if (dragged || !action) {
      var group,
          st = wnd.scrollTop(),
          elmTop = elm.offset().top,
          elmHeight = elm[0].offsetHeight,
          wndTop = hasContext ? wnd.offset().top : st;
      $$1('.mbsc-lv-gr-title', elm).each(function (i, v) {
        if ($$1(v).offset().top < wndTop) {
          group = v;
        }
      });

      if (elmTop < wndTop && elmTop + elmHeight > wndTop) {
        groupHeader.show().empty().append($$1(group).clone());
      } else {
        groupHeader.hide();
      }
    }
  }

  function disableActions(i, v) {
    if (valueOrFunc(v.disabled, {
      target: item[0],
      index: itemIndex
    })) {
      $$1('.mbsc-ic-' + v.icon, stagec).addClass('mbsc-lv-ic-disabled');
    }
  }

  function runAction(stage, item, index, callback) {
    var revert,
        undoStage = {
      icon: 'undo2',
      text: s.undoText,
      action: function action() {
        that.undo();
      }
    };

    if (stage.undo) {
      that.startActionTrack(); // Add user defined undo

      if ($$1.isFunction(stage.undo)) {
        that.addUndoAction(function () {
          stage.undo.call(e, {
            target: item[0],
            index: index
          }, that);
        });
      } // Remember the item where the undo is displayed


      undoRef = item.attr('data-ref');
    }

    revert = stage.action.call(e, {
      target: item[0],
      index: index
    }, that);

    if (stage.undo) {
      that.endActionTrack();

      if (revert !== false) {
        slide(item, +item.attr('data-pos') < 0 ? -100 : 100, 200);
      }

      placeholder.height(itemHeight).insertAfter(item);
      item.css('top', startTop).addClass('mbsc-lv-item-undo');
      multic.hide();
      iconc.show();
      stagec.append(iconc);
      setStageProps(undoStage);
      setConfirm(undoStage, item, index, true, callback);
    } else {
      slideEnd(item, revert, callback);
    }
  }

  function setConfirm(stage, item, index, ph, callback) {
    function onActionCancel(ev) {
      ev.preventDefault();

      if (ph) {
        cleanUndo(item);
      }

      slideEnd(item, true, callback);
    }

    function onActionConfirmStart(ev) {
      ev.stopPropagation();
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
    }

    function onActionConfirmEnd(ev) {
      ev.preventDefault();

      if (ev.type === 'touchend') {
        preventClick();
      } // If movement is less than 10px, it's a tap


      if (Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {
        runAction(stage, item, index, callback);

        if (ph) {
          undoAnim = null;
          cleanUndo(item);
        }
      }
    }

    var startX,
        startY,
        itm = item[0];
    confirms = true;

    if (itm.__mbscOff) {
      itm.__mbscOff();
    }

    listen(document, 'touchstart', onActionCancel, {
      passive: false
    });
    listen(document, 'mousedown', onActionCancel);

    if (!demoMode) {
      listen(iconc[0], 'touchstart', onActionConfirmStart, {
        passive: true
      });
      listen(iconc[0], 'mousedown', onActionConfirmStart);
      listen(iconc[0], 'touchend', onActionConfirmEnd);
      listen(iconc[0], 'mouseup', onActionConfirmEnd);
    }

    itm.__mbscOff = function () {
      unlisten(document, 'touchstart', onActionCancel, {
        passive: false
      });
      unlisten(document, 'mousedown', onActionCancel);
      unlisten(iconc[0], 'touchstart', onActionConfirmStart, {
        passive: true
      });
      unlisten(iconc[0], 'mousedown', onActionConfirmStart);
      unlisten(iconc[0], 'touchend', onActionConfirmEnd);
      unlisten(iconc[0], 'mouseup', onActionConfirmEnd);
      delete itm.__mbscOff;
    };
  }

  function slideMove() {
    slide(item, startPos + diffX * 100 / itemw);
    rafRunning = false;
  }

  function slideEnd(item, revert, callback) {
    if (item[0].__mbscOff) {
      item[0].__mbscOff();
    }

    if (revert !== false) {
      slide(item, 0, item.attr('data-pos') !== '0' ? 200 : 0, false, function () {
        cleanStage(item, callback);
        resetItem(item);
      });
    } else {
      cleanStage(item, callback);
    }

    confirms = false;
  }

  function slide(item, pos, time, px, callback) {
    pos = Math.max(swipe == 'right' ? 0 : -100, Math.min(pos, swipe == 'left' ? 0 : 100));
    style = item[0].style;
    item.attr('data-pos', pos);
    style[jsPrefix + 'Transform'] = 'translate3d(' + (px ? itemw * pos / 100 + 'px' : pos + '%') + ',0,0)';
    style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms';

    if (callback) {
      transition++;
      setTimeout(function () {
        callback();
        transition--;
      }, time);
    }

    animPos = pos;
  }

  function drag(item, top, time, callback) {
    top = Math.max(minDrag, Math.min(top, maxDrag));
    style = item[0].style;
    style[jsPrefix + 'Transform'] = 'translate3d(0,' + top + 'px,0)';
    style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms ease-out';

    if (callback) {
      transition++;
      setTimeout(function () {
        callback();
        transition--;
      }, time);
    }
  }

  function stopTimer() {
    clearTimeout(timer);

    if (!cancel && that.sortable) {
      cancel = true;
      fill.remove();
    }
  }

  function setStageProps(stage, iconSlide) {
    var txt = valueOrFunc(stage.text, {
      target: item[0],
      index: itemIndex
    }) || '';

    if (valueOrFunc(stage.disabled, {
      target: item[0],
      index: itemIndex
    })) {
      stagec.addClass('mbsc-lv-ic-disabled');
    } else {
      stagec.removeClass('mbsc-lv-ic-disabled');
    }

    stagec.css('background-color', stage.color || (stage.percent === 0 ? getFirstColor(animPos) : transp));
    iconc.attr('class', 'mbsc-lv-ic-c mbsc-lv-ic-' + (iconSlide ? 'move-' : '') + (animPos < 0 ? 'right' : 'left'));
    icon.attr('class', ' mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-' + (stage.icon || 'none'));
    text.attr('class', 'mbsc-lv-ic-text' + (stage.icon ? '' : ' mbsc-lv-ic-text-only') + (txt ? '' : ' mbsc-lv-ic-only')).html(txt || '&nbsp;');

    if (s.animateIcons) {
      if (quickSwipe) {
        icon.addClass('mbsc-lv-ic-v');
      } else {
        setTimeout(function () {
          icon.addClass('mbsc-lv-ic-a');
        }, 10);
      }
    }
  }

  function cleanStage(item, callback) {
    if (!action) {
      // Don't clean stages if another action started
      icon.attr('class', 'mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none');
      stagec.attr('style', '').removeClass('mbsc-lv-stage-c-v');
      text.html('');
    }

    stagec.removeClass('mbsc-lv-left mbsc-lv-right');

    if (item) {
      event('onSlideEnd', {
        target: item[0],
        index: itemIndex
      });

      if (callback) {
        callback();
      }
    }
  }

  function cleanUndo(item) {
    item.css('top', '').removeClass('mbsc-lv-item-undo'); // Remove placeholder

    if (undoAnim) {
      that.animate(placeholder, 'collapse', function () {
        placeholder.remove();
      });
    } else {
      placeholder.remove();
    }

    cleanStage();
    undoRef = null;
    undoAnim = null;
  }

  function resetItem(item) {
    style = item[0].style;
    style[jsPrefix + 'Transform'] = '';
    style[jsPrefix + 'Transition'] = '';
    style.top = '';
    item.removeClass('mbsc-lv-item-swiping');
  }

  function valueOrFunc(val, args) {
    return $$1.isFunction(val) ? val.call(this, args, that) : val;
  }

  function isSelectable(item) {
    return selectable && !item.hasClass('mbsc-lv-parent') && !item.hasClass('mbsc-lv-back');
  }

  function initItem(item) {
    var id = item.attr('data-ref'),
        role = item.attr('data-role'),
        type = types[item.attr('data-type') || 'defaults'],
        selected = isSelectable(item) && item.attr('data-selected') == 'true';

    if (!id) {
      id = guid++;
      item.attr('data-ref', id);
    }

    treeMap[id] = {
      item: item,
      child: item.children(listSelector),
      parent: item.parent(),
      ref: item.parent()[0] === e ? null : item.parent().parent().attr('data-ref')
    };
    item.addClass(role == 'list-divider' ? 'mbsc-lv-gr-title' : 'mbsc-lv-item' + (type.actionable ? ' mbsc-lv-item-actionable' : '') + (selected ? ' ' + SELECTED_CLASS : ''));
    item.attr('aria-selected', selected ? 'true' : 'false'); // Add sort handle

    if (that.sortable.handle && role != 'list-divider' && !item.children('.mbsc-lv-handle-c').length) {
      item.append(handleDiv);
    }

    if (s.enhance && !item.hasClass('mbsc-lv-item-enhanced')) {
      var itemIcon = item.attr('data-icon'),
          itemImg = item.find('img').eq(0).addClass('mbsc-lv-img');

      if (itemImg.is(':first-child')) {
        item.addClass('mbsc-lv-img-' + (s.rtl ? 'right' : 'left'));
      } else if (itemImg.length) {
        item.addClass('mbsc-lv-img-' + (s.rtl ? 'left' : 'right'));
      }

      item.addClass('mbsc-lv-item-enhanced').children().each(function (i, v) {
        v = $$1(v);

        if (v.is('p, h1, h2, h3, h4, h5, h6')) {
          v.addClass('mbsc-lv-txt');
        }
      });

      if (itemIcon) {
        item.addClass('mbsc-lv-item-ic-' + (item.attr('data-icon-align') || (s.rtl ? 'right' : 'left'))).append('<div class="mbsc-lv-item-ic mbsc-ic mbsc-ic-' + itemIcon + '"></div>');
      }
    }
    /* TRIAL */

  }

  function initBranch(elm) {
    // Create map object
    $$1(itemSelector, elm).not('.mbsc-lv-back').each(function () {
      initItem($$1(this));
    }); // Add extra classes and markup (arrows and back items)

    $$1(listSelector, elm).not('.mbsc-lv').addClass('mbsc-lv').prepend(htmlLeft).parent().addClass('mbsc-lv-parent mbsc-lv-item-actionable').prepend(htmlRight); // Add parent reference for back buttons

    $$1('.mbsc-lv-back', elm).each(function () {
      $$1(this).attr('data-back', $$1(this).parent().parent().attr('data-ref'));
    });
  }

  function getChildren(list) {
    return list.children(itemSelector).not('.mbsc-lv-back').not('.mbsc-lv-removed').not('.mbsc-lv-ph');
  }

  function getItemByID(item) {
    if (typeof item !== 'object') {
      item = $$1(itemSelector, cont).filter('[data-id="' + item + '"]');
    }

    return $$1(item);
  }

  function getItemLevel(item) {
    var level = 0,
        map = treeMap[item.attr('data-ref')];

    while (map && map.ref) {
      level++;
      map = treeMap[map.ref];
    }

    return level;
  }

  function getNextPrev(item, dir) {
    item = item[dir](); // Returns next or previous item filtering out placeholder or currently dragged element

    while (item.length && (!item.hasClass('mbsc-lv-item') || item.hasClass('mbsc-lv-ph') || item.hasClass('mbsc-lv-item-dragging'))) {
      if (!that.sortable.group && item.hasClass('mbsc-lv-gr-title')) {
        return false;
      }

      item = item[dir]();
    }

    return item;
  }

  function getFirstColor(pos) {
    return (pos > 0 ? type.right : type.left).color || transp;
  }

  function getNumStr(s) {
    return isNumeric(s) ? s + '' : 0;
  }

  function getActionWidth(type, diffX) {
    return +(diffX < 0 ? getNumStr((type.actionsWidth || 0).right) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.right) || getNumStr(s.actionsWidth) : getNumStr((type.actionsWidth || 0).left) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.left) || getNumStr(s.actionsWidth));
  }

  function scrollToItem(item, scrollToTop) {
    if (item) {
      var scrollTop = wnd.scrollTop(),
          itemHeight = item.is('.mbsc-lv-item') ? item[0].offsetHeight : 0,
          itemTop = item.offset().top + (hasContext ? scrollTop - wndTop : 0);

      if (scrollToTop) {
        if (itemTop < scrollTop || itemTop + itemHeight > scrollTop + wndHeight) {
          wnd.scrollTop(itemTop);
        }
      } else {
        if (itemTop < scrollTop) {
          wnd.scrollTop(itemTop);
        } else if (itemTop + itemHeight > scrollTop + wndHeight) {
          wnd.scrollTop(Math.min(itemTop, itemTop + itemHeight - wndHeight / 2));
        }
      }
    }
  }

  function drill(dir, list, item, callback, scrollToTop) {
    var parent = list.parent(),
        ph = list.prev();
    callback = callback || noop;

    if (ph[0] === iconc[0]) {
      ph = iconc.prev();
    }

    if (s.rtl) {
      dir = dir === 'l' ? 'r' : 'l';
    }

    if (currList[0] !== list[0]) {
      event('onNavStart', {
        level: slideLevel,
        direction: dir,
        list: list[0]
      });
      slideCont.prepend(list.addClass('mbsc-lv-v mbsc-lv-sl-new')); // If top of the list is not visible, scroll to top

      scrollToItem(cont);
      animate(slideCont, 'mbsc-lv-sl-' + dir, function () {
        currList.removeClass('mbsc-lv-sl-curr');
        list.removeClass('mbsc-lv-sl-new').addClass('mbsc-lv-sl-curr');

        if (currPh && currPh.length) {
          currList.removeClass('mbsc-lv-v').insertAfter(currPh);
        } else {
          currParent.append(currList.removeClass('mbsc-lv-v'));
        } // Remember the previous element where we need to put back the list later
        // We need this because some frameworks like ember js put additional elements (script tags)
        // and appending to parent element is not ok


        currPh = ph;
        currParent = parent;
        currList = list;
        scrollToItem(item, scrollToTop);
        callback.call(e, item);
        event('onNavEnd', {
          level: slideLevel,
          direction: dir,
          list: list[0]
        });
      });
    } else {
      scrollToItem(item, scrollToTop);
      callback.call(e, item);
    }
  }

  function navigate(item, callback) {
    if (!transition) {
      if (item.hasClass('mbsc-lv-parent')) {
        slideLevel++;
        drill('r', treeMap[item.attr('data-ref')].child, null, callback);
      } else if (item.hasClass('mbsc-lv-back')) {
        slideLevel--;
        drill('l', treeMap[item.attr('data-back')].parent, treeMap[item.attr('data-back')].item, callback);
      }
    }
  }

  function animate(el, anim, callback) {
    var timer;

    function onAnimEnd() {
      clearTimeout(timer);
      transition--;
      el.off(animEnd, onAnimEnd).removeClass(anim);
      callback.call(e, el);
    }

    callback = callback || noop;

    if (s.animation && anim !== 'mbsc-lv-item-none') {
      transition++;
      el.on(animEnd, onAnimEnd).addClass(anim); // animEnd event will not execute with some integration plugins, this is a workaround to make sure it's executed

      timer = setTimeout(onAnimEnd, 250);
    } else {
      callback.call(e, el);
    }
  }

  function doAction(el, action) {
    var queue,
        id = el.attr('data-ref');
    queue = actionQueue[id] = actionQueue[id] || [];

    if (action) {
      queue.push(action);
    }

    if (el.attr('data-action')) {
      return;
    }

    action = queue.shift(); // Check this for safety
    // There was a case in angular were the data-ref attribute was lost,
    // so the queue was empty

    if (action) {
      el.attr('data-action', 1);
      action(function () {
        el.removeAttr('data-action');

        if (queue.length) {
          doAction(el);
        } else {
          delete actionQueue[id];
        }
      });
    }
  }

  function processStages(stages, dir, duplicate) {
    var count, temp;

    if (stages && stages.length) {
      count = 100 / (stages.length + 2);
      $$1.each(stages, function (i, stage) {
        if (stage.key === undefined) {
          stage.key = stageNr++;
        }

        if (stage.percent === undefined) {
          // if no percent passed then generate to both sides
          stage.percent = dir * count * (i + 1);

          if (duplicate) {
            temp = extend$1({}, stage);
            temp.key = stageNr++;
            temp.percent = -count * (i + 1);
            stages.push(temp);
            stageObj[temp.key] = temp;
          }
        }

        stageObj[stage.key] = stage;
      });
    }
  }

  function selectItem($item) {
    if (isSelectable($item)) {
      $item.addClass(SELECTED_CLASS).attr('data-selected', 'true').attr('aria-selected', 'true');
    }
  }

  function deselectItem($item) {
    $item.removeClass(SELECTED_CLASS).removeAttr('data-selected').removeAttr('aria-selected');
  } // Call the parent constructor


  Base.call(this, elem, settings, true);
  /* TRIALFUNC */

  /**
   * Animate a list item
   */

  that.animate = function (li, anim, callback) {
    animate(li, 'mbsc-lv-item-' + anim, callback);
  };
  /**
   * Add a new list item
   */


  that.add = function (id, markup, index, callback, p, isUndo) {
    var backBtn,
        length,
        siblings,
        sublevel,
        map,
        pref,
        cssClass = '',
        $parent = p === undefined ? elm : getItemByID(p),
        $list = $parent,
        $item = typeof markup !== 'object' ? $$1('<' + itemNode + ' data-ref="' + guid++ + '" data-id="' + id + '">' + markup + '</' + itemNode + '>') : $$1(markup),
        item = $item[0],
        style = item.style,
        dir = $item.attr('data-pos') < 0 ? 'left' : 'right',
        ref = $item.attr('data-ref');
    callback = callback || noop;

    if (!ref) {
      ref = guid++;
      $item.attr('data-ref', ref);
    }

    initItem($item); // Put action in undo stack

    if (!isUndo) {
      that.addUndoAction(function (next) {
        if (sublevel) {
          that.navigate($parent, function () {
            $list.remove();
            $parent.removeClass('mbsc-lv-parent').children('.mbsc-lv-arr').remove();
            map.child = $parent.children(listSelector);
            that.remove($item, null, next, true);
          });
        } else {
          that.remove($item, null, next, true);
        }
      }, true);
    }

    doAction($item, function (next) {
      resetItem($item.css('top', '').removeClass('mbsc-lv-item-undo')); // If parent is a list item, insert new element in the sublist

      if ($parent.is(itemSelector)) {
        pref = $parent.attr('data-ref'); // If there is no sublist yet, create it

        if (!$parent.children(listSelector).length) {
          sublevel = true;
          $parent.append('<' + listNode + '></' + listNode + '>');
        }
      } else {
        pref = $parent.children('.mbsc-lv-back').attr('data-back');
      }

      map = treeMap[pref];

      if (map) {
        if (!map.child.length) {
          $parent.addClass('mbsc-lv-parent').prepend(htmlRight); // Set parent to be the sublist

          $list = $parent.children(listSelector).prepend(htmlLeft).addClass('mbsc-lv');
          map.child = $list;
          $$1('.mbsc-lv-back', $parent).attr('data-back', pref);
        } else {
          $list = map.child;
        }
      }

      treeMap[ref] = {
        item: $item,
        child: $item.children(listSelector),
        parent: $list,
        ref: pref
      };
      siblings = getChildren($list);
      length = siblings.length;

      if (index === undefined || index === null) {
        index = length;
      }

      if (isUndo) {
        cssClass = 'mbsc-lv-item-new-' + (isUndo ? dir : '');
      }

      initBranch($item.addClass(cssClass));

      if (index !== false) {
        if (!length) {
          backBtn = $$1('.mbsc-lv-back', $list);

          if (backBtn.length) {
            $item.insertAfter(backBtn);
          } else {
            $list.append($item);
          }
        } else if (index < length) {
          $item.insertBefore(siblings.eq(index));
        } else {
          $item.insertAfter(siblings.eq(length - 1));
        }
      }

      cont.trigger('mbsc-refresh'); // If current level is visible

      if (s.animateAddRemove && $list.hasClass('mbsc-lv-v')) {
        // Don't run expand animation if add is running on the "undo" element
        style.height = item.offsetHeight + 'px';
        that.animate($item, isUndo && undoRef === ref ? 'none' : 'expand', function ($item) {
          that.animate($item, isUndo ? 'add-' + dir : 'pop-in', function ($item) {
            style.height = '';
            callback.call(e, $item.removeClass(cssClass));
            next();
          });
        });
      } else {
        callback.call(e, $item.removeClass(cssClass));
        next();
      }

      event('onItemAdd', {
        target: item
      });
    });
  };
  /**
   * Swipe a list item programatically
   */


  that.swipe = function (li, percent, time, demo, callback) {
    var prevPos;
    li = getItemByID(li);
    item = li;
    demoMode = demo;
    simulating = true;
    action = true;
    time = time === undefined ? 300 : time;
    diffX = percent > 0 ? 1 : -1;
    onActionStart();
    onSwipeStart();
    slide(li, percent, time);
    clearTimeout(swipeTimeout);
    clearInterval(swipeInterval);
    swipeInterval = setInterval(function () {
      prevPos = animPos;
      animPos = getPosition(li) / itemw * 100;
      onSwipeMove(prevPos);
    }, 10);
    swipeTimeout = setTimeout(function () {
      clearInterval(swipeInterval);
      prevPos = animPos;
      animPos = percent; // We need one additional move with the final percent to get the correct stage

      onSwipeMove(prevPos);
      onSwipeEnd(callback);
      demoMode = false;
      simulating = false;
      action = false;
    }, time);
  };

  that.openStage = function (li, stage, time, demo) {
    if (stageObj[stage]) {
      that.swipe(li, stageObj[stage].percent, time, demo);
    }
  };

  that.openActions = function (li, dir, time, demo) {
    li = getItemByID(li);
    var percent = getActionWidth(types[li.attr('data-type') || 'defaults'], dir == 'left' ? -1 : 1);
    that.swipe(li, dir == 'left' ? -percent : percent, time, demo);
  };

  that.close = function (li, time) {
    that.swipe(li, 0, time);
  };
  /**
   * Remove a list item
   */


  that.remove = function (id, dir, callback, isUndo) {
    var $item, $parent, anim, index, ref, shouldNavigate, style;

    function deleteSubTree($child) {
      if ($child) {
        shouldNavigate = shouldNavigate || $child.hasClass('mbsc-lv-v');
        $child.children('[data-ref]').each(function () {
          var ref = $$1(this).attr('data-ref');

          if (treeMap[ref]) {
            deleteSubTree(treeMap[ref].child);
            delete treeMap[ref];
          }
        });
      }
    }

    callback = callback || noop;
    $item = getItemByID(id);
    ref = $item.attr('data-ref');

    if ($item.length && treeMap[ref]) {
      $parent = $item.parent();
      index = getChildren($parent).index($item);
      style = $item[0].style;
      deleteSubTree(treeMap[ref].child);

      if (shouldNavigate) {
        anim = s.animation;
        s.animation = false;
        that.navigate($item);
        s.animation = anim;
      }

      delete treeMap[ref]; // Put action in undo stack

      if (!isUndo) {
        // If undo element is removed, undo placeholder should be removed with animation
        if ($item.attr('data-ref') === undoRef) {
          undoAnim = true;
        }

        that.addUndoAction(function (next) {
          that.add(null, $item, index, next, $parent, true);
        }, true);
      }

      doAction($item, function (next) {
        dir = dir || ($item.attr('data-pos') < 0 ? 'left' : 'right');

        if (s.animateAddRemove && $parent.hasClass('mbsc-lv-v')) {
          that.animate($item.addClass('mbsc-lv-removed'), isUndo ? 'pop-out' : 'remove-' + dir, function ($item) {
            style.height = $item[0].offsetHeight + 'px';
            that.animate($item, 'collapse', function ($item) {
              style.height = '';
              resetItem($item.removeClass('mbsc-lv-removed'));

              if (callback.call(e, $item) !== false) {
                $item.remove();
              }

              next();
            });
          });
        } else {
          if (callback.call(e, $item) !== false) {
            $item.remove();
          }

          next();
        }

        event('onItemRemove', {
          target: $item[0]
        });
      });
    }
  };
  /**
   * Moves an item in the list
   */


  that.move = function (li, index, dir, callback, p, isUndo) {
    li = getItemByID(li); //if (getChildren(li.parent()).index(li) !== index) {

    if (!isUndo) {
      that.startActionTrack();
    }

    stagec.append(iconc);
    that.remove(li, dir, null, isUndo);
    that.add(null, li, index, callback, p, isUndo);

    if (!isUndo) {
      that.endActionTrack();
    } //}

  };
  /**
   * Navigate and scroll to the given element
   */


  that.navigate = function (item, callback) {
    var map, level;
    item = getItemByID(item);
    map = treeMap[item.attr('data-ref')];
    level = getItemLevel(item);

    if (map) {
      drill(level >= slideLevel ? 'r' : 'l', map.parent, item, callback, true);
      slideLevel = level;
    }
  };

  that.showLoading = function () {
    isLoading = true;
    loading.addClass('mbsc-show-lv-loading');
    wnd.scrollTop(hasContext ? wnd0.scrollHeight : $$1(s.context)[0].scrollHeight);
  };

  that.hideLoading = function () {
    loading.removeClass('mbsc-show-lv-loading'); // Needs timeout to prevent triggering 
    // the onListEnd event from the scroll listener

    setTimeout(function () {
      isLoading = false;
    }, 100);
  };

  that.select = function (item) {
    if (!multiple) {
      deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));
    }

    selectItem(getItemByID(item));
  };

  that.deselect = function (item) {
    deselectItem(getItemByID(item));
  };

  that._processSettings = function () {
    if (elm.is('[mbsc-enhance]')) {
      hadEnhance = true;
      elm.removeAttr('mbsc-enhance');
    }
  };
  /**
   * Listview initialization.
   */


  that._init = function () {
    var contClass,
        headerClass,
        sortable,
        defSortHandle = elm.find(listSelector).length ? 'left' : 'right',
        i = 0,
        icons = '',
        iconsLeft = '',
        iconsRight = '';
    listNode = s.listNode;
    listSelector = s.listSelector;
    itemNode = s.itemNode;
    itemSelector = s.itemSelector;
    multiple = s.select == 'multiple';
    selectable = s.select != 'off'; // --- TRIAL SERVER CODE START ---

    sortable = s.sort || s.sortable || false; // Backward compatiblity for 'group' and sortHandle settings
    // ---

    if (sortable === 'group') {
      sortable = {
        group: false,
        multiLevel: true
      };
    }

    if (sortable === true) {
      sortable = {
        group: true,
        multiLevel: true,
        handle: s.sortHandle
      };
    }

    if (sortable && sortable.handle === undefined) {
      sortable.handle = s.sortHandle;
    } // ---


    if (sortable.handle) {
      handlePos = sortable.handle === true ? defSortHandle : sortable.handle;
      handleDiv = '<div class="mbsc-lv-handle-c mbsc-lv-item-h-' + handlePos + ' mbsc-lv-handle"><div class="' + s.handleClass + ' mbsc-lv-handle-bar-c mbsc-lv-handle">' + s.handleMarkup + '</div></div>';
    }

    htmlLeft = '<' + itemNode + ' class="mbsc-lv-item mbsc-lv-back mbsc-lv-item-actionable">' + s.backText + '<div class="mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.leftArrowClass + '"></div></' + itemNode + '>';
    htmlRight = '<div class="mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.rightArrowClass + '"></div>';
    contClass = 'mbsc-no-touch mbsc-lv-cont mbsc-lv-' + s.theme + ' mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-lv-hb' : '') + (s.rtl ? ' mbsc-lv-rtl mbsc-rtl' : ' mbsc-ltr') + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') + (s.animateIcons ? ' mbsc-lv-ic-anim' : '') + (s.striped ? ' mbsc-lv-alt-row' : '') + (s.fixedHeader ? ' mbsc-lv-has-fixed-header' : '') + (sortable.handle ? ' mbsc-lv-handle-' + handlePos : ''); // --- TRIAL SERVER CODE END ---

    that.sortable = sortable || false;

    if (!cont) {
      // Icon menu container
      icons += '<div class="mbsc-lv-multi-c"></div>'; // Stage icons container

      icons += '<div class="mbsc-lv-ic-c"><div class="mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none"></div><div class="mbsc-lv-ic-text"></div></div>'; // Add classes

      elm.addClass('mbsc-lv mbsc-lv-v mbsc-lv-root').removeClass('mbsc-cloak').show();
      stagec = $$1('<div class="mbsc-lv-stage-c">' + icons + '</div>');
      iconc = $$1('.mbsc-lv-ic-c', stagec);
      multic = $$1('.mbsc-lv-multi-c', stagec);
      icon = $$1('.mbsc-lv-ic-s', stagec);
      text = $$1('.mbsc-lv-ic-text', stagec);
      placeholder = $$1('<' + itemNode + ' class="mbsc-lv-item mbsc-lv-ph"></' + itemNode + '>');
      fill = $$1('<div class="mbsc-lv-fill-item"></div>');
      cont = $$1('<div class="' + contClass + '"><' + listNode + ' class="mbsc-lv mbsc-lv-dummy"></' + listNode + '><div class="mbsc-lv-sl-c"></div>' + '<div class="mbsc-lv-loading"><span class="mbsc-ic mbsc-ic-' + (s.loadingIcon || 'loop2') + '"></span></div></div>');
      cont0 = cont[0];
      dummyCont = $$1('.mbsc-lv-dummy', cont);
      loading = $$1('.mbsc-lv-loading', cont);
      cont.insertAfter(elm);
      onResize(); // Slide events

      listen(cont0, 'mousedown', onStart);
      listen(document, 'touchstart', onStart, {
        passive: false
      });
      listen(document, 'touchmove', onMove, {
        passive: false
      });
      cont.on('touchend touchcancel', '.mbsc-lv-item', onEnd).on('click', '.mbsc-lv-item', onClick); // Prevent click on swipe

      listen(e, 'click', onListClick, true); // Init action icons
      // ---

      listen(cont0, 'mousedown', onIconStart);
      listen(document, 'touchstart', onIconStart, {
        passive: false
      });
      cont.on('touchend mouseup', '.mbsc-lv-ic-m', function (ev) {
        if (!demoMode) {
          if (ev.type === 'touchend') {
            preventClick();
          } // If movement is less than 10px, fire the click event handler


          if (confirms && !$$1(this).hasClass('mbsc-lv-ic-disabled') && Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {
            runAction((animPos < 0 ? type.rightMenu : type.leftMenu)[$$1(this).index()], confirmItem, confirmIndex);
          }
        }
      }); // ---
      // Init hierarchical navigation
      // ---

      slideCont = $$1('.mbsc-lv-sl-c', cont).append(elm.addClass('mbsc-lv-sl-curr')).attr('data-ref', guid++);
      currList = elm;
      currParent = cont; // ---
    } else {
      cont.attr('class', contClass); // reinit sort handles

      $$1('.mbsc-lv-handle-c', cont).remove(); // remove to reinit list items

      $$1(itemSelector, cont).not('.mbsc-lv-back').removeClass('mbsc-lv-item');
      unlisten(wnd0, 'orientationchange', onResize);
      unlisten(wnd0, 'resize', onResize);
      unlisten(wnd0, 'scroll', onScrollBottom);
      unlisten(wnd0, 'touchmove', onScrollBottom, {
        passive: true
      });

      if (onScrollThrottle) {
        unlisten(wnd0, 'scroll', onScrollThrottle);
        unlisten(wnd0, 'touchmove', onScrollThrottle, {
          passive: true
        });
      }
    }

    hasContext = s.context !== 'body';
    wnd = $$1(hasContext ? s.context : window);
    wnd0 = wnd[0]; // Recalculate sizes on resize / orientationchange

    listen(wnd0, 'orientationchange', onResize);
    listen(wnd0, 'resize', onResize);
    listen(wnd0, 'scroll', onScrollBottom);
    listen(wnd0, 'touchmove', onScrollBottom, {
      passive: true
    }); // Init stages and actions
    // ---

    stageNr = 0;
    types = s.itemGroups || {};
    types.defaults = {
      swipeleft: s.swipeleft,
      swiperight: s.swiperight,
      stages: s.stages,
      actions: s.actions,
      actionsWidth: s.actionsWidth,
      actionable: s.actionable
    };
    initBranch(elm);
    $$1.each(types, function (n, v) {
      v.swipe = v.swipe !== undefined ? v.swipe : s.swipe;
      v.actionable = v.actionable !== undefined ? v.actionable : s.actionable;
      v.stages = v.stages || []; // Init stages

      processStages(v.stages, 1, true);
      processStages(v.stages.left, 1);
      processStages(v.stages.right, -1);

      if (v.stages.left || v.stages.right) {
        v.stages = [].concat(v.stages.left || [], v.stages.right || []);
      }

      found = false;

      if (!v.stages.length) {
        if (v.swipeleft) {
          v.stages.push({
            percent: -30,
            action: v.swipeleft
          });
        }

        if (v.swiperight) {
          v.stages.push({
            percent: 30,
            action: v.swiperight
          });
        }
      }

      $$1.each(v.stages, function (i, v) {
        // find the 0
        if (v.percent === 0) {
          found = true;
          return false;
        }
      });

      if (!found) {
        v.stages.push({
          percent: 0
        });
      }

      v.stages.sort(function (a, b) {
        return a.percent - b.percent;
      });
      $$1.each(v.stages, function (i, s) {
        // find the 0
        if (s.percent === 0) {
          v.start = i;
          return false;
        }
      });

      if (found) {
        v.left = v.right = v.stages[v.start];
      } else {
        v.left = v.stages[v.start - 1] || {};
        v.right = v.stages[v.start + 1] || {};
      } // Init actions


      if (v.actions) {
        v.leftMenu = v.actions.left || v.actions;
        v.rightMenu = v.actions.right || v.leftMenu;
        iconsLeft = '';
        iconsRight = '';

        for (i = 0; i < v.leftMenu.length; i++) {
          iconsLeft += '<div ' + (v.leftMenu[i].color ? 'style="background-color: ' + v.leftMenu[i].color + '"' : '') + ' class="mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.leftMenu[i].icon + '">' + (v.leftMenu[i].text || '') + '</div>';
        }

        for (i = 0; i < v.rightMenu.length; ++i) {
          iconsRight += '<div ' + (v.rightMenu[i].color ? 'style="background-color: ' + v.rightMenu[i].color + '"' : '') + ' class="mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.rightMenu[i].icon + '">' + (v.rightMenu[i].text || '') + '</div>';
        }

        if (v.actions.left) {
          v.swipe = v.actions.right ? v.swipe : 'right';
        }

        if (v.actions.right) {
          v.swipe = v.actions.left ? v.swipe : 'left';
        }

        v.icons = '<div class="mbsc-lv-multi mbsc-lv-multi-ic-left">' + iconsLeft + '</div><div class="mbsc-lv-multi mbsc-lv-multi-ic-right">' + iconsRight + '</div>';
      }
    }); // ---
    // Init fixed header
    // ---

    if (s.fixedHeader) {
      headerClass = 'mbsc-lv-fixed-header' + (hasContext ? ' mbsc-lv-fixed-header-ctx mbsc-lv-' + s.theme + ' mbsc-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') : '');

      if (!groupHeader) {
        groupHeader = $$1('<div class="' + headerClass + '"></div>');
      } else {
        groupHeader.attr('class', headerClass);
        onScroll();
      }

      if (hasContext) {
        wnd.before(groupHeader);
      } else {
        cont.prepend(groupHeader);
      }

      onScrollThrottle = throttle(onScroll, 200);
      listen(wnd0, 'scroll', onScrollThrottle);
      listen(wnd0, 'touchmove', onScrollThrottle, {
        passive: true
      });
    } // ---


    if (s.hover) {
      if (!hoverTime) {
        cont.on('mouseover.mbsc-lv', '.mbsc-lv-item', function () {
          if (!hoverItem || hoverItem[0] != this) {
            onMouseLeave();
            hoverItem = $$1(this);

            if (types[hoverItem.attr('data-type') || 'defaults'].actions) {
              hoverTimer = setTimeout(function () {
                if (!preventHover) {
                  hoverItemOpened = true;
                  that.openActions(hoverItem, hoverDir, hoverTime, false);
                } else {
                  hoverItem = null;
                }
              }, hoverTimeout);
            }
          }
        }).on('mouseleave.mbsc-lv', onMouseLeave);
      }

      hoverTime = s.hover.time || 200;
      hoverTimeout = s.hover.timeout || 200;
      hoverDir = s.hover.direction || s.hover || 'right';
    }

    if (hadEnhance) {
      cont.attr('mbsc-enhance', '');
    }

    cont.trigger('mbsc-enhance', [{
      theme: s.theme,
      lang: s.lang
    }]);
  };
  /**
   * Listview destroy: removes event handlers, classes and additional markup.
   */


  that._destroy = function () {
    var form;
    currParent.append(currList);

    if (hasContext && groupHeader) {
      groupHeader.remove();
    }

    if (hadEnhance) {
      elm.attr('mbsc-enhance', ''); // Destroy form instance if any

      form = instances[cont0.id];

      if (form) {
        form.destroy();
      }
    }

    unlisten(document, 'touchstart', onStart, {
      passive: false
    });
    unlisten(document, 'touchstart', onIconStart, {
      passive: false
    });
    unlisten(document, 'touchmove', onMove, {
      passive: false
    });
    unlisten(e, 'click', onListClick, true);
    cont.find('.mbsc-lv-txt,.mbsc-lv-img').removeClass('mbsc-lv-txt mbsc-lv-img');
    cont.find(listSelector).removeClass('mbsc-lv mbsc-lv-v mbsc-lv-root mbsc-lv-sl-curr').find(itemSelector).removeClass('mbsc-lv-gr-title mbsc-lv-item mbsc-lv-item-enhanced mbsc-lv-parent mbsc-lv-img-left mbsc-lv-img-right mbsc-lv-item-ic-left mbsc-lv-item-ic-right').removeAttr('data-ref');
    $$1('.mbsc-lv-back,.mbsc-lv-handle-c,.mbsc-lv-arr,.mbsc-lv-item-ic', cont).remove();
    elm.insertAfter(cont);
    cont.remove();
    stagec.remove();
    unlisten(wnd0, 'orientationchange', onResize);
    unlisten(wnd0, 'resize', onResize);
    unlisten(wnd0, 'scroll', onScrollBottom);
    unlisten(wnd0, 'touchmove', onScrollBottom, {
      passive: true
    });

    if (onScrollThrottle) {
      unlisten(wnd0, 'scroll', onScrollThrottle);
      unlisten(wnd0, 'touchmove', onScrollThrottle, {
        passive: true
      });
    }
  }; // Undo manager, may be removed later in separate class
  // ---


  var undoing,
      undoQueue = [],
      undoStack = [],
      undoGroup = [],
      undoListener = 0;

  that.startActionTrack = function () {
    // Start a new undo group if not running
    if (!undoListener) {
      undoGroup = [];
    }

    undoListener++;
  };

  that.endActionTrack = function () {
    // End undo group, if this the outermost listener (undoListener counter is 0);
    undoListener--;

    if (!undoListener) {
      undoStack.push(undoGroup);
    }
  };

  that.addUndoAction = function (action, async) {
    var obj = {
      action: action,
      async: async
    }; //if (!undoing) {

    if (undoListener) {
      // Add undo action in current group, if a listener is running
      undoGroup.push(obj);
    } else {
      // Add undo action within a new group
      undoStack.push([obj]);

      if (undoStack.length > s.undoLimit) {
        undoStack.shift();
      }
    } //}

  };

  that.undo = function () {
    var action, i, group;

    function run() {
      if (i < 0) {
        undoing = false; // If there is data in the queue, keep calling the undo

        undo();
      } else {
        action = group[i];
        i--;

        if (action.async) {
          // Run action, next action must be called inside the action
          action.action(run);
        } else {
          // Run action
          action.action(); // Run next action

          run();
        }
      }
    }

    function undo() {
      group = undoQueue.shift();

      if (group) {
        undoing = true;
        i = group.length - 1; // Call actions from the group recoursively

        run();
      }
    }

    if (undoStack.length) {
      undoQueue.push(undoStack.pop());
    } // If undo is currently running, don't do anything (it will be called later from queue)


    if (!undoing) {
      undo();
    }
  }; // ---
  // Constructor


  s = that.settings;
  event = that.trigger;
  that.init();
}; // Defaults

ListView.prototype = {
  _class: 'listview',
  _hasDef: true,
  _hasTheme: true,
  _hasLang: true,
  _defaults: {
    context: 'body',
    actionsWidth: 90,
    sortDelay: 250,
    undoLimit: 10,
    tap: hasGhostClick,
    swipe: true,
    quickSwipe: true,
    animateAddRemove: true,
    animateIcons: true,
    animation: true,
    revert: true,
    vibrate: true,
    actionable: true,
    handleClass: '',
    handleMarkup: '<div class="mbsc-lv-handle-bar mbsc-lv-handle"></div><div class="mbsc-lv-handle-bar mbsc-lv-handle"></div><div class="mbsc-lv-handle-bar mbsc-lv-handle"></div>',
    listNode: 'ul',
    listSelector: 'ul,ol',
    itemNode: 'li',
    itemSelector: 'li',
    leftArrowClass: 'mbsc-ic-arrow-left4',
    rightArrowClass: 'mbsc-ic-arrow-right4',
    backText: 'Back',
    undoText: 'Undo',
    stages: [],
    select: 'off'
  }
};
classes.ListView = ListView;
mobiscroll.themes.listview.mobiscroll = {
  leftArrowClass: 'mbsc-ic-arrow-left5',
  rightArrowClass: 'mbsc-ic-arrow-right5'
};

var MbscListviewService = (function () {
    function MbscListviewService() {
        this.addObservable = new Observable();
        this.removeObservable = new Observable();
        this.cardObservable = new Observable();
        this.instanceObservable = new Observable();
        this.inst = null;
    }
    MbscListviewService.prototype.notifyInstanceReady = function (instance) {
        this.inst = instance;
        this.instanceObservable.next(instance);
    };
    MbscListviewService.prototype.onInstanceReady = function () {
        return this.instanceObservable;
    };
    MbscListviewService.prototype.notifyAdded = function (item, parent) {
        this.addObservable.next({ item: item, parent: parent });
    };
    MbscListviewService.prototype.notifyRemoved = function (item) {
        this.removeObservable.next(item);
    };
    MbscListviewService.prototype.notifyCardPresence = function (isCard) {
        this.cardObservable.next(isCard);
    };
    MbscListviewService.prototype.onCardContent = function () {
        return this.cardObservable;
    };
    MbscListviewService.prototype.onItemAdded = function () {
        return this.addObservable;
    };
    MbscListviewService.prototype.onItemRemoved = function () {
        return this.removeObservable;
    };
    MbscListviewService = __decorate([
        Injectable()
    ], MbscListviewService);
    return MbscListviewService;
}());
var MbscSublistService = (function () {
    function MbscSublistService() {
        this.addObservable = new Observable();
        this.removeObserable = new Observable();
    }
    MbscSublistService.prototype.notifyAdded = function (item) {
        this.addObservable.next(item);
    };
    MbscSublistService.prototype.notifyRemoved = function (item) {
        this.removeObserable.next(item);
    };
    MbscSublistService.prototype.onItemAdded = function () {
        return this.addObservable;
    };
    MbscSublistService.prototype.onItemRemoved = function () {
        return this.removeObserable;
    };
    MbscSublistService = __decorate([
        Injectable()
    ], MbscSublistService);
    return MbscSublistService;
}());
var MbscListitemService = (function () {
    function MbscListitemService() {
        this.sublistSubject = new Observable();
        this.inst = null;
    }
    MbscListitemService.prototype.notifySublistCreated = function (item) {
        this.sublistSubject.next(item);
    };
    MbscListitemService.prototype.onSublistCreated = function () {
        return this.sublistSubject;
    };
    MbscListitemService = __decorate([
        Injectable()
    ], MbscListitemService);
    return MbscListitemService;
}());
var MbscListviewSublist = (function () {
    function MbscListviewSublist(parentServ, subServ, itemService) {
        this.parentServ = parentServ;
        this.subServ = subServ;
        this.itemService = itemService;
    }
    MbscListviewSublist.prototype.ngOnInit = function () {
        this.itemService.notifySublistCreated(this);
    };
    MbscListviewSublist = __decorate([
        Component({
            selector: 'mbsc-listview-sublist',
            template: '<ng-content></ng-content>',
            providers: [MbscSublistService]
        }),
        __metadata("design:paramtypes", [MbscListviewService, MbscSublistService, MbscListitemService])
    ], MbscListviewSublist);
    return MbscListviewSublist;
}());
var MbscListviewItem = (function () {
    function MbscListviewItem(elem, lvService, lvItemService, subService) {
        var _this = this;
        this.elem = elem;
        this.lvService = lvService;
        this.lvItemService = lvItemService;
        this.subService = subService;
        this.clone = null;
        this.mounted = false;
        this.isParent = false;
        this._instance = undefined;
        this.subitemObserver = null;
        this.selectedChange = new EventEmitter();
        this.sublistObserver = lvItemService.onSublistCreated().subscribe(function (sublist) {
            _this.isParent = true;
            _this.sublist = sublist;
            _this.subitemObserver = sublist.subServ.onItemAdded().subscribe(function (subItem) {
                if (_this.mounted) {
                    _this.lvService.notifyAdded(subItem, _this);
                }
            });
        });
        this.instanceObserver = this.lvService.onInstanceReady().subscribe(function (instance) {
            _this._instance = instance;
        });
        if (lvService.inst) {
            this._instance = lvService.inst;
        }
    }
    Object.defineProperty(MbscListviewItem.prototype, "Index", {
        get: function () {
            var thisElem = $$1(this.elem.nativeElement);
            var index = thisElem.parent().children('mbsc-listview-item, mbsc-listview-header').not('.mbsc-lv-back').index(thisElem);
            return index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscListviewItem.prototype, "Element", {
        get: function () {
            return this.clone || $$1(this.elem.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    MbscListviewItem.prototype.ngAfterViewInit = function () {
        if (this.subService) {
            this.subService.notifyAdded(this);
        }
        else {
            this.lvService.notifyAdded(this);
        }
        this.mounted = true;
    };
    MbscListviewItem.prototype.ngOnDestroy = function () {
        this.lvItemService.onSublistCreated().unsubscribe(this.sublistObserver);
        this.lvService.onInstanceReady().unsubscribe(this.instanceObserver);
        if (this.subitemObserver !== null) {
            this.sublist.subServ.onItemAdded().unsubscribe(this.subitemObserver);
            this.sublist = null;
        }
        var $elm = this.Element, $clone = $elm.clone();
        if ($elm.parent().length) {
            $clone.insertBefore($elm);
            this.clone = $clone;
        }
        if (this.subService) {
            this.subService.notifyRemoved(this);
        }
        else {
            this.lvService.notifyRemoved(this);
        }
    };
    Object.defineProperty(MbscListviewItem.prototype, "selected", {
        get: function () {
            return this._selected;
        },
        set: function (v) {
            this._selected = v;
            if (this._instance) {
                if (this._selected) {
                    this._instance.select(this.elem.nativeElement);
                }
                else {
                    this._instance.deselect(this.elem.nativeElement);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    MbscListviewItem.prototype.toggle = function () {
        this._selected = !this._selected;
        this.selectedChange.emit(this._selected);
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscListviewItem.prototype, "id", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscListviewItem.prototype, "icon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscListviewItem.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscListviewItem.prototype, "type", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], MbscListviewItem.prototype, "selected", null);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListviewItem.prototype, "selectedChange", void 0);
    MbscListviewItem = __decorate([
        Component({
            selector: 'mbsc-listview-item',
            template: '<ng-content></ng-content>',
            providers: [MbscListitemService],
            host: {
                '[attr.data-id]': 'id',
                '[attr.data-icon]': 'icon',
                '[attr.data-icon-align]': 'iconAlign',
                '[attr.data-selected]': 'selected',
                '[attr.data-type]': 'type'
            }
        }),
        __param(3, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscListviewService, MbscListitemService, MbscSublistService])
    ], MbscListviewItem);
    return MbscListviewItem;
}());
var MbscListviewHeader = (function (_super) {
    __extends(MbscListviewHeader, _super);
    function MbscListviewHeader(elem, lvService, itemService, subService) {
        return _super.call(this, elem, lvService, itemService, subService) || this;
    }
    MbscListviewHeader = __decorate([
        Component({
            selector: 'mbsc-listview-header',
            template: '<ng-content></ng-content>',
            providers: [MbscListitemService],
            host: {
                '[attr.data-id]': 'id',
                'data-role': 'list-divider'
            }
        }),
        __param(3, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscListviewService, MbscListitemService, MbscSublistService])
    ], MbscListviewHeader);
    return MbscListviewHeader;
}(MbscListviewItem));
var MbscListview = (function (_super) {
    __extends(MbscListview, _super);
    function MbscListview(elem, zone, lvService, optionService) {
        var _this = _super.call(this, elem, zone) || this;
        _this.elem = elem;
        _this.lvService = lvService;
        _this.optionService = optionService;
        _this.onItemTap = new EventEmitter();
        _this.onItemAdd = new EventEmitter();
        _this.onItemRemove = new EventEmitter();
        _this.onListEnd = new EventEmitter();
        _this.onNavEnd = new EventEmitter();
        _this.onNavStart = new EventEmitter();
        _this.onSlideEnd = new EventEmitter();
        _this.onSlideStart = new EventEmitter();
        _this.onSort = new EventEmitter();
        _this.onSortChange = new EventEmitter();
        _this.onSortStart = new EventEmitter();
        _this.onSortEnd = new EventEmitter();
        _this.onSortUpdate = new EventEmitter();
        _this.onStageChange = new EventEmitter();
        _this.cardContent = false;
        _this.addObserver = lvService.onItemAdded().subscribe(function (t) {
            var item = t.item, parent = t.parent;
            if (_this.instance) {
                _this.instance.add(null, item.Element, item.Index, undefined, parent && parent.Element);
            }
        });
        _this.removeObserver = lvService.onItemRemoved().subscribe(function (item) {
            if (_this.instance) {
                _this.instance.remove(item.Element, undefined);
            }
        });
        _this.cardObserver = lvService.onCardContent().subscribe(function (isCard) {
            _this.cardContent = isCard;
        });
        return _this;
    }
    MbscListview.prototype.tapHandler = function (event, inst) {
        var selection = this.select || (inst && inst.settings.select);
        switch (selection) {
            case 'multiple': {
                var item = this._getItem(event.target);
                if (item && !item.isParent) {
                    item.toggle();
                }
                break;
            }
            case 'single': {
                var item = this._getItem(event.target);
                if (item && !item.selected) {
                    this.items.forEach(function (item) {
                        if (item.selected) {
                            item.toggle();
                        }
                    });
                    item.toggle();
                }
            }
        }
        event.inst = inst;
        this.onItemTap.emit(event);
    };
    MbscListview.prototype._getItem = function (nativeEl) {
        return this.items.find(function (item) {
            return item.elem.nativeElement === nativeEl;
        });
    };
    MbscListview.prototype.initControl = function () {
        var _this = this;
        var onItemTap = this.tapHandler.bind(this);
        var onItemTapUser = this.options && this.options.onItemTap;
        if (onItemTapUser) {
            onItemTap = function (event, inst) {
                _this.tapHandler(event, inst);
                return onItemTapUser(event, inst);
            };
        }
        var options = extend$1({
            listNode: 'mbsc-listview',
            listSelector: 'mbsc-listview, mbsc-listview-sublist',
            itemNode: 'mbsc-listview-item',
            itemSelector: 'mbsc-listview-item, mbsc-listview-header'
        }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, { onItemTap: onItemTap });
        this.instance = new ListView(this.elem.nativeElement, options);
        this.lvService.notifyInstanceReady(this.instance);
    };
    MbscListview.prototype.ngOnDestroy = function () {
        this.lvService.onCardContent().unsubscribe(this.cardObserver);
        this.lvService.onItemAdded().unsubscribe(this.addObserver);
        this.lvService.onItemRemoved().unsubscribe(this.removeObserver);
        _super.prototype.ngOnDestroy.call(this);
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "actions", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscListview.prototype, "actionsWidth", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "context", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "striped", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "animateAddRemove", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "actionable", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "animateIcons", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "enhance", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "fillAnimation", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "fixedHeader", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "hover", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "iconSlide", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "itemGroups", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscListview.prototype, "loadingIcon", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "navigateOnDrop", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "quickSwipe", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscListview.prototype, "select", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "sortable", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscListview.prototype, "sortDelay", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "stages", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "swipe", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Function)
    ], MbscListview.prototype, "swipeleft", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Function)
    ], MbscListview.prototype, "swiperight", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscListview.prototype, "vibrate", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscListview.prototype, "undoText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscListview.prototype, "backText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onItemTap", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onItemAdd", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onItemRemove", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onListEnd", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onNavEnd", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onNavStart", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSlideEnd", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSlideStart", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSort", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSortChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSortStart", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSortEnd", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onSortUpdate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscListview.prototype, "onStageChange", void 0);
    __decorate([
        Input$1('options'),
        __metadata("design:type", Object)
    ], MbscListview.prototype, "options", void 0);
    __decorate([
        ContentChildren(MbscListviewItem, { descendants: true }),
        __metadata("design:type", QueryList)
    ], MbscListview.prototype, "items", void 0);
    MbscListview = __decorate([
        Component({
            selector: 'mbsc-listview',
            template: "<ng-content></ng-content>",
            providers: [MbscListviewService],
            exportAs: 'mobiscroll',
            host: {
                'class': 'mbsc-cloak',
                '[class.mbsc-card-list]': 'cardContent'
            }
        }),
        __param(3, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, MbscListviewService, MbscOptionsService])
    ], MbscListview);
    return MbscListview;
}(MbscBase));
var comp$1 = [
    MbscListview,
    MbscListviewItem,
    MbscListviewHeader,
    MbscListviewSublist
];
var MbscListviewModule = (function () {
    function MbscListviewModule() {
    }
    MbscListviewModule = __decorate([
        NgModule({
            imports: [MbscBaseModule],
            declarations: comp$1,
            exports: comp$1
        })
    ], MbscListviewModule);
    return MbscListviewModule;
}());

var MbscPopup = (function (_super) {
    __extends(MbscPopup, _super);
    function MbscPopup(initialElem, optionService, zone) {
        var _this = _super.call(this, initialElem, zone) || this;
        _this.optionService = optionService;
        _this.onBeforeClose = new EventEmitter();
        _this.onBeforeShow = new EventEmitter();
        _this.onCancel = new EventEmitter();
        _this.onClose = new EventEmitter();
        _this.onDestroy = new EventEmitter();
        _this.onFill = new EventEmitter();
        _this.onMarkupReady = new EventEmitter();
        _this.onPosition = new EventEmitter();
        _this.onShow = new EventEmitter();
        _this.onSet = new EventEmitter();
        return _this;
    }
    MbscPopup.prototype.ngAfterViewInit = function () {
        this.getInlineEvents();
        var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);
        this.instance = new Popup(this.initialElem.nativeElement, options);
    };
    __decorate([
        Input$1('options'),
        __metadata("design:type", Object)
    ], MbscPopup.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscPopup.prototype, "anchor", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscPopup.prototype, "animate", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscPopup.prototype, "buttons", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscPopup.prototype, "closeOnOverlayTap", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscPopup.prototype, "context", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscPopup.prototype, "disabled", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscPopup.prototype, "display", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscPopup.prototype, "focusOnClose", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscPopup.prototype, "focusTrap", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscPopup.prototype, "headerText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscPopup.prototype, "showOnFocus", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscPopup.prototype, "showOnTap", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscPopup.prototype, "touchUi", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscPopup.prototype, "okText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscPopup.prototype, "cancelText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onBeforeClose", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onBeforeShow", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onCancel", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onClose", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onDestroy", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onFill", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onMarkupReady", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onPosition", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onShow", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscPopup.prototype, "onSet", void 0);
    MbscPopup = __decorate([
        Component({
            selector: 'mbsc-popup',
            template: "<ng-content></ng-content>",
            exportAs: 'mobiscroll',
            host: { 'class': 'mbsc-cloak' }
        }),
        __param(1, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscOptionsService, NgZone])
    ], MbscPopup);
    return MbscPopup;
}(MbscBase));
var MbscWidget = (function (_super) {
    __extends(MbscWidget, _super);
    function MbscWidget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MbscWidget = __decorate([
        Component({
            selector: 'mbsc-widget',
            template: "<ng-content></ng-content>",
            exportAs: 'mobiscroll',
            host: { 'class': 'mbsc-cloak' }
        })
    ], MbscWidget);
    return MbscWidget;
}(MbscPopup));
var MbscPopupModule = (function () {
    function MbscPopupModule() {
    }
    MbscPopupModule = __decorate([
        NgModule({
            imports: [MbscBaseModule],
            declarations: [MbscPopup, MbscWidget],
            exports: [MbscPopup, MbscWidget]
        })
    ], MbscPopupModule);
    return MbscPopupModule;
}());

var RangePicker = Scroller;
var defaults$5 = {
  autoCorrect: true,
  showSelector: true,
  minRange: 1,
  rangeTap: true
};

presets.range = function (inst) {
  // Private functions
  // ---
  function normalize(d, ref) {
    if (d) {
      d.setFullYear(ref.getFullYear());
      d.setMonth(ref.getMonth());
      d.setDate(ref.getDate());
    }
  }

  function normalizeTime(date, isEnd) {
    var o = inst._order,
        d = new Date(date);

    if (o.h === undefined) {
      d.setHours(isEnd ? 23 : 0);
    }

    if (o.i === undefined) {
      d.setMinutes(isEnd ? 59 : 0);
    }

    if (o.s === undefined) {
      d.setSeconds(isEnd ? 59 : 0);
    }

    d.setMilliseconds(isEnd ? 999 : 0);
    return d;
  }

  function updateInputs(change) {
    inst._startDate = startDate = tempStartDate;
    inst._endDate = endDate = tempEndDate;

    if (s.startInput) {
      $$1(s.startInput).val(inst.startVal);

      if (change) {
        $$1(s.startInput).trigger('change');
      }
    }

    if (s.endInput) {
      $$1(s.endInput).val(inst.endVal);

      if (change) {
        $$1(s.endInput).trigger('change');
      }
    }
  }

  function addDays(d, days) {
    return new Date(d.getFullYear(), d.getMonth(), d.getDate() + days);
  }

  function checkRangeSize(curr) {
    if (hasTime) {
      // Check exact times in milliseconds for min and max ranges
      if (tempEndDate - tempStartDate > s.maxRange - 1) {
        if (curr) {
          tempStartDate = new Date(Math.max(minDate, tempEndDate - s.maxRange + 1));
        } else {
          tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.maxRange - 1));
        }
      }

      if (tempEndDate - tempStartDate < s.minRange - 1) {
        if (curr) {
          tempStartDate = new Date(Math.max(minDate, tempEndDate - s.minRange + 1));
        } else {
          tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.minRange - 1));
        }
      }
    } else {
      // Work with days only, not milliseconds. This way daylight saving times are handled
      if (Math.ceil((tempEndDate - tempStartDate) / oneDay) > maxDays) {
        if (curr) {
          tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - maxDays)), false);
        } else {
          tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, maxDays - 1)), true);
        }
      }

      if (Math.ceil((tempEndDate - tempStartDate) / oneDay) < minDays) {
        if (curr) {
          tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - minDays)), false);
        } else {
          tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, minDays - 1)), true);
        }
      }
    }
  }

  function validate(dates, ui) {
    var ret = true;

    if (dates && tempStartDate && tempEndDate) {
      // We need to check this 2 times, because the
      // corrected range is constrained by min/max dates
      checkRangeSize(curr);
      checkRangeSize(!curr);
    }

    if (!tempStartDate || !tempEndDate) {
      ret = false;
    }

    if (ui) {
      highlightDays();
    }

    return ret;
  }

  function calcDayNr() {
    return tempStartDate && tempEndDate ? Math.max(1, Math.round((new Date(tempEndDate).setHours(0, 0, 0, 0) - new Date(tempStartDate).setHours(0, 0, 0, 0)) / 86400000) + 1) : 0;
  }

  function selectTab(tab) {
    tab.addClass(selectedClass).attr('aria-checked', 'true');
  }

  function setActiveTab() {
    if (showSelector && ctx) {
      $$1('.mbsc-range-btn', ctx).removeClass(selectedClass).removeAttr('aria-checked');
      selectTab($$1('.mbsc-range-btn', ctx).eq(curr));
    }
  }

  function highlightDays() {
    var start,
        startT,
        end,
        endT,
        hl,
        nr = 0,
        startClass = autoChange || !curr ? ' mbsc-cal-day-hl mbsc-cal-sel-start' : ' mbsc-cal-sel-start',
        endClass = autoChange || curr ? ' mbsc-cal-day-hl mbsc-cal-sel-end' : ' mbsc-cal-sel-end';
    inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';
    inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';

    if (ctx) {
      $$1('.mbsc-range-btn-v-start', ctx).html(inst.startVal || '&nbsp;');
      $$1('.mbsc-range-btn-v-end', ctx).html(inst.endVal || '&nbsp;'); // Highlight dates

      start = tempStartDate ? new Date(tempStartDate) : null;
      end = tempEndDate ? new Date(tempEndDate) : null;

      if (!start && end) {
        start = new Date(end);
      }

      if (!end && start) {
        end = new Date(start);
      }

      hl = curr ? end : start;
      $$1('.mbsc-cal-day-picker .mbsc-cal-day-hl', ctx).removeClass(highlightClass);
      $$1('.mbsc-cal-day-picker .mbsc-selected', ctx).removeClass('mbsc-cal-sel-start mbsc-cal-sel-end ' + selectedClass).removeAttr('aria-selected');

      if (start && end) {
        startT = start.setHours(0, 0, 0, 0);
        endT = end.setHours(0, 0, 0, 0);

        while (end >= start && nr < 126) {
          $$1('.mbsc-cal-day[data-full="' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '"]', ctx).addClass(selectedClass + ' ' + (hl.getTime() === startT ? startClass : '') + (hl.getTime() === endT ? endClass : '')).attr('aria-selected', 'true');
          hl.setDate(hl.getDate() + (curr ? -1 : 1));
          hl.setHours(0, 0, 0, 0);
          nr++;
        }
      }
    }
  }

  function setTimeInfo(d, end) {
    return {
      h: d ? d.getHours() : end ? 23 : 0,
      i: d ? d.getMinutes() : end ? 59 : 0,
      s: d ? d.getSeconds() : end ? 59 : 0
    };
  }

  function validateDates() {
    if (tempStartDate) {
      init = true;
      inst.setDate(tempStartDate, false, 0, true);
      tempStartDate = inst.getDate(true);
    }

    if (tempEndDate) {
      init = true;
      inst.setDate(tempEndDate, false, 0, true);
      tempEndDate = inst.getDate(true);
    }
  }

  function onBtnClick(ev) {
    if (testTouch(ev, this)) {
      inst._showDayPicker();

      inst.setActiveDate($$1(this).attr('data-select'));
    }
  } // ---


  var base,
      ctx,
      dayChange,
      format,
      hasTime,
      init,
      maxDate,
      minDate,
      set,
      tempStartDate,
      tempStartTime,
      tempEndDate,
      tempEndTime,
      timeOnly,
      showSelector,
      startDate = inst._startDate,
      endDate = inst._endDate,
      curr = 0,
      now = new Date(),
      orig = extend$1({}, inst.settings),
      s = extend$1(inst.settings, defaults$5, orig),
      startAnchor = s.anchor,
      autoChange = s.rangeTap,
      oneDay = 24 * 60 * 60 * 1000,
      minDays = Math.max(1, Math.ceil(s.minRange / oneDay)),
      maxDays = Math.max(1, Math.ceil(s.maxRange / oneDay)),
      disabledClass = 'mbsc-disabled ' + (s.disabledClass || ''),
      selectedClass = 'mbsc-selected ' + (s.selectedClass || ''),
      highlightClass = 'mbsc-cal-day-hl',
      def = s.defaultValue === null ? [] : s.defaultValue || [new Date(now.setHours(0, 0, 0, 0)), new Date(now.getFullYear(), now.getMonth(), now.getDate() + 6, 23, 59, 59, 999)];

  if (autoChange) {
    s.tabs = true;
  }

  base = CalendarBase.call(this, inst);
  format = inst._format;
  hasTime = /time/i.test(s.controls.join(','));
  timeOnly = s.controls.join('') === 'time';
  showSelector = s.showSelector;
  maxDate = s.max ? normalizeTime(makeDate(s.max, format, s), true) : Infinity;
  minDate = s.min ? normalizeTime(makeDate(s.min, format, s), false) : -Infinity;
  def[0] = makeDate(def[0], format, s, s.isoParts);
  def[1] = makeDate(def[1], format, s, s.isoParts);

  if (s.startInput) {
    inst.attachShow($$1(s.startInput), function () {
      curr = 0;
      s.anchor = startAnchor || $$1(s.startInput);
    });
  }

  if (s.endInput) {
    inst.attachShow($$1(s.endInput), function () {
      curr = 1;
      s.anchor = startAnchor || $$1(s.endInput);
    });
  }

  inst._getDayProps = function (d, props) {
    var start = tempStartDate ? new Date(tempStartDate.getFullYear(), tempStartDate.getMonth(), tempStartDate.getDate()) : null,
        end = tempEndDate ? new Date(tempEndDate.getFullYear(), tempEndDate.getMonth(), tempEndDate.getDate()) : null;
    return {
      selected: start && end && d >= start && d <= tempEndDate,
      cssClass: props.cssClass + ' ' + ((autoChange || !curr) && start && start.getTime() === d.getTime() || (autoChange || curr) && end && end.getTime() === d.getTime() ? highlightClass : '') + (start && start.getTime() === d.getTime() ? ' mbsc-cal-sel-start' : '') + (end && end.getTime() === d.getTime() ? ' mbsc-cal-sel-end' : '')
    };
  }; // Extended methods
  // ---


  inst.setVal = function (values, fill, change, temp, time) {
    var v = values || [],
        d = values;
    tempStartDate = makeDate(v[0], format, s, s.isoParts);
    tempEndDate = makeDate(v[1], format, s, s.isoParts);
    validateDates();
    inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';
    inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';
    d = base.parseValue(curr ? tempEndDate : tempStartDate, inst);

    if (!temp) {
      inst._startDate = startDate = tempStartDate;
      inst._endDate = endDate = tempEndDate;
    }

    set = true;

    inst._setVal(d, fill, change, temp, time);
  };

  inst.getVal = function (temp) {
    return temp ? [returnDate(tempStartDate, s, format), returnDate(tempEndDate, s, format)] : inst._hasValue ? [returnDate(startDate, s, format), returnDate(endDate, s, format)] : null;
  };

  inst.setActiveDate = function (active) {
    var hl; //if (!autoChange) {

    curr = active == 'start' ? 0 : 1; //}

    hl = active == 'start' ? tempStartDate : tempEndDate;

    if (inst.isVisible()) {
      //if (!autoChange) {
      setActiveTab();

      if (!autoChange) {
        $$1('.mbsc-cal-table .mbsc-cal-day-hl', ctx).removeClass(highlightClass);

        if (hl) {
          $$1('.mbsc-cal-day[data-full="' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '"]', ctx).addClass(highlightClass);
        }
      }

      if (hl) {
        init = true;
        inst.setDate(hl, false, 1000, true);
      }
    }
  };

  inst.getValue = inst.getVal; // ---
  // ---

  return extend$1({}, base, {
    highlight: false,
    outerMonthChange: false,
    formatValue: function formatValue() {
      return inst.startVal + (s.endInput ? '' : inst.endVal ? ' - ' + inst.endVal : '');
    },
    parseValue: function parseValue(v) {
      var parts = v ? v.split(' - ') : [],
          startVal = s.startInput ? $$1(s.startInput).val() : parts[0],
          endVal = s.endInput ? $$1(s.endInput).val() : parts[1];
      s.defaultValue = def[1]; // used by parseDate

      endDate = endVal ? parseDate(format, endVal, s) : def[1];
      s.defaultValue = def[0]; // used by parseDate

      startDate = startVal ? parseDate(format, startVal, s) : def[2];
      s.defaultValue = def[curr];
      inst.startVal = startDate ? formatDate(format, startDate, s) : '';
      inst.endVal = endDate ? formatDate(format, endDate, s) : '';
      inst._startDate = startDate;
      inst._endDate = endDate;
      return base.parseValue(curr ? endDate : startDate, inst);
    },
    onFill: function onFill(ev) {
      updateInputs(ev.change);
    },
    onBeforeClose: function onBeforeClose(ev) {
      // Don't allow invalid selection
      if (ev.button === 'set' && !validate(true, true)) {
        inst.setActiveDate(curr ? 'start' : 'end');
        return false;
      }
    },
    onHide: function onHide() {
      base.onHide.call(inst);
      curr = 0;
      ctx = null;
      s.anchor = startAnchor;
    },
    onClear: function onClear() {
      if (autoChange) {
        curr = 0;
      }
    },
    onBeforeShow: function onBeforeShow() {
      tempStartDate = startDate || def[0];
      tempEndDate = endDate || def[1];
      tempStartTime = setTimeInfo(tempStartDate, 0);
      tempEndTime = setTimeInfo(tempEndDate, 1);

      if (s.counter) {
        s.headerText = function () {
          var nr = calcDayNr();
          return (nr > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, nr);
        };
      }

      set = true;
    },
    onMarkupReady: function onMarkupReady(ev) {
      var html; // Validate start end end dates

      validateDates(); // Set the current date (start or end)

      if (curr && tempEndDate || !curr && tempStartDate) {
        init = true;
        inst.setDate(curr ? tempEndDate : tempStartDate, false, 0, true);
      }

      highlightDays(); // Call calbase

      base.onMarkupReady.call(this, ev);
      ctx = $$1(ev.target);
      ctx.addClass('mbsc-range');

      if (showSelector) {
        html = '<div class="mbsc-range-btn-t" role="radiogroup">' + '<div class="mbsc-range-btn-c mbsc-range-btn-start"><div role="radio" data-select="start" class="mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn">' + s.fromText + '<div class="mbsc-range-btn-v mbsc-range-btn-v-start">' + (inst.startVal || '&nbsp;') + '</div></div></div>' + '<div class="mbsc-range-btn-c mbsc-range-btn-end"><div role="radio" data-select="end" class="mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn">' + s.toText + '<div class="mbsc-range-btn-v mbsc-range-btn-v-end">' + (inst.endVal || '&nbsp;') + '</div></div></div>' + '</div>';

        if (s.headerText) {
          $$1('.mbsc-fr-hdr', ctx).after(html);
        } else {
          $$1('.mbsc-fr-w', ctx).prepend(html);
        }

        setActiveTab();
      }

      $$1('.mbsc-range-btn', ctx).each(function (i, el) {
        listen(el, 'touchstart', onBtnClick, {
          passive: true
        });
        listen(el, 'click', onBtnClick);
      });
    },
    onDayChange: function onDayChange(day) {
      day.active = curr ? 'end' : 'start';
      dayChange = true;
    },
    onSetDate: function onSetDate(day) {
      var d;

      if (!init) {
        d = normalizeTime(day.date, curr);

        if (!set || dayChange) {
          if (autoChange && dayChange) {
            if (curr == 1 && d < tempStartDate) {
              curr = 0;
            }

            if (curr) {
              d.setHours(tempEndTime.h, tempEndTime.i, tempEndTime.s, 999);
            } else {
              d.setHours(tempStartTime.h, tempStartTime.i, tempStartTime.s, 0);
            }
          }

          if (curr) {
            tempEndDate = new Date(d);
            tempEndTime = setTimeInfo(tempEndDate);
          } else {
            tempStartDate = new Date(d);
            tempStartTime = setTimeInfo(tempStartDate);
          } // Make sure times are on the same day for comparison


          if (timeOnly && s.autoCorrect) {
            normalize(tempStartDate, d);
            normalize(tempEndDate, d);
          } // Set end date on start selection if rangeTap is enabled


          if (autoChange && dayChange && !curr) {
            //tempEndDate = new Date(d.setHours(23, 59, 59, 999));
            tempEndDate = null;
          }
        }
      }

      if (timeOnly && !s.autoCorrect && tempEndDate < tempStartDate) {
        // Set end time to next day
        tempEndDate = new Date(tempEndDate.setDate(tempEndDate.getDate() + 1));
      } // Validate min/max ranges


      inst._isValid = validate(set || dayChange || s.autoCorrect, !init);
      day.active = curr ? 'end' : 'start'; // Toggle start/end if rangeTap is enabled

      if (!init && autoChange) {
        if (dayChange) {
          curr = curr ? 0 : 1;
        }

        setActiveTab();
      }

      if (inst.isVisible()) {
        // Disable set button
        if (inst._isValid) {
          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).removeClass(disabledClass);
        } else {
          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).addClass(disabledClass);
        }
      }

      dayChange = false;
      set = false;
      init = false;
    },
    onTabChange: function onTabChange(ev) {
      if (ev.tab != 'calendar') {
        inst.setDate(curr ? tempEndDate : tempStartDate, false, 1000, true);
      }

      validate(true, true);
    }
  });
};

var RANGE_SUB_TEMPLATE = "<mbsc-input\n    [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [disabled]=\"disabled\" [placeholder]=\"placeholder\"\n    [error]=\"error\" [errorMessage]=\"errorMessage\" \n    [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n    <ng-content></ng-content>\n</mbsc-input>";
var MbscRangeStartComponent = (function () {
    function MbscRangeStartComponent(host, parent, zone, control) {
        this.host = host;
        this.parent = parent;
        this.zone = zone;
        this.control = control;
        this.theme = undefined;
        this.errorMessage = '';
        this.placeholder = '';
        this.rangeIndex = 0;
        this.oldAccessor = null;
        this.onChange = function (value) { };
        this.onTouch = function () { };
        this.initialSet = true;
        this.checkAccessor();
    }
    Object.defineProperty(MbscRangeStartComponent.prototype, "element", {
        get: function () {
            var i = $$1(this.host.nativeElement).find('input');
            return i[0];
        },
        enumerable: true,
        configurable: true
    });
    MbscRangeStartComponent.prototype.checkAccessor = function () {
        if (this.control) {
            if (this.control.valueAccessor !== this) {
                this.oldAccessor = this.control.valueAccessor;
            }
            this.control.valueAccessor = this;
        }
    };
    MbscRangeStartComponent.prototype.handleChange = function () {
        var _this = this;
        $$1(this.element).on('change', function () {
            _this.zone.run(function () {
                var arr = _this.parent.instance.getVal(), value = arr ? arr[_this.rangeIndex] : undefined, current = undefined, valueText = _this.parent.instance[_this.rangeIndex === 0 ? 'startVal' : 'endVal'];
                if (arr && value && _this.element.value !== valueText && _this.parent.enableManualEdit) {
                    var newArr = new Array(2), otherIndex = _this.rangeIndex === 1 ? 0 : 1;
                    newArr[_this.rangeIndex] = _this.element.value;
                    newArr[otherIndex] = arr[otherIndex];
                    _this.parent.instance.setVal(newArr, true, true);
                }
                else {
                    if (_this.control && _this.control.value && _this.control.value instanceof Array) {
                        current = _this.control.value[_this.rangeIndex];
                    }
                    else if (_this.control && _this.control.value) {
                        current = _this.control.value;
                    }
                    if (_this.control) {
                        if (!isDateEqual(current, value)) {
                            _this.onChange(value);
                            _this.control.control.patchValue(value);
                        }
                    }
                }
            });
        });
    };
    MbscRangeStartComponent.prototype.ngAfterViewInit = function () {
        this.handleChange();
        this.checkAccessor();
    };
    MbscRangeStartComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    MbscRangeStartComponent.prototype.registerOnTouched = function (fn) {
        this.onTouch = fn;
    };
    MbscRangeStartComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.oldAccessor && this.oldAccessor.setDisabledState) {
            this.oldAccessor.setDisabledState(isDisabled);
        }
    };
    MbscRangeStartComponent.prototype.writeValue = function (v) {
        var _this = this;
        if (this.parent && this.parent.instance) {
            var arr_1 = this.parent.instance.getVal(), val = (arr_1 && arr_1.length) ? arr_1[this.rangeIndex] : undefined;
            if (!isDateEqual(v, val)) {
                if (v === undefined) {
                    arr_1 = undefined;
                }
                else {
                    arr_1 = arr_1 || [];
                    arr_1[this.rangeIndex] = v;
                }
                this.parent.instance.setVal(arr_1, true, false);
                if (this.initialSet) {
                    setTimeout(function () {
                        _this.parent.instance.setVal(arr_1, true, false);
                        _this.initialSet = false;
                    });
                }
            }
        }
    };
    __decorate([
        Input$1('icon'),
        __metadata("design:type", String)
    ], MbscRangeStartComponent.prototype, "inputIcon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscRangeStartComponent.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRangeStartComponent.prototype, "name", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscRangeStartComponent.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRangeStartComponent.prototype, "errorMessage", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscRangeStartComponent.prototype, "disabled", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRangeStartComponent.prototype, "placeholder", void 0);
    MbscRangeStartComponent = __decorate([
        Component({
            selector: 'mbsc-range-start',
            template: RANGE_SUB_TEMPLATE
        }),
        __param(1, Inject(forwardRef(function () { return MbscRangeComponent; }))), __param(3, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscRangeComponent, NgZone, NgControl])
    ], MbscRangeStartComponent);
    return MbscRangeStartComponent;
}());
var MbscRangeEndComponent = (function (_super) {
    __extends(MbscRangeEndComponent, _super);
    function MbscRangeEndComponent(el, parent, zone, control) {
        var _this = _super.call(this, el, parent, zone, control) || this;
        _this.rangeIndex = 1;
        return _this;
    }
    MbscRangeEndComponent = __decorate([
        Component({
            selector: 'mbsc-range-end',
            template: RANGE_SUB_TEMPLATE,
        }),
        __param(1, Inject(forwardRef(function () { return MbscRangeComponent; }))), __param(3, Optional()),
        __metadata("design:paramtypes", [ElementRef, MbscRangeComponent, NgZone, NgControl])
    ], MbscRangeEndComponent);
    return MbscRangeEndComponent;
}(MbscRangeStartComponent));
var MbscRange = (function (_super) {
    __extends(MbscRange, _super);
    function MbscRange(initialElem, zone, control, inputService, optionService, view) {
        var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;
        _this.optionService = optionService;
        _this.onSetDate = new EventEmitter();
        _this.onCellHoverIn = new EventEmitter();
        _this.onCellHoverOut = new EventEmitter();
        _this.onDayChange = new EventEmitter();
        _this.options = {};
        _this.onChangeEmitter = new EventEmitter();
        return _this;
    }
    Object.defineProperty(MbscRange.prototype, "endInput", {
        set: function (v) {
            var element = v;
            if (typeof v == "string") {
                var hasInput = $$1(v).find('input');
                if (hasInput.length) {
                    element = hasInput[0];
                }
            }
            this._endInput = element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRange.prototype, "startInput", {
        set: function (v) {
            var element = v;
            if (typeof v == "string") {
                var hasInput = $$1(v).find('input');
                if (hasInput.length) {
                    element = hasInput[0];
                }
            }
            this._startInput = element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MbscRange.prototype, "value", {
        set: function (v) {
            this.setNewValueProxy(v);
        },
        enumerable: true,
        configurable: true
    });
    MbscRange.prototype.setNewValue = function (v) {
        if (this.instance) {
            if (!deepEqualsArray(v, this.instance.getVal())) {
                this.instance.setVal(v, true, false);
                if (this._inputService && this._inputService.input) {
                    this._inputService.input.innerValue = this.instance._value;
                }
            }
        }
    };
    Object.defineProperty(MbscRange.prototype, "optionExtensions", {
        get: function () {
            var _this = this;
            var externalOnClose = this.options && this.options.onClose;
            var externalOnFill = this.options && this.options.onFill;
            var onCloseEmitter = this.onClose;
            return {
                onFill: function (event, inst) {
                    if (!_this._wrapper) {
                        if (_this.oldAccessor) {
                            _this.oldAccessor.writeValue(event.valueText);
                        }
                    }
                    if (externalOnFill) {
                        externalOnFill(event, inst);
                    }
                },
                onClose: function (event, inst) {
                    _this.onTouch();
                    if (externalOnClose) {
                        externalOnClose(event, inst);
                    }
                    if (onCloseEmitter) {
                        event.inst = inst;
                        onCloseEmitter.emit(event);
                    }
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    MbscRange.prototype.initControl = function () {
        var options = extend$1({
            preset: 'range',
            skipShow: this._wrapper
        }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {
            endInput: this._wrapper ? this.end.element : this._endInput,
            startInput: this._wrapper ? this.start.element : this._startInput
        }, this.optionExtensions);
        this.instance = new RangePicker(this._wrapper ? this.initialElem.nativeElement : this.element, options);
        if (this.initialValue) {
            this.instance.setVal(this.initialValue, true, false);
        }
    };
    MbscRange.prototype.ngAfterContentInit = function () {
        if (this.start || this.end) {
            this._wrapper = true;
        }
        else {
            this._wrapper = false;
        }
    };
    MbscRange.prototype.handleChange = function () {
        var _this = this;
        if (this._wrapper) {
            $$1(this.start.element).on('change', function () {
                _this.zone.run(function () {
                    var value = _this.instance.getVal();
                    if (_this.control) {
                        if (!deepEqualsArray(_this.control.value, value)) {
                            _this.onChange(value);
                            _this.control.control.patchValue(value);
                        }
                    }
                    else {
                        _this.onChangeEmitter.emit(value);
                    }
                });
            });
            $$1(this.end.element).on('change', function () {
                _this.zone.run(function () {
                    var value = _this.instance.getVal();
                    if (_this.control) {
                        if (!deepEqualsArray(_this.control.value, value)) {
                            _this.onChange(value);
                            _this.control.control.patchValue(value);
                        }
                    }
                    else {
                        _this.onChangeEmitter.emit(value);
                    }
                });
            });
        }
        else {
            var that_1 = this;
            $$1(this.element).on('change', function () {
                that_1.zone.run(function () {
                    if (that_1.element.value !== that_1.instance._value && that_1.enableManualEdit) {
                        var v = that_1.element.value && that_1.element.value.split(' - ');
                        if (v) {
                            that_1.instance.setVal(v, true, true);
                        }
                    }
                    else {
                        var value = that_1.instance.getVal();
                        if (that_1.control) {
                            that_1.onChange(value);
                            that_1.control.control.patchValue(value);
                        }
                        else {
                            that_1.onChangeEmitter.emit(value);
                        }
                    }
                });
            });
        }
    };
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscRange.prototype, "autoCorrect", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Array)
    ], MbscRange.prototype, "controls", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MbscRange.prototype, "endInput", null);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscRange.prototype, "maxRange", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Number)
    ], MbscRange.prototype, "minRange", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscRange.prototype, "showSelector", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], MbscRange.prototype, "startInput", null);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRange.prototype, "fromText", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRange.prototype, "toText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscRange.prototype, "onSetDate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscRange.prototype, "onCellHoverIn", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscRange.prototype, "onCellHoverOut", void 0);
    __decorate([
        Output(),
        __metadata("design:type", EventEmitter)
    ], MbscRange.prototype, "onDayChange", void 0);
    __decorate([
        ContentChild(MbscRangeStartComponent, { static: false }),
        __metadata("design:type", MbscRangeStartComponent)
    ], MbscRange.prototype, "start", void 0);
    __decorate([
        ContentChild(MbscRangeEndComponent, { static: false }),
        __metadata("design:type", MbscRangeEndComponent)
    ], MbscRange.prototype, "end", void 0);
    __decorate([
        Input$1('mbsc-options'),
        __metadata("design:type", Object)
    ], MbscRange.prototype, "options", void 0);
    __decorate([
        Input$1('mbsc-range'),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], MbscRange.prototype, "value", null);
    __decorate([
        Output('mbsc-rangeChange'),
        __metadata("design:type", EventEmitter)
    ], MbscRange.prototype, "onChangeEmitter", void 0);
    MbscRange = __decorate([
        Directive({
            selector: '[mbsc-range]',
            exportAs: 'mobiscroll'
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])
    ], MbscRange);
    return MbscRange;
}(MbscCalBase));
var MbscRangeComponent = (function (_super) {
    __extends(MbscRangeComponent, _super);
    function MbscRangeComponent(initialElem, zone, control, inputService, optionService) {
        var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;
        _this.errorMessage = '';
        _this.placeholder = '';
        return _this;
    }
    MbscRangeComponent.prototype.ngAfterViewInit = function () {
        _super.prototype.ngAfterViewInit.call(this);
        this.setThemeClasses();
    };
    __decorate([
        Input$1('icon'),
        __metadata("design:type", String)
    ], MbscRangeComponent.prototype, "inputIcon", void 0);
    __decorate([
        Input$1('icon-align'),
        __metadata("design:type", String)
    ], MbscRangeComponent.prototype, "iconAlign", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRangeComponent.prototype, "name", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Boolean)
    ], MbscRangeComponent.prototype, "error", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRangeComponent.prototype, "errorMessage", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", Object)
    ], MbscRangeComponent.prototype, "options", void 0);
    __decorate([
        Input$1(),
        __metadata("design:type", String)
    ], MbscRangeComponent.prototype, "placeholder", void 0);
    MbscRangeComponent = __decorate([
        Component({
            selector: 'mbsc-range',
            exportAs: 'mobiscroll',
            template: "<ng-content select=\"mbsc-range-start\"></ng-content>\n    <ng-content select=\"mbsc-range-end\"></ng-content>\n    <mbsc-input *ngIf=\"!_wrapper && (!inline || showInput)\" \n        [controlNg]=\"false\" [name]=\"name\" [theme]=\"theme\" [disabled]=\"disabled\" [dropdown]=\"dropdown\" [placeholder]=\"placeholder\"\n        [error]=\"error\" [errorMessage]=\"errorMessage\" \n        [icon]=\"inputIcon\" [icon-align]=\"iconAlign\">\n        <ng-content></ng-content>\n    </mbsc-input>",
        }),
        __param(2, Optional()), __param(3, Optional()), __param(4, Optional()),
        __metadata("design:paramtypes", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])
    ], MbscRangeComponent);
    return MbscRangeComponent;
}(MbscRange));
var MbscRangeModule = (function () {
    function MbscRangeModule() {
    }
    MbscRangeModule = __decorate([
        NgModule({
            imports: [CommonModule, MbscCalBaseModule, MbscInputModule],
            declarations: [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent],
            exports: [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent]
        })
    ], MbscRangeModule);
    return MbscRangeModule;
}());

var directives = [
    MbscInput,
    MbscCalendar, MbscCalendarComponent,
    MbscDate, MbscTime, MbscDatetime, MbscDateComponent, MbscTimeComponent, MbscDatetimeComponent,
    MbscEventcalendar, MbscEventcalendarComponent,
    MbscListview, MbscListviewSublist, MbscListviewItem, MbscListviewHeader,
    MbscPopup, MbscWidget,
    MbscRange, MbscRangeComponent, MbscRangeStartComponent, MbscRangeEndComponent,
];
var modules = [
    MbscInputModule,
    MbscCalendarModule,
    MbscDatetimeModule,
    MbscEventcalendarModule,
    MbscListviewModule,
    MbscPopupModule,
    MbscRangeModule,
];
var MbscModule = (function () {
    function MbscModule() {
    }
    MbscModule_1 = MbscModule;
    MbscModule.forRoot = function (config) {
        return {
            ngModule: MbscModule_1,
            providers: [{
                    provide: MbscRouterToken,
                    useExisting: config.angularRouter
                }]
        };
    };
    var MbscModule_1;
    MbscModule = MbscModule_1 = __decorate([
        NgModule({
            imports: [FormsModule, CommonModule, modules],
            exports: [directives, modules]
        })
    ], MbscModule);
    return MbscModule;
}());

// Espaol
mobiscroll.i18n.es = {
  // Core
  setText: 'Aceptar',
  cancelText: 'Cancelar',
  clearText: 'Borrar',
  selectedText: '{count} seleccionado',
  selectedPluralText: '{count} seleccionados',
  // Datetime component
  dateFormat: 'dd/mm/yy',
  dayNames: ['Domingo', 'Lunes', 'Martes', 'Mircoles', 'Jueves', 'Viernes', 'Sbado'],
  dayNamesShort: ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'S'],
  dayNamesMin: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
  dayText: 'Da',
  hourText: 'Horas',
  minuteText: 'Minutos',
  monthNames: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
  monthNamesShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
  monthText: 'Mes',
  secText: 'Segundos',
  timeFormat: 'HH:ii',
  yearText: 'A&ntilde;o',
  nowText: 'Ahora',
  pmText: 'pm',
  amText: 'am',
  todayText: 'Hoy',
  // Calendar component
  firstDay: 1,
  dateText: 'Fecha',
  timeText: 'Tiempo',
  closeText: 'Cerrar',
  allDayText: 'Todo el da',
  noEventsText: 'No hay eventos',
  eventText: 'Evento',
  eventsText: 'Eventos',
  moreEventsText: '{count} ms',
  // Daterange component
  fromText: 'Iniciar',
  toText: 'Final',
  // Measurement components
  wholeText: 'Entero',
  fractionText: 'Fraccin',
  unitText: 'Unidad',
  // Time / Timespan component
  labels: ['Aos', 'Meses', 'Das', 'Horas', 'Minutos', 'Segundos', ''],
  labelsShort: ['Ao', 'Mes', 'Da', 'Hora', 'Min', 'Seg', ''],
  // Timer component
  startText: 'Iniciar',
  stopText: 'Detngase',
  resetText: 'Reinicializar',
  lapText: 'Lap',
  hideText: 'Esconder',
  // Listview
  backText: 'Atrs',
  undoText: 'Deshacer',
  // Form
  offText: 'No',
  onText: 'S',
  // Numpad
  decimalSeparator: ',',
  thousandsSeparator: ' '
};

var themes$1 = mobiscroll.themes;
themes$1.frame.ios = {
  display: 'bottom',
  // frame
  headerText: false,
  // frame
  btnWidth: false,
  // frame
  deleteIcon: 'ios-backspace',
  // numpad
  scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)
};
themes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {
  rows: 5,
  // scroller
  height: 34,
  // scroller
  minWidth: 55,
  // scroller
  selectedLineHeight: true,
  // scroller
  selectedLineBorder: 1,
  // scroller
  showLabel: false,
  // scroller
  useShortLabels: true,
  // timespan/timer
  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',
  // scroller
  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',
  // scroller
  checkIcon: 'ion-ios7-checkmark-empty',
  // select
  filterClearIcon: 'ion-close-circled',
  // select
  dateDisplay: 'MMdyy',
  // date
  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',
  // calendar
  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar

});
themes$1.listview.ios = {
  leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',
  rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'
};
themes$1.form.ios = {};

mobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');

function _addRipple($control, ev) {
  var x = getCoord(ev, 'X', true),
      y = getCoord(ev, 'Y', true),
      control = $control[0],
      rect = $control.offset(),
      left = x - rect.left,
      top = y - rect.top,
      width = Math.max(left, control.offsetWidth - left),
      height = Math.max(top, control.offsetHeight - top),
      size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

  _removeRipple($ripple);

  $ripple = $$1('<span class="mbsc-ripple"></span>').css({
    backgroundColor: getComputedStyle(control).color,
    width: size,
    height: size,
    top: y - rect.top - size / 2,
    left: x - rect.left - size / 2
  }).appendTo($control);
  setTimeout(function () {
    $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');
  }, 10);
}

function _removeRipple($r) {
  setTimeout(function () {
    if ($r) {
      $r.removeClass('mbsc-ripple-visible');
      setTimeout(function () {
        $r.remove();
      }, 2000);
    }
  }, 100);
}

function initRipple($markup, selector, disabled, nohl) {
  var startX,
      startY,
      markup = $markup[0];

  function onStart(ev) {
    var target = closest(markup, ev.target, selector);

    if (target && testTouch(ev, target)) {
      startX = getCoord(ev, 'X');
      startY = getCoord(ev, 'Y');
      $active$1 = $$1(target);

      if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {
        _addRipple($active$1, ev);
      } else {
        $active$1 = null;
      }
    }
  }

  function onMove(ev) {
    if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {
      _removeRipple($ripple);

      $active$1 = null;
    }
  }

  function onEnd() {
    if ($active$1) {
      setTimeout(function () {
        _removeRipple($ripple);
      }, 100);
      $active$1 = null;
    }
  }

  if (markup) {
    if (markup.__mbscRippleOff) {
      markup.__mbscRippleOff();
    }

    listen(markup, 'touchstart', onStart, {
      passive: true
    });
    listen(markup, 'mousedown', onStart);
    listen(markup, 'touchmove', onMove, {
      passive: true
    });
    listen(markup, 'mousemove', onMove);
    listen(markup, 'touchend', onEnd);
    listen(markup, 'touchcancel', onEnd);
    listen(markup, 'mouseleave', onEnd);
    listen(markup, 'mouseup', onEnd);

    markup.__mbscRippleOff = function () {
      unlisten(markup, 'touchstart', onStart, {
        passive: true
      });
      unlisten(markup, 'mousedown', onStart);
      unlisten(markup, 'touchmove', onMove, {
        passive: true
      });
      unlisten(markup, 'mousemove', onMove);
      unlisten(markup, 'touchend', onEnd);
      unlisten(markup, 'touchcancel', onEnd);
      unlisten(markup, 'mouseleave', onEnd);
      unlisten(markup, 'mouseup', onEnd);
      delete markup.__mbscRippleOff;
    };
  }
}

var $active$1,
    $ripple,
    themes$2 = mobiscroll.themes;
themes$2.frame.material = {
  headerText: false,
  btnWidth: false,
  deleteIcon: 'material-backspace',
  onMarkupReady: function onMarkupReady(ev) {
    initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');
  }
};
themes$2.scroller.material = extend$1({}, themes$2.frame.material, {
  showLabel: false,
  selectedLineBorder: 2,
  weekDays: 'min',
  icon: {
    filled: 'material-star',
    empty: 'material-star-outline'
  },
  checkIcon: 'material-check',
  btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',
  btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',
  btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',
  btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'
});
themes$2.listview.material = {
  leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',
  rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',
  onItemActivate: function onItemActivate(ev) {
    _addRipple($$1(ev.target), ev.domEvent);
  },
  onItemDeactivate: function onItemDeactivate() {
    _removeRipple($ripple);
  },
  onSlideStart: function onSlideStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  },
  onSortStart: function onSortStart(ev) {
    $$1('.mbsc-ripple', ev.target).remove();
  }
};
themes$2.navigation.material = {
  onInit: function onInit() {
    initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');
  },
  onMarkupInit: function onMarkupInit() {
    $$1('.mbsc-ripple', this).remove();
  },
  onDestroy: function onDestroy() {
    if (this.__mbscRippleOff) {
      this.__mbscRippleOff();
    }
  }
};
themes$2.form.material = {
  addRipple: function addRipple(elm, ev) {
    _addRipple(elm, ev);
  },
  removeRipple: function removeRipple() {
    _removeRipple($ripple);
  }
};

mobiscroll.customTheme('material-dark', 'material');

mobiscroll.customTheme('ios-dark', 'ios');

mobiscroll.customTheme('negromaterial', 'material');

var themes$3 = mobiscroll.themes;
var theme = 'mobiscroll';

if (os == 'android') {
  theme = 'material';
} else if (os == 'ios') {
  theme = 'ios';
} else if (os == 'wp') {
  theme = 'windows';
}

$$1.each(themes$3.frame, function (key, settings) {
  // Stop at the first custom theme with the OS base theme
  if (theme && settings.baseTheme == theme && key != theme + '-dark') {
    mobiscroll.autoTheme = key;
    return false;
  } else if (key == theme) {
    mobiscroll.autoTheme = key;
  }
});

export { MbscCalendar, MbscCalendarComponent, MbscCalendarModule, MbscDate, MbscDateComponent, MbscDatetime, MbscDatetimeComponent, MbscDatetimeModule, MbscEventcalendar, MbscEventcalendarComponent, MbscEventcalendarModule, MbscInput, MbscInputModule, MbscListview, MbscListviewHeader, MbscListviewItem, MbscListviewModule, MbscListviewSublist, MbscModule, MbscPopup, MbscPopupModule, MbscRange, MbscRangeComponent, MbscRangeEndComponent, MbscRangeModule, MbscRangeStartComponent, MbscTime, MbscTimeComponent, MbscWidget, mobiscroll, MbscRouterToken as a, MbscOptionsService as b, MbscInputService as c, MbscBase as d, MbscValueBase as e, MbscCloneBase as f, MbscControlBase as g, MbscFrameBase as h, MbscScrollerBase as i, MbscBaseModule as j, MbscFrameBaseModule as k, MbscScrollerBaseModule as l, INPUT_TEMPLATE as m, MbscDateBase as n, MbscListviewService as o, MbscSublistService as p, MbscListitemService as q, MbscFormBase as r, MbscFormValueBase as s, MbscInputBase as t, MbscCalBase as u, MbscCalBaseModule as v, MbscDatetimeBase as w, MbscDatetimeBaseModule as x };
